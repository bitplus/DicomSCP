{"version":3,"file":"5717.bundle.0b527d29ba488766ef38.js","mappings":"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B,CAC1B,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAA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","sources":["webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/drawImageSync.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/calculateTransform.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/addVolumesToViewports.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/addImageSlicesToViewports.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/Settings.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/Contour.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/ContourSet.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/cache/classes/Surface.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/enums/BlendModes.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/enums/GeometryType.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/enums/CalibrationTypes.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/enums/GenerateImageType.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/getEnabledElement.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/webWorkerManager/webWorkerManager.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/init.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/loaders/geometryLoader.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/contourSet/createContourSet.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/contourSet/validateContourSet.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/surface/createSurface.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/loaders/utils/surface/validateSurface.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/loaders/volumeLoader.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/ProgressiveIterator.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/RLEVoxelMap.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/actorCheck.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/applyPreset.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/autoLoad.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/clamp.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/colormap.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createLinearRGBTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSigmoidRGBTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/decimate.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepClone.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestImageId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageSliceDataForVolumeViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getMinMax.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getScalingParameters.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSliceRange.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSpacingInNormalDirection.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getTargetVolumeAndSpacingInNormalDir.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportsWithVolumeId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVoiFromSigmoidRGBTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeActorCorners.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeSliceRangeInfo.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportScrollInfo.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/hasFloatScalingParameters.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/hasNaNValues.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageIdToURI.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageRetrieveMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/TargetEventListeners.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/MultiTargetEventListenerManager.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scaleRgbTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getRuntimeId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calibratedPixelSpacingMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isOpposite.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/indexWithinDimensions.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportsContainingSameVolumes.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isPTPrescaledWithSUV.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/renderToCanvasGPU.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/renderToCanvasCPU.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/loadImageToCanvas.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/worldToImageCoords.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageToWorldCoords.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportsWithImageURI.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestStackImageIndexForPoint.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getCurrentVolumeViewportSlice.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/spatialRegistrationMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateViewportsSpatialRegistration.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportImageCornersInWorld.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/PointsManager.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageLegacy.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isValidVolume.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isVideoTransferSyntax.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertStackToVolumeViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertVolumeToStackViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/roundNumber.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertToGrayscale.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportImageIds.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getRandomSampleFromArray.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/color.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepEqual.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/splitImageIdsBy4DTags.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getDynamicVolumeInfo.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scaleArray.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/clip.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scroll.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/jumpToSlice.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/index.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportModality.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/invertRgbTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isEqual.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/makeVolumeMetadata.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/planar.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/pointInShapeCallback.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/snapFocalPointToSlice.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/sortImageIdsAndGetSpacing.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transferFunctionUtils.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformCanvasToIJK.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformIndexToWorld.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformWorldToIndex.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/updateVTKImageDataWithCornerstoneImage.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/windowLevel.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPath.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRectByCoordinates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/StrategyCallbacks.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/WorkerTypes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/annotationInterpolationEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraResetEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createPresentationViewSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createImageSliceSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createSlabThicknessSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PanTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelRegionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ZoomTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AdvancedMagnifyTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OverlayGridTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SegmentationIntersectionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/HeightTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ETDRSGridTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundDirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/KeyImageTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AnnotationEraserTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleROIStartEndThresholdTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OrientationMarkerTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentSelectTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/VideoRedactionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationRenderingEngine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getState.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/getAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddSegmentationRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationDataModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Contour/computeAndAddContourRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Labelmap/computeAndAddLabelmapRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/computeAndAddSurfaceRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/updateSurfaceData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/createAndCacheSurfacesFromRaw.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/convertContourToSurface.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/convertLabelmapToSurface.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/Surface/surfaceComputationStrategies.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/canComputeRequestedRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/polySeg/computeAndAddRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getAllToolGroups.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/addTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/BaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/surfaceDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIStartEndThresholdTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIThresholdTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportsForAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/findClosestPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getUniqueSegmentIndices.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/invalidateBrushCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/Core/CellArray.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js","webpack:///../../../node_modules/lodash.get/index.js","webpack:///../../../node_modules/comlink/dist/esm/comlink.mjs","webpack:///../../../node_modules/d3-array/src/transpose.js","webpack:///../../../node_modules/d3-array/src/zip.js","webpack:///../../../node_modules/d3-array/src/min.js","webpack:///../../../node_modules/d3-interpolate/src/quantize.js"],"sourcesContent":["import now from './rendering/now';\nimport { renderColorImage } from './rendering/renderColorImage';\nimport { renderGrayscaleImage } from './rendering/renderGrayscaleImage';\nimport { renderPseudoColorImage } from './rendering/renderPseudoColorImage';\nexport default function (enabledElement, invalidated) {\n    const image = enabledElement.image;\n    if (!enabledElement.canvas || !enabledElement.image) {\n        return;\n    }\n    const start = now();\n    image.stats = {\n        lastGetPixelDataTime: -1.0,\n        lastStoredPixelDataToCanvasImageDataTime: -1.0,\n        lastPutImageDataTime: -1.0,\n        lastRenderTime: -1.0,\n        lastLutGenerateTime: -1.0,\n    };\n    if (image) {\n        let render = image.render;\n        if (!render) {\n            if (enabledElement.viewport.colormap) {\n                render = renderPseudoColorImage;\n            }\n            else if (image.color) {\n                render = renderColorImage;\n            }\n            else {\n                render = renderGrayscaleImage;\n            }\n        }\n        render(enabledElement, invalidated);\n    }\n    const renderTimeInMs = now() - start;\n    image.stats.lastRenderTime = renderTimeInMs;\n    enabledElement.invalid = false;\n    enabledElement.needsRedraw = false;\n}\n","import { Transform } from './transform';\nexport default function (enabledElement, scale) {\n    const transform = new Transform();\n    if (!enabledElement.viewport.displayedArea) {\n        return transform;\n    }\n    transform.translate(enabledElement.canvas.width / 2, enabledElement.canvas.height / 2);\n    const angle = enabledElement.viewport.rotation;\n    if (angle !== 0) {\n        transform.rotate((angle * Math.PI) / 180);\n    }\n    let widthScale = enabledElement.viewport.scale;\n    let heightScale = enabledElement.viewport.scale;\n    const width = enabledElement.viewport.displayedArea.brhc.x -\n        (enabledElement.viewport.displayedArea.tlhc.x - 1);\n    const height = enabledElement.viewport.displayedArea.brhc.y -\n        (enabledElement.viewport.displayedArea.tlhc.y - 1);\n    if (enabledElement.viewport.displayedArea.presentationSizeMode === 'NONE') {\n        if (enabledElement.image.rowPixelSpacing <\n            enabledElement.image.columnPixelSpacing) {\n            widthScale *=\n                enabledElement.image.columnPixelSpacing /\n                    enabledElement.image.rowPixelSpacing;\n        }\n        else if (enabledElement.image.columnPixelSpacing <\n            enabledElement.image.rowPixelSpacing) {\n            heightScale *=\n                enabledElement.image.rowPixelSpacing /\n                    enabledElement.image.columnPixelSpacing;\n        }\n    }\n    else {\n        widthScale = enabledElement.viewport.displayedArea.columnPixelSpacing;\n        heightScale = enabledElement.viewport.displayedArea.rowPixelSpacing;\n        if (enabledElement.viewport.displayedArea.presentationSizeMode ===\n            'SCALE TO FIT') {\n            const verticalScale = enabledElement.canvas.height / (height * heightScale);\n            const horizontalScale = enabledElement.canvas.width / (width * widthScale);\n            widthScale = heightScale = Math.min(horizontalScale, verticalScale);\n            if (enabledElement.viewport.displayedArea.rowPixelSpacing <\n                enabledElement.viewport.displayedArea.columnPixelSpacing) {\n                widthScale *=\n                    enabledElement.viewport.displayedArea.columnPixelSpacing /\n                        enabledElement.viewport.displayedArea.rowPixelSpacing;\n            }\n            else if (enabledElement.viewport.displayedArea.columnPixelSpacing <\n                enabledElement.viewport.displayedArea.rowPixelSpacing) {\n                heightScale *=\n                    enabledElement.viewport.displayedArea.rowPixelSpacing /\n                        enabledElement.viewport.displayedArea.columnPixelSpacing;\n            }\n        }\n    }\n    transform.scale(widthScale, heightScale);\n    if (angle !== 0) {\n        transform.rotate((-angle * Math.PI) / 180);\n    }\n    transform.translate(enabledElement.viewport.translation.x, enabledElement.viewport.translation.y);\n    if (angle !== 0) {\n        transform.rotate((angle * Math.PI) / 180);\n    }\n    if (scale !== undefined) {\n        transform.scale(scale, scale);\n    }\n    if (enabledElement.viewport.hflip) {\n        transform.scale(-1, 1);\n    }\n    if (enabledElement.viewport.vflip) {\n        transform.scale(1, -1);\n    }\n    transform.translate(-width / 2, -height / 2);\n    return transform;\n}\n","import createViewport from './createViewport';\nimport getImageFitScale from './getImageFitScale';\nexport default function (canvas, image, modality, colormap) {\n    if (canvas === undefined) {\n        throw new Error('getDefaultViewport: parameter canvas must not be undefined');\n    }\n    if (image === undefined) {\n        return createViewport();\n    }\n    const scale = getImageFitScale(canvas, image, 0).scaleFactor;\n    let voi;\n    if (modality === 'PT' && image.isPreScaled) {\n        voi = {\n            windowWidth: 5,\n            windowCenter: 2.5,\n        };\n    }\n    else if (image.windowWidth !== undefined &&\n        image.windowCenter !== undefined) {\n        voi = {\n            windowWidth: Array.isArray(image.windowWidth)\n                ? image.windowWidth[0]\n                : image.windowWidth,\n            windowCenter: Array.isArray(image.windowCenter)\n                ? image.windowCenter[0]\n                : image.windowCenter,\n        };\n    }\n    return {\n        scale,\n        translation: {\n            x: 0,\n            y: 0,\n        },\n        voi,\n        invert: image.invert,\n        pixelReplication: false,\n        rotation: 0,\n        hflip: false,\n        vflip: false,\n        modalityLUT: image.modalityLUT,\n        modality,\n        voiLUT: image.voiLUT,\n        colormap: colormap !== undefined ? colormap : image.colormap,\n        displayedArea: {\n            tlhc: {\n                x: 1,\n                y: 1,\n            },\n            brhc: {\n                x: image.columns,\n                y: image.rows,\n            },\n            rowPixelSpacing: image.rowPixelSpacing === undefined ? 1 : image.rowPixelSpacing,\n            columnPixelSpacing: image.columnPixelSpacing === undefined ? 1 : image.columnPixelSpacing,\n            presentationSizeMode: 'NONE',\n        },\n    };\n}\n","import BaseVolumeViewport from '../BaseVolumeViewport';\nasync function addVolumesToViewports(renderingEngine, volumeInputs, viewportIds, immediateRender = false, suppressEvents = false) {\n    for (const viewportId of viewportIds) {\n        const viewport = renderingEngine.getViewport(viewportId);\n        if (!viewport) {\n            throw new Error(`Viewport with Id ${viewportId} does not exist`);\n        }\n        if (!(viewport instanceof BaseVolumeViewport)) {\n            console.warn(`Viewport with Id ${viewportId} is not a BaseVolumeViewport. Cannot add volume to this viewport.`);\n            return;\n        }\n    }\n    const addVolumePromises = viewportIds.map(async (viewportId) => {\n        const viewport = renderingEngine.getViewport(viewportId);\n        await viewport.addVolumes(volumeInputs, immediateRender, suppressEvents);\n    });\n    await Promise.all(addVolumePromises);\n    return;\n}\nexport default addVolumesToViewports;\n","async function addImageSlicesToViewports(renderingEngine, stackInputs, viewportIds) {\n    for (const viewportId of viewportIds) {\n        const viewport = renderingEngine.getStackViewport(viewportId);\n        if (!viewport) {\n            throw new Error(`Viewport with Id ${viewportId} does not exist`);\n        }\n        if (!viewport.addImages) {\n            console.warn(`Viewport with Id ${viewportId} does not have addImages. Cannot add image segmentation to this viewport.`);\n            return;\n        }\n    }\n    const addStackPromises = viewportIds.map(async (viewportId) => {\n        const viewport = renderingEngine.getStackViewport(viewportId);\n        viewport.addImages(stackInputs);\n    });\n    await Promise.all(addStackPromises);\n}\nexport default addImageSlicesToViewports;\n","const DEFAULT_SETTINGS = Symbol('DefaultSettings');\nconst RUNTIME_SETTINGS = Symbol('RuntimeSettings');\nconst OBJECT_SETTINGS_MAP = Symbol('ObjectSettingsMap');\nconst DICTIONARY = Symbol('Dictionary');\nexport default class Settings {\n    constructor(base) {\n        const dictionary = Object.create((base instanceof Settings && DICTIONARY in base\n            ? base[DICTIONARY]\n            : null));\n        Object.seal(Object.defineProperty(this, DICTIONARY, {\n            value: dictionary,\n        }));\n    }\n    set(key, value) {\n        return set(this[DICTIONARY], key, value, null);\n    }\n    get(key) {\n        return get(this[DICTIONARY], key);\n    }\n    unset(key) {\n        return unset(this[DICTIONARY], key + '');\n    }\n    forEach(callback) {\n        iterate(this[DICTIONARY], callback);\n    }\n    extend() {\n        return new Settings(this);\n    }\n    import(root) {\n        if (isPlainObject(root)) {\n            Object.keys(root).forEach((key) => {\n                set(this[DICTIONARY], key, root[key], null);\n            });\n        }\n    }\n    dump() {\n        const context = {};\n        iterate(this[DICTIONARY], (key, value) => {\n            if (typeof value !== 'undefined') {\n                deepSet(context, key, value);\n            }\n        });\n        return context;\n    }\n    static assert(subject) {\n        return subject instanceof Settings\n            ? subject\n            : Settings.getRuntimeSettings();\n    }\n    static getDefaultSettings(subfield = null) {\n        let defaultSettings = Settings[DEFAULT_SETTINGS];\n        if (!(defaultSettings instanceof Settings)) {\n            defaultSettings = new Settings();\n            Settings[DEFAULT_SETTINGS] = defaultSettings;\n        }\n        if (subfield) {\n            const settingObj = {};\n            defaultSettings.forEach((name) => {\n                if (name.startsWith(subfield)) {\n                    const setting = name.split(`${subfield}.`)[1];\n                    settingObj[setting] = defaultSettings.get(name);\n                }\n            });\n            return settingObj;\n        }\n        return defaultSettings;\n    }\n    static getRuntimeSettings() {\n        let runtimeSettings = Settings[RUNTIME_SETTINGS];\n        if (!(runtimeSettings instanceof Settings)) {\n            runtimeSettings = new Settings(Settings.getDefaultSettings());\n            Settings[RUNTIME_SETTINGS] = runtimeSettings;\n        }\n        return runtimeSettings;\n    }\n    static getObjectSettings(subject, from) {\n        let settings = null;\n        if (subject instanceof Settings) {\n            settings = subject;\n        }\n        else if (typeof subject === 'object' && subject !== null) {\n            let objectSettingsMap = Settings[OBJECT_SETTINGS_MAP];\n            if (!(objectSettingsMap instanceof WeakMap)) {\n                objectSettingsMap = new WeakMap();\n                Settings[OBJECT_SETTINGS_MAP] = objectSettingsMap;\n            }\n            settings = objectSettingsMap.get(subject);\n            if (!(settings instanceof Settings)) {\n                settings = new Settings(Settings.assert(Settings.getObjectSettings(from)));\n                objectSettingsMap.set(subject, settings);\n            }\n        }\n        return settings;\n    }\n    static extendRuntimeSettings() {\n        return Settings.getRuntimeSettings().extend();\n    }\n}\nfunction unset(dictionary, name) {\n    if (name.endsWith('.')) {\n        let deleteCount = 0;\n        const namespace = name;\n        const base = namespace.slice(0, -1);\n        const deleteAll = base.length === 0;\n        for (const key in dictionary) {\n            if (Object.prototype.hasOwnProperty.call(dictionary, key) &&\n                (deleteAll || key.startsWith(namespace) || key === base)) {\n                delete dictionary[key];\n                ++deleteCount;\n            }\n        }\n        return deleteCount > 0;\n    }\n    return delete dictionary[name];\n}\nfunction iterate(dictionary, callback) {\n    for (const key in dictionary) {\n        callback(key, dictionary[key]);\n    }\n}\nfunction setAll(dictionary, prefix, record, references) {\n    let failCount;\n    if (references.has(record)) {\n        return set(dictionary, prefix, null, references);\n    }\n    references.add(record);\n    failCount = 0;\n    for (const field in record) {\n        if (Object.prototype.hasOwnProperty.call(record, field)) {\n            const key = field.length === 0 ? prefix : `${prefix}.${field}`;\n            if (!set(dictionary, key, record[field], references)) {\n                ++failCount;\n            }\n        }\n    }\n    references.delete(record);\n    return failCount === 0;\n}\nfunction set(dictionary, key, value, references) {\n    if (isValidKey(key)) {\n        if (isPlainObject(value)) {\n            return setAll(dictionary, key, value, references instanceof WeakSet ? references : new WeakSet());\n        }\n        dictionary[key] = value;\n        return true;\n    }\n    return false;\n}\nfunction get(dictionary, key) {\n    return dictionary[key];\n}\nfunction isValidKey(key) {\n    let last, current, previous;\n    if (typeof key !== 'string' || (last = key.length - 1) < 0) {\n        return false;\n    }\n    previous = -1;\n    while ((current = key.indexOf('.', previous + 1)) >= 0) {\n        if (current - previous < 2 || current === last) {\n            return false;\n        }\n        previous = current;\n    }\n    return true;\n}\nfunction isPlainObject(subject) {\n    if (typeof subject === 'object' && subject !== null) {\n        const prototype = Object.getPrototypeOf(subject);\n        if (prototype === Object.prototype || prototype === null) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction deepSet(context, key, value) {\n    const separator = key.indexOf('.');\n    if (separator >= 0) {\n        const subKey = key.slice(0, separator);\n        let subContext = context[subKey];\n        if (typeof subContext !== 'object' || subContext === null) {\n            const subContextValue = subContext;\n            subContext = {};\n            if (typeof subContextValue !== 'undefined') {\n                subContext[''] = subContextValue;\n            }\n            context[subKey] = subContext;\n        }\n        deepSet(subContext, key.slice(separator + 1, key.length), value);\n    }\n    else {\n        context[key] = value;\n    }\n}\nSettings.getDefaultSettings().set('useCursors', true);\n","export class Contour {\n    constructor(props) {\n        const { points, type } = props.data;\n        this.id = props.id;\n        this._points = points;\n        this._type = type;\n        this._color = props.color;\n        this._segmentIndex = props.segmentIndex;\n        this.sizeInBytes = this._getSizeInBytes();\n    }\n    _getSizeInBytes() {\n        return this._points.length * 3;\n    }\n    get points() {\n        return this._points;\n    }\n    set points(value) {\n        this._points = value;\n    }\n    get color() {\n        return this._color;\n    }\n    set color(value) {\n        this._color = value;\n    }\n    get type() {\n        return this._type;\n    }\n    set type(value) {\n        this._type = value;\n    }\n    get segmentIndex() {\n        return this._segmentIndex;\n    }\n    set segmentIndex(value) {\n        this._segmentIndex = value;\n    }\n    get flatPointsArray() {\n        return this._points.map((point) => [...point]).flat();\n    }\n}\nexport default Contour;\n","import Contour from './Contour';\nexport class ContourSet {\n    constructor(props) {\n        this._color = [200, 0, 0];\n        this.id = props.id;\n        this._contours = [];\n        this._color = props.color ?? this._color;\n        this.frameOfReferenceUID = props.frameOfReferenceUID;\n        this._segmentIndex = props.segmentIndex;\n        this._createEachContour(props.data);\n        this.sizeInBytes = this._getSizeInBytes();\n    }\n    _createEachContour(contourDataArray) {\n        contourDataArray.forEach((contourData) => {\n            const { points, type, color } = contourData;\n            const contour = new Contour({\n                id: `${this.id}-segment-${this._segmentIndex}`,\n                data: {\n                    points,\n                    type,\n                    segmentIndex: this._segmentIndex,\n                    color: color ?? this._color,\n                },\n                segmentIndex: this._segmentIndex,\n                color: color ?? this._color,\n            });\n            this._contours.push(contour);\n        });\n        this._updateContourSetCentroid();\n    }\n    _updateContourSetCentroid() {\n        const numberOfPoints = this.totalNumberOfPoints;\n        const flatPointsArray = this.flatPointsArray;\n        const sumOfPoints = flatPointsArray.reduce((acc, point) => {\n            return [acc[0] + point[0], acc[1] + point[1], acc[2] + point[2]];\n        }, [0, 0, 0]);\n        const centroid = [\n            sumOfPoints[0] / numberOfPoints,\n            sumOfPoints[1] / numberOfPoints,\n            sumOfPoints[2] / numberOfPoints,\n        ];\n        const closestPoint = flatPointsArray.reduce((closestPoint, point) => {\n            const distanceToPoint = this._getDistance(centroid, point);\n            const distanceToClosestPoint = this._getDistance(centroid, closestPoint);\n            if (distanceToPoint < distanceToClosestPoint) {\n                return point;\n            }\n            else {\n                return closestPoint;\n            }\n        }, flatPointsArray[0]);\n        this._centroid = closestPoint;\n    }\n    _getSizeInBytes() {\n        return this._contours.reduce((sizeInBytes, contour) => {\n            return sizeInBytes + contour.sizeInBytes;\n        }, 0);\n    }\n    _getDistance(pointA, pointB) {\n        return Math.sqrt((pointA[0] - pointB[0]) ** 2 +\n            (pointA[1] - pointB[1]) ** 2 +\n            (pointA[2] - pointB[2]) ** 2);\n    }\n    get centroid() {\n        return this._centroid;\n    }\n    get segmentIndex() {\n        return this._segmentIndex;\n    }\n    get color() {\n        return this._color;\n    }\n    set color(value) {\n        this._color = value;\n        this._contours.forEach((contour) => {\n            if (contour instanceof Contour) {\n                contour.color = value;\n            }\n        });\n    }\n    get contours() {\n        return this._contours;\n    }\n    get flatPointsArray() {\n        return this._contours.flatMap((contour) => contour.points);\n    }\n    get numberOfContours() {\n        return this._contours.length;\n    }\n    get totalNumberOfPoints() {\n        return this._contours.reduce((numberOfPoints, contour) => {\n            return numberOfPoints + contour.points.length;\n        }, 0);\n    }\n    get numberOfPointsArray() {\n        return this._contours.map((contour) => contour.points.length);\n    }\n    getPointsInContour(contourIndex) {\n        return this._contours[contourIndex].points;\n    }\n    getNumberOfPointsInAContour(contourIndex) {\n        return this.getPointsInContour(contourIndex).length;\n    }\n}\nexport default ContourSet;\n","export class Surface {\n    constructor(props) {\n        this._color = [200, 0, 0];\n        this.id = props.id;\n        this._points = props.points;\n        this._polys = props.polys;\n        this._color = props.color ?? this._color;\n        this.frameOfReferenceUID = props.frameOfReferenceUID;\n        this._segmentIndex = props.segmentIndex;\n        this.sizeInBytes = this._getSizeInBytes();\n        this._updateCentroid();\n    }\n    _getSizeInBytes() {\n        return this._points.length * 4 + this._polys.length * 4;\n    }\n    _updateCentroid() {\n        const numberOfPoints = this._points.length / 3;\n        let sumX = 0, sumY = 0, sumZ = 0;\n        for (let i = 0; i < this._points.length; i += 3) {\n            sumX += this._points[i];\n            sumY += this._points[i + 1];\n            sumZ += this._points[i + 2];\n        }\n        this._centroid = [\n            sumX / numberOfPoints,\n            sumY / numberOfPoints,\n            sumZ / numberOfPoints,\n        ];\n    }\n    get color() {\n        return this._color;\n    }\n    set color(color) {\n        this._color = color;\n    }\n    get points() {\n        return this._points;\n    }\n    set points(points) {\n        this._points = points;\n        this._updateCentroid();\n    }\n    get polys() {\n        return this._polys;\n    }\n    set polys(polys) {\n        this._polys = polys;\n    }\n    get segmentIndex() {\n        return this._segmentIndex;\n    }\n    get centroid() {\n        return this._centroid;\n    }\n    get flatPointsArray() {\n        return this._points;\n    }\n    get totalNumberOfPoints() {\n        return this._points.length / 3;\n    }\n}\n","import vtkConstants from '@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants';\nconst { BlendMode } = vtkConstants;\nvar BlendModes;\n(function (BlendModes) {\n    BlendModes[BlendModes[\"COMPOSITE\"] = BlendMode.COMPOSITE_BLEND] = \"COMPOSITE\";\n    BlendModes[BlendModes[\"MAXIMUM_INTENSITY_BLEND\"] = BlendMode.MAXIMUM_INTENSITY_BLEND] = \"MAXIMUM_INTENSITY_BLEND\";\n    BlendModes[BlendModes[\"MINIMUM_INTENSITY_BLEND\"] = BlendMode.MINIMUM_INTENSITY_BLEND] = \"MINIMUM_INTENSITY_BLEND\";\n    BlendModes[BlendModes[\"AVERAGE_INTENSITY_BLEND\"] = BlendMode.AVERAGE_INTENSITY_BLEND] = \"AVERAGE_INTENSITY_BLEND\";\n})(BlendModes || (BlendModes = {}));\nexport default BlendModes;\n","var GeometryType;\n(function (GeometryType) {\n    GeometryType[\"CONTOUR\"] = \"CONTOUR\";\n    GeometryType[\"SURFACE\"] = \"SURFACE\";\n})(GeometryType || (GeometryType = {}));\nexport default GeometryType;\n","export var CalibrationTypes;\n(function (CalibrationTypes) {\n    CalibrationTypes[\"NOT_APPLICABLE\"] = \"\";\n    CalibrationTypes[\"ERMF\"] = \"ERMF\";\n    CalibrationTypes[\"USER\"] = \"User\";\n    CalibrationTypes[\"PROJECTION\"] = \"Proj\";\n    CalibrationTypes[\"REGION\"] = \"Region\";\n    CalibrationTypes[\"ERROR\"] = \"Error\";\n    CalibrationTypes[\"UNCALIBRATED\"] = \"Uncalibrated\";\n})(CalibrationTypes || (CalibrationTypes = {}));\nexport default CalibrationTypes;\n","export var GenerateImageType;\n(function (GenerateImageType) {\n    GenerateImageType[\"SUM\"] = \"SUM\";\n    GenerateImageType[\"SUBTRACT\"] = \"SUBTRACT\";\n    GenerateImageType[\"AVERAGE\"] = \"AVERAGE\";\n})(GenerateImageType || (GenerateImageType = {}));\n","import getRenderingEngine, { getRenderingEngines, } from './RenderingEngine/getRenderingEngine';\nexport default function getEnabledElement(element) {\n    if (!element) {\n        return;\n    }\n    const { viewportUid, renderingEngineUid } = element.dataset;\n    return getEnabledElementByIds(viewportUid, renderingEngineUid);\n}\nexport function getEnabledElementByIds(viewportId, renderingEngineId) {\n    if (!renderingEngineId || !viewportId) {\n        return;\n    }\n    const renderingEngine = getRenderingEngine(renderingEngineId);\n    if (!renderingEngine || renderingEngine.hasBeenDestroyed) {\n        return;\n    }\n    const viewport = renderingEngine.getViewport(viewportId);\n    if (!viewport) {\n        return;\n    }\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n    return {\n        viewport,\n        renderingEngine,\n        viewportId,\n        renderingEngineId,\n        FrameOfReferenceUID,\n    };\n}\nexport function getEnabledElementByViewportId(viewportId) {\n    const renderingEngines = getRenderingEngines();\n    for (let i = 0; i < renderingEngines.length; i++) {\n        const renderingEngine = renderingEngines[i];\n        const viewport = renderingEngine.getViewport(viewportId);\n        if (viewport) {\n            return getEnabledElementByIds(viewportId, renderingEngine.id);\n        }\n    }\n}\nexport function getEnabledElements() {\n    const enabledElements = [];\n    const renderingEngines = getRenderingEngines();\n    renderingEngines.forEach((renderingEngine) => {\n        const viewports = renderingEngine.getViewports();\n        viewports.forEach(({ element }) => {\n            enabledElements.push(getEnabledElement(element));\n        });\n    });\n    return enabledElements;\n}\n","import * as Comlink from 'comlink';\nimport { RequestType } from '../enums/';\nimport { RequestPoolManager } from '../requestPool/requestPoolManager';\nclass CentralizedWorkerManager {\n    constructor() {\n        this.workerRegistry = {};\n        this.workerPoolManager = new RequestPoolManager('webworker');\n    }\n    registerWorker(workerName, workerFn, options = {}) {\n        const { maxWorkerInstances = 1, overwrite = false, autoTerminateOnIdle = {\n            enabled: false,\n            idleTimeThreshold: 3000,\n        }, } = options;\n        if (this.workerRegistry[workerName] && !overwrite) {\n            console.warn(`Worker type '${workerName}' is already registered...`);\n            return;\n        }\n        if (overwrite && this.workerRegistry[workerName]?.idleCheckIntervalId) {\n            clearInterval(this.workerRegistry[workerName].idleCheckIntervalId);\n        }\n        const workerProperties = {\n            workerFn: null,\n            instances: [],\n            loadCounters: [],\n            lastActiveTime: [],\n            nativeWorkers: [],\n            autoTerminateOnIdle: autoTerminateOnIdle.enabled,\n            idleCheckIntervalId: null,\n            idleTimeThreshold: autoTerminateOnIdle.idleTimeThreshold,\n        };\n        workerProperties.loadCounters = Array(maxWorkerInstances).fill(0);\n        workerProperties.lastActiveTime = Array(maxWorkerInstances).fill(null);\n        for (let i = 0; i < maxWorkerInstances; i++) {\n            const worker = workerFn();\n            workerProperties.instances.push(Comlink.wrap(worker));\n            workerProperties.nativeWorkers.push(worker);\n            workerProperties.workerFn = workerFn;\n        }\n        this.workerRegistry[workerName] = workerProperties;\n    }\n    getNextWorkerAPI(workerName) {\n        const workerProperties = this.workerRegistry[workerName];\n        if (!workerProperties) {\n            console.error(`Worker type '${workerName}' is not registered.`);\n            return null;\n        }\n        const workerInstances = workerProperties.instances.filter((instance) => instance !== null);\n        let minLoadIndex = 0;\n        let minLoadValue = workerProperties.loadCounters[0] || 0;\n        for (let i = 1; i < workerInstances.length; i++) {\n            const currentLoadValue = workerProperties.loadCounters[i] || 0;\n            if (currentLoadValue < minLoadValue) {\n                minLoadIndex = i;\n                minLoadValue = currentLoadValue;\n            }\n        }\n        if (workerProperties.instances[minLoadIndex] === null) {\n            const worker = workerProperties.workerFn();\n            workerProperties.instances[minLoadIndex] = Comlink.wrap(worker);\n            workerProperties.nativeWorkers[minLoadIndex] = worker;\n        }\n        workerProperties.loadCounters[minLoadIndex] += 1;\n        return {\n            api: workerProperties.instances[minLoadIndex],\n            index: minLoadIndex,\n        };\n    }\n    executeTask(workerName, methodName, args = {}, { requestType = RequestType.Compute, priority = 0, options = {}, callbacks = [], } = {}) {\n        return new Promise((resolve, reject) => {\n            const requestFn = async () => {\n                const { api, index } = this.getNextWorkerAPI(workerName);\n                if (!api) {\n                    const error = new Error(`No available worker instance for '${workerName}'`);\n                    console.error(error);\n                    reject(error);\n                    return;\n                }\n                try {\n                    let finalCallbacks = [];\n                    if (callbacks.length) {\n                        finalCallbacks = callbacks.map((cb) => {\n                            return Comlink.proxy(cb);\n                        });\n                    }\n                    const workerProperties = this.workerRegistry[workerName];\n                    workerProperties.processing = true;\n                    const results = await api[methodName](args, ...finalCallbacks);\n                    workerProperties.processing = false;\n                    workerProperties.lastActiveTime[index] = Date.now();\n                    if (workerProperties.autoTerminateOnIdle &&\n                        !workerProperties.idleCheckIntervalId &&\n                        workerProperties.idleTimeThreshold) {\n                        workerProperties.idleCheckIntervalId = setInterval(() => {\n                            this.terminateIdleWorkers(workerName, workerProperties.idleTimeThreshold);\n                        }, workerProperties.idleTimeThreshold);\n                    }\n                    resolve(results);\n                }\n                catch (err) {\n                    console.error(`Error executing method '${methodName}' on worker '${workerName}':`, err);\n                    reject(err);\n                }\n                finally {\n                    this.workerRegistry[workerName].loadCounters[index]--;\n                }\n            };\n            this.workerPoolManager.addRequest(requestFn, requestType, options, priority);\n        });\n    }\n    terminateIdleWorkers(workerName, idleTimeThreshold) {\n        const workerProperties = this.workerRegistry[workerName];\n        if (workerProperties.processing) {\n            return;\n        }\n        const now = Date.now();\n        workerProperties.instances.forEach((_, index) => {\n            const lastActiveTime = workerProperties.lastActiveTime[index];\n            const isWorkerActive = lastActiveTime !== null && workerProperties.loadCounters[index] > 0;\n            const idleTime = now - lastActiveTime;\n            if (!isWorkerActive && idleTime > idleTimeThreshold) {\n                this.terminateWorkerInstance(workerName, index);\n            }\n        });\n    }\n    terminate(workerName) {\n        const workerProperties = this.workerRegistry[workerName];\n        if (!workerProperties) {\n            console.error(`Worker type '${workerName}' is not registered.`);\n            return;\n        }\n        workerProperties.instances.forEach((_, index) => {\n            this.terminateWorkerInstance(workerName, index);\n        });\n    }\n    terminateWorkerInstance(workerName, index) {\n        const workerProperties = this.workerRegistry[workerName];\n        const workerInstance = workerProperties.instances[index];\n        if (workerInstance !== null) {\n            workerInstance[Comlink.releaseProxy]();\n            workerProperties.nativeWorkers[index].terminate();\n            workerProperties.instances[index] = null;\n            workerProperties.lastActiveTime[index] = null;\n        }\n    }\n}\nexport default CentralizedWorkerManager;\n","import { getRenderingEngines } from './RenderingEngine/getRenderingEngine';\nlet csRenderInitialized = false;\nimport deepMerge from './utilities/deepMerge';\nimport CentralizedWebWorkerManager from './webWorkerManager/webWorkerManager';\nconst defaultConfig = {\n    gpuTier: { tier: 2 },\n    isMobile: false,\n    rendering: {\n        useCPURendering: false,\n        preferSizeOverAccuracy: false,\n        strictZSpacingForVolumeViewport: true,\n    },\n    peerImport: (moduleId) => null,\n};\nlet config = {\n    ...defaultConfig,\n    rendering: { ...defaultConfig.rendering },\n};\nlet webWorkerManager = null;\nfunction _getGLContext() {\n    const canvas = document.createElement('canvas');\n    const gl = canvas.getContext('webgl2') ||\n        canvas.getContext('webgl') ||\n        canvas.getContext('experimental-webgl');\n    return gl;\n}\nfunction _hasActiveWebGLContext() {\n    const gl = _getGLContext();\n    return (gl instanceof WebGLRenderingContext || gl instanceof WebGL2RenderingContext);\n}\nfunction _hasNorm16TextureSupport() {\n    const gl = _getGLContext();\n    if (gl) {\n        const ext = gl.getExtension('EXT_texture_norm16');\n        if (ext) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isIOS() {\n    if (/iPad|iPhone|iPod/.test(navigator.platform)) {\n        return true;\n    }\n    else {\n        return (navigator.maxTouchPoints &&\n            navigator.maxTouchPoints > 2 &&\n            navigator.platform.includes('MacIntel'));\n    }\n}\nfunction init(configuration = config) {\n    if (csRenderInitialized) {\n        return csRenderInitialized;\n    }\n    config = deepMerge(defaultConfig, configuration);\n    if (isIOS()) {\n        if (configuration.rendering?.preferSizeOverAccuracy) {\n            config.rendering.preferSizeOverAccuracy = true;\n        }\n        else {\n            console.log('norm16 texture not supported, you can turn on the preferSizeOverAccuracy flag to use native data type, but be aware of the inaccuracy of the rendering in high bits');\n        }\n    }\n    const hasWebGLContext = _hasActiveWebGLContext();\n    if (!hasWebGLContext) {\n        console.log('CornerstoneRender: GPU not detected, using CPU rendering');\n        config.rendering.useCPURendering = true;\n    }\n    else {\n        console.log('CornerstoneRender: using GPU rendering');\n    }\n    csRenderInitialized = true;\n    if (!webWorkerManager) {\n        webWorkerManager = new CentralizedWebWorkerManager();\n    }\n    return csRenderInitialized;\n}\nfunction setUseCPURendering(status, updateViewports = true) {\n    config.rendering.useCPURendering = status;\n    csRenderInitialized = true;\n    if (updateViewports) {\n        _updateRenderingPipelinesForAllViewports();\n    }\n}\nfunction setPreferSizeOverAccuracy(status) {\n    config.rendering.preferSizeOverAccuracy = status;\n    csRenderInitialized = true;\n    _updateRenderingPipelinesForAllViewports();\n}\nfunction canRenderFloatTextures() {\n    if (!isIOS()) {\n        return true;\n    }\n    return false;\n}\nfunction resetUseCPURendering() {\n    config.rendering.useCPURendering = !_hasActiveWebGLContext();\n    _updateRenderingPipelinesForAllViewports();\n}\nfunction getShouldUseCPURendering() {\n    return config.rendering.useCPURendering;\n}\nfunction isCornerstoneInitialized() {\n    return csRenderInitialized;\n}\nfunction resetInitialization() {\n    csRenderInitialized = false;\n}\nfunction getConfiguration() {\n    return config;\n}\nfunction setConfiguration(c) {\n    config = c;\n    _updateRenderingPipelinesForAllViewports();\n}\nfunction _updateRenderingPipelinesForAllViewports() {\n    getRenderingEngines().forEach((engine) => {\n        engine.getViewports().forEach((viewport) => {\n            viewport.updateRenderingPipeline();\n        });\n    });\n}\nfunction getWebWorkerManager() {\n    if (!webWorkerManager) {\n        webWorkerManager = new CentralizedWebWorkerManager();\n    }\n    return webWorkerManager;\n}\nfunction peerImport(moduleId) {\n    return config.peerImport(moduleId);\n}\nexport { init, getShouldUseCPURendering, isCornerstoneInitialized, setUseCPURendering, setPreferSizeOverAccuracy, resetUseCPURendering, getConfiguration, setConfiguration, getWebWorkerManager, canRenderFloatTextures, peerImport, resetInitialization, };\n","import '@kitware/vtk.js/Rendering/Profiles/Geometry';\nimport cache from '../cache/cache';\nimport { GeometryType } from '../enums';\nimport { createContourSet } from './utils/contourSet/createContourSet';\nimport { createSurface } from './utils/surface/createSurface';\nimport Events from '../enums/Events';\nimport eventTarget from '../eventTarget';\nimport triggerEvent from '../utilities/triggerEvent';\nconst geometryLoaders = {};\nlet unknownGeometryLoader;\nfunction loadGeometryFromGeometryLoader(geometryId, options) {\n    const colonIndex = geometryId.indexOf(':');\n    const scheme = geometryId.substring(0, colonIndex);\n    let loader = geometryLoaders[scheme];\n    if (loader === undefined || loader === null) {\n        if (unknownGeometryLoader == null ||\n            typeof unknownGeometryLoader !== 'function') {\n            throw new Error(`No geometry loader for scheme ${scheme} has been registered`);\n        }\n        loader = unknownGeometryLoader;\n    }\n    const geometryLoadObject = loader(geometryId, options);\n    geometryLoadObject.promise.then(function (geometry) {\n        triggerEvent(eventTarget, Events.GEOMETRY_LOADED, { geometry });\n    }, function (error) {\n        const errorObject = {\n            geometryId,\n            error,\n        };\n        triggerEvent(eventTarget, Events.GEOMETRY_LOADED_FAILED, errorObject);\n    });\n    return geometryLoadObject;\n}\nexport function loadGeometry(geometryId, options) {\n    if (geometryId === undefined) {\n        throw new Error('loadGeometry: parameter geometryId must not be undefined');\n    }\n    let geometryLoadObject = cache.getGeometryLoadObject(geometryId);\n    if (geometryLoadObject !== undefined) {\n        return geometryLoadObject.promise;\n    }\n    geometryLoadObject = loadGeometryFromGeometryLoader(geometryId, options);\n    return geometryLoadObject.promise;\n}\nexport async function loadAndCacheGeometry(geometryId, options) {\n    if (geometryId === undefined) {\n        throw new Error('createAndCacheGeometry: parameter geometryId must not be undefined');\n    }\n    let geometryLoadObject = cache.getGeometryLoadObject(geometryId);\n    if (geometryLoadObject !== undefined) {\n        return geometryLoadObject.promise;\n    }\n    geometryLoadObject = loadGeometryFromGeometryLoader(geometryId, options);\n    await cache.putGeometryLoadObject(geometryId, geometryLoadObject);\n    return geometryLoadObject.promise;\n}\nexport function createAndCacheGeometry(geometryId, options) {\n    if (geometryId === undefined) {\n        throw new Error('createAndCacheGeometry: parameter geometryId must not be undefined');\n    }\n    let geometry = cache.getGeometry(geometryId);\n    if (geometry) {\n        return geometry;\n    }\n    if (options.type === GeometryType.CONTOUR) {\n        geometry = createContourSet(geometryId, options.geometryData);\n    }\n    else if (options.type === GeometryType.SURFACE) {\n        geometry = createSurface(geometryId, options.geometryData);\n    }\n    else {\n        throw new Error('Unknown geometry type');\n    }\n    cache.putGeometrySync(geometryId, geometry);\n    return geometry;\n}\nexport function registerGeometryLoader(scheme, geometryLoader) {\n    geometryLoaders[scheme] = geometryLoader;\n}\nexport function registerUnknownGeometryLoader(geometryLoader) {\n    const oldGeometryLoader = unknownGeometryLoader;\n    unknownGeometryLoader = geometryLoader;\n    return oldGeometryLoader;\n}\n","import cache from '../cache/cache';\nimport Events from '../enums/Events';\nimport eventTarget from '../eventTarget';\nimport genericMetadataProvider from '../utilities/genericMetadataProvider';\nimport { getBufferConfiguration } from '../utilities/getBufferConfiguration';\nimport triggerEvent from '../utilities/triggerEvent';\nimport uuidv4 from '../utilities/uuidv4';\nimport VoxelManager from '../utilities/VoxelManager';\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\nimport * as metaData from '../metaData';\nconst imageLoaders = {};\nlet unknownImageLoader;\nfunction loadImageFromImageLoader(imageId, options) {\n    const cachedImageLoadObject = cache.getImageLoadObject(imageId);\n    if (cachedImageLoadObject) {\n        handleImageLoadPromise(cachedImageLoadObject.promise, imageId);\n        return cachedImageLoadObject;\n    }\n    const scheme = imageId.split(':')[0];\n    const loader = imageLoaders[scheme] || unknownImageLoader;\n    if (!loader) {\n        throw new Error(`loadImageFromImageLoader: No image loader found for scheme '${scheme}'`);\n    }\n    const imageLoadObject = loader(imageId, options);\n    handleImageLoadPromise(imageLoadObject.promise, imageId);\n    return imageLoadObject;\n}\nfunction handleImageLoadPromise(imagePromise, imageId) {\n    Promise.resolve(imagePromise)\n        .then((image) => {\n        ensureVoxelManager(image);\n        triggerEvent(eventTarget, Events.IMAGE_LOADED, { image });\n    })\n        .catch((error) => {\n        const errorDetails = {\n            imageId,\n            error,\n        };\n        triggerEvent(eventTarget, Events.IMAGE_LOAD_FAILED, errorDetails);\n    });\n}\nfunction ensureVoxelManager(image) {\n    if (!image.voxelManager) {\n        const { width, height, numberOfComponents } = image;\n        const voxelManager = VoxelManager.createImageVoxelManager({\n            scalarData: image.getPixelData(),\n            width,\n            height,\n            numberOfComponents,\n        });\n        image.voxelManager = voxelManager;\n        image.getPixelData = () => voxelManager.getScalarData();\n        delete image.imageFrame.pixelData;\n    }\n}\nexport function loadImage(imageId, options = { priority: 0, requestType: 'prefetch' }) {\n    if (imageId === undefined) {\n        throw new Error('loadImage: parameter imageId must not be undefined');\n    }\n    return loadImageFromImageLoader(imageId, options).promise;\n}\nexport function loadAndCacheImage(imageId, options = { priority: 0, requestType: 'prefetch' }) {\n    if (imageId === undefined) {\n        throw new Error('loadAndCacheImage: parameter imageId must not be undefined');\n    }\n    const imageLoadObject = loadImageFromImageLoader(imageId, options);\n    if (!cache.getImageLoadObject(imageId)) {\n        cache.putImageLoadObject(imageId, imageLoadObject);\n    }\n    return imageLoadObject.promise;\n}\nexport function loadAndCacheImages(imageIds, options = { priority: 0, requestType: 'prefetch' }) {\n    if (!imageIds || imageIds.length === 0) {\n        throw new Error('loadAndCacheImages: parameter imageIds must be list of image Ids');\n    }\n    const allPromises = imageIds.map((imageId) => {\n        return loadAndCacheImage(imageId, options);\n    });\n    return allPromises;\n}\nexport function createAndCacheDerivedImage(referencedImageId, options = {}) {\n    if (referencedImageId === undefined) {\n        throw new Error('createAndCacheDerivedImage: parameter imageId must not be undefined');\n    }\n    if (options.imageId === undefined) {\n        options.imageId = `derived:${uuidv4()}`;\n    }\n    const { imageId, skipCreateBuffer, onCacheAdd } = options;\n    const imagePlaneModule = metaData.get('imagePlaneModule', referencedImageId);\n    const length = imagePlaneModule.rows * imagePlaneModule.columns;\n    const { TypedArrayConstructor } = getBufferConfiguration(options.targetBuffer?.type, length);\n    const imageScalarData = new TypedArrayConstructor(skipCreateBuffer ? 1 : length);\n    const derivedImageId = imageId;\n    const referencedImagePlaneMetadata = metaData.get('imagePlaneModule', referencedImageId);\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'imagePlaneModule',\n        metadata: referencedImagePlaneMetadata,\n    });\n    const referencedImageGeneralSeriesMetadata = metaData.get('generalSeriesModule', referencedImageId);\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'generalSeriesModule',\n        metadata: referencedImageGeneralSeriesMetadata,\n    });\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'generalImageModule',\n        metadata: {\n            instanceNumber: options.instanceNumber,\n        },\n    });\n    const imagePixelModule = metaData.get('imagePixelModule', referencedImageId);\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'imagePixelModule',\n        metadata: {\n            ...imagePixelModule,\n            bitsAllocated: 8,\n            bitsStored: 8,\n            highBit: 7,\n            samplesPerPixel: 1,\n            pixelRepresentation: 0,\n        },\n    });\n    const localImage = createAndCacheLocalImage(imageId, {\n        scalarData: imageScalarData,\n        onCacheAdd,\n        skipCreateBuffer,\n        targetBuffer: {\n            type: imageScalarData.constructor.name,\n        },\n        dimensions: [imagePlaneModule.columns, imagePlaneModule.rows],\n        spacing: [\n            imagePlaneModule.columnPixelSpacing,\n            imagePlaneModule.rowPixelSpacing,\n        ],\n        origin: imagePlaneModule.imagePositionPatient,\n        direction: imagePlaneModule.imageOrientationPatient,\n        frameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n    });\n    localImage.referencedImageId = referencedImageId;\n    if (!cache.getImageLoadObject(imageId)) {\n        cache.putImageSync(imageId, localImage);\n    }\n    return localImage;\n}\nexport function createAndCacheDerivedImages(referencedImageIds, options = {}) {\n    if (referencedImageIds.length === 0) {\n        throw new Error('createAndCacheDerivedImages: parameter imageIds must be list of image Ids');\n    }\n    const derivedImageIds = [];\n    const images = referencedImageIds.map((referencedImageId, index) => {\n        const newOptions = {\n            imageId: options?.getDerivedImageId?.(referencedImageId) ||\n                `derived:${uuidv4()}`,\n            ...options,\n        };\n        derivedImageIds.push(newOptions.imageId);\n        return createAndCacheDerivedImage(referencedImageId, {\n            ...newOptions,\n            instanceNumber: index + 1,\n        });\n    });\n    return images;\n}\nexport function createAndCacheLocalImage(imageId, options) {\n    const { scalarData, origin, direction, targetBuffer, skipCreateBuffer, onCacheAdd, frameOfReferenceUID, } = options;\n    const dimensions = options.dimensions;\n    const spacing = options.spacing;\n    if (!dimensions || !spacing) {\n        throw new Error('createAndCacheLocalImage: dimensions and spacing are required');\n    }\n    const width = dimensions[0];\n    const height = dimensions[1];\n    const columnPixelSpacing = spacing[0];\n    const rowPixelSpacing = spacing[1];\n    const imagePlaneModule = {\n        frameOfReferenceUID,\n        rows: height,\n        columns: width,\n        imageOrientationPatient: direction ?? [1, 0, 0, 0, 1, 0],\n        rowCosines: direction ? direction.slice(0, 3) : [1, 0, 0],\n        columnCosines: direction ? direction.slice(3, 6) : [0, 1, 0],\n        imagePositionPatient: origin ?? [0, 0, 0],\n        pixelSpacing: [rowPixelSpacing, columnPixelSpacing],\n        rowPixelSpacing: rowPixelSpacing,\n        columnPixelSpacing: columnPixelSpacing,\n    };\n    const length = width * height;\n    const numberOfComponents = scalarData.length / length;\n    let scalarDataToUse;\n    if (scalarData) {\n        if (!(scalarData instanceof Uint8Array ||\n            scalarData instanceof Float32Array ||\n            scalarData instanceof Uint16Array ||\n            scalarData instanceof Int16Array)) {\n            throw new Error('createAndCacheLocalImage: scalarData must be of type Uint8Array, Uint16Array, Int16Array or Float32Array');\n        }\n        scalarDataToUse = scalarData;\n    }\n    else if (!skipCreateBuffer) {\n        const { numBytes, TypedArrayConstructor } = getBufferConfiguration(targetBuffer?.type, length);\n        const imageScalarData = new TypedArrayConstructor(length);\n        scalarDataToUse = imageScalarData;\n    }\n    let bitsAllocated, bitsStored, highBit;\n    if (scalarDataToUse instanceof Uint8Array) {\n        bitsAllocated = 8;\n        bitsStored = 8;\n        highBit = 7;\n    }\n    else if (scalarDataToUse instanceof Uint16Array) {\n        bitsAllocated = 16;\n        bitsStored = 16;\n        highBit = 15;\n    }\n    else if (scalarDataToUse instanceof Int16Array) {\n        bitsAllocated = 16;\n        bitsStored = 16;\n        highBit = 15;\n    }\n    else if (scalarDataToUse instanceof Float32Array) {\n        bitsAllocated = 32;\n        bitsStored = 32;\n        highBit = 31;\n    }\n    else {\n        throw new Error('Unsupported scalarData type');\n    }\n    const imagePixelModule = {\n        samplesPerPixel: 1,\n        photometricInterpretation: scalarDataToUse.length > dimensions[0] * dimensions[1]\n            ? 'RGB'\n            : 'MONOCHROME2',\n        rows: height,\n        columns: width,\n        bitsAllocated,\n        bitsStored,\n        highBit,\n    };\n    const metadata = {\n        imagePlaneModule,\n        imagePixelModule,\n    };\n    ['imagePlaneModule', 'imagePixelModule'].forEach((type) => {\n        genericMetadataProvider.add(imageId, {\n            type,\n            metadata: metadata[type] || {},\n        });\n    });\n    const voxelManager = VoxelManager.createImageVoxelManager({\n        height,\n        width,\n        numberOfComponents,\n        scalarData: scalarDataToUse,\n    });\n    let minPixelValue = scalarDataToUse[0];\n    let maxPixelValue = scalarDataToUse[0];\n    for (let i = 1; i < scalarDataToUse.length; i++) {\n        if (scalarDataToUse[i] < minPixelValue) {\n            minPixelValue = scalarDataToUse[i];\n        }\n        if (scalarDataToUse[i] > maxPixelValue) {\n            maxPixelValue = scalarDataToUse[i];\n        }\n    }\n    const image = {\n        imageId: imageId,\n        intercept: 0,\n        windowCenter: 0,\n        windowWidth: 0,\n        color: imagePixelModule.photometricInterpretation === 'RGB',\n        numberOfComponents: imagePixelModule.samplesPerPixel,\n        dataType: targetBuffer?.type,\n        slope: 1,\n        minPixelValue,\n        maxPixelValue,\n        rows: imagePixelModule.rows,\n        columns: imagePixelModule.columns,\n        getCanvas: undefined,\n        height: imagePixelModule.rows,\n        width: imagePixelModule.columns,\n        rgba: undefined,\n        columnPixelSpacing: imagePlaneModule.columnPixelSpacing,\n        rowPixelSpacing: imagePlaneModule.rowPixelSpacing,\n        FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n        invert: false,\n        getPixelData: () => voxelManager.getScalarData(),\n        voxelManager,\n        sizeInBytes: scalarData.byteLength,\n    };\n    onCacheAdd?.(image);\n    cache.putImageSync(image.imageId, image);\n    return image;\n}\nexport function cancelLoadImage(imageId) {\n    const filterFunction = ({ additionalDetails }) => {\n        if (additionalDetails.imageId) {\n            return additionalDetails.imageId !== imageId;\n        }\n        return true;\n    };\n    imageLoadPoolManager.filterRequests(filterFunction);\n    const imageLoadObject = cache.getImageLoadObject(imageId);\n    if (imageLoadObject) {\n        imageLoadObject.cancelFn();\n    }\n}\nexport function cancelLoadImages(imageIds) {\n    imageIds.forEach((imageId) => {\n        cancelLoadImage(imageId);\n    });\n}\nexport function cancelLoadAll() {\n    const requestPool = imageLoadPoolManager.getRequestPool();\n    Object.keys(requestPool).forEach((type) => {\n        const requests = requestPool[type];\n        Object.keys(requests).forEach((priority) => {\n            const requestDetails = requests[priority].pop();\n            const additionalDetails = requestDetails.additionalDetails;\n            const { imageId, volumeId } = additionalDetails;\n            let loadObject;\n            if (imageId) {\n                loadObject = cache.getImageLoadObject(imageId);\n            }\n            else if (volumeId) {\n                loadObject = cache.getVolumeLoadObject(volumeId);\n            }\n            if (loadObject) {\n                loadObject.cancel();\n            }\n        });\n        imageLoadPoolManager.clearRequestStack(type);\n    });\n}\nexport function registerImageLoader(scheme, imageLoader) {\n    imageLoaders[scheme] = imageLoader;\n}\nexport function registerUnknownImageLoader(imageLoader) {\n    const oldImageLoader = unknownImageLoader;\n    unknownImageLoader = imageLoader;\n    return oldImageLoader;\n}\nexport function unregisterAllImageLoaders() {\n    Object.keys(imageLoaders).forEach((imageLoader) => delete imageLoaders[imageLoader]);\n    unknownImageLoader = undefined;\n}\nexport function createAndCacheDerivedLabelmapImages(referencedImageIds, options = {}) {\n    return createAndCacheDerivedImages(referencedImageIds, {\n        ...options,\n        targetBuffer: { type: 'Uint8Array' },\n    });\n}\nexport function createAndCacheDerivedLabelmapImage(referencedImageId, options = {}) {\n    return createAndCacheDerivedImage(referencedImageId, {\n        ...options,\n        targetBuffer: { type: 'Uint8Array' },\n    });\n}\n","import { GeometryType } from '../../../enums';\nimport { validateContourSet } from './validateContourSet';\nimport { ContourSet } from '../../../cache/classes/ContourSet';\nexport function createContourSet(geometryId, contourSetData) {\n    validateContourSet(contourSetData);\n    const contourSet = new ContourSet({\n        id: contourSetData.id,\n        data: contourSetData.data,\n        color: contourSetData.color,\n        frameOfReferenceUID: contourSetData.frameOfReferenceUID,\n        segmentIndex: contourSetData.segmentIndex ?? 1,\n    });\n    const geometry = {\n        id: geometryId,\n        type: GeometryType.CONTOUR,\n        data: contourSet,\n        sizeInBytes: contourSet.sizeInBytes,\n    };\n    return geometry;\n}\n","export function validateContourSet(contourSetData) {\n    if (!contourSetData || contourSetData.data.length === 0) {\n        throw new Error('Invalid contour set data, see publicContourSetData type for more info');\n    }\n    if (!contourSetData.id) {\n        throw new Error('Invalid contour set data, each contour set must have an id');\n    }\n    if (!contourSetData.data || !Array.isArray(contourSetData.data)) {\n        throw new Error('Invalid contour set data, each contour set must have an array of contours');\n    }\n    contourSetData.data.forEach((contourData) => {\n        if (!contourData.points || !Array.isArray(contourData.points)) {\n            throw new Error('Invalid contour set data, each contour must have an array of points');\n        }\n        contourData.points.forEach((point) => {\n            if (!point || !Array.isArray(point) || point.length !== 3) {\n                throw new Error('Invalid contour set data, each point must be an array of length 3');\n            }\n        });\n    });\n}\n","import { GeometryType } from '../../../enums';\nimport { validateSurface } from './validateSurface';\nimport { Surface } from '../../../cache/classes/Surface';\nexport function createSurface(geometryId, surfaceData) {\n    validateSurface(surfaceData);\n    const surface = new Surface({\n        id: surfaceData.id,\n        points: surfaceData.points,\n        polys: surfaceData.polys,\n        color: surfaceData.color,\n        frameOfReferenceUID: surfaceData.frameOfReferenceUID,\n        segmentIndex: surfaceData.segmentIndex ?? 1,\n    });\n    const geometry = {\n        id: geometryId,\n        type: GeometryType.SURFACE,\n        data: surface,\n        sizeInBytes: surface.sizeInBytes,\n    };\n    return geometry;\n}\n","export function validateSurface(surfaceData) {\n    if (!surfaceData.id) {\n        throw new Error('Surface must have an id');\n    }\n    if (surfaceData.points?.length === 0) {\n        throw new Error('Surface must have non-empty points array');\n    }\n    if (surfaceData.polys?.length === 0) {\n        throw new Error('Surface must have non-empty polys array');\n    }\n    if (!surfaceData.frameOfReferenceUID) {\n        throw new Error('Surface must have a frameOfReferenceUID');\n    }\n}\n","import '@kitware/vtk.js/Rendering/Profiles/Volume';\nimport { ImageVolume } from '../cache/classes/ImageVolume';\nimport cache from '../cache/cache';\nimport Events from '../enums/Events';\nimport eventTarget from '../eventTarget';\nimport triggerEvent from '../utilities/triggerEvent';\nimport uuidv4 from '../utilities/uuidv4';\nimport VoxelManager from '../utilities/VoxelManager';\nimport { createAndCacheLocalImage, createAndCacheDerivedImages, } from './imageLoader';\nimport { generateVolumePropsFromImageIds } from '../utilities/generateVolumePropsFromImageIds';\nimport { cornerstoneStreamingImageVolumeLoader } from './cornerstoneStreamingImageVolumeLoader';\nconst volumeLoaders = {};\nlet unknownVolumeLoader = cornerstoneStreamingImageVolumeLoader;\nfunction loadVolumeFromVolumeLoader(volumeId, options) {\n    const colonIndex = volumeId.indexOf(':');\n    const scheme = volumeId.substring(0, colonIndex);\n    let loader = volumeLoaders[scheme];\n    if (loader === undefined || loader === null) {\n        if (unknownVolumeLoader == null ||\n            typeof unknownVolumeLoader !== 'function') {\n            throw new Error(`No volume loader for scheme ${scheme} has been registered`);\n        }\n        loader = unknownVolumeLoader;\n    }\n    const volumeLoadObject = loader(volumeId, options);\n    volumeLoadObject.promise.then(function (volume) {\n        triggerEvent(eventTarget, Events.VOLUME_LOADED, { volume });\n    }, function (error) {\n        const errorObject = {\n            volumeId,\n            error,\n        };\n        triggerEvent(eventTarget, Events.VOLUME_LOADED_FAILED, errorObject);\n    });\n    return volumeLoadObject;\n}\nexport function loadVolume(volumeId, options = { imageIds: [] }) {\n    if (volumeId === undefined) {\n        throw new Error('loadVolume: parameter volumeId must not be undefined');\n    }\n    let volumeLoadObject = cache.getVolumeLoadObject(volumeId);\n    if (volumeLoadObject !== undefined) {\n        return volumeLoadObject.promise;\n    }\n    volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);\n    return volumeLoadObject.promise.then((volume) => {\n        return volume;\n    });\n}\nexport async function createAndCacheVolume(volumeId, options) {\n    if (volumeId === undefined) {\n        throw new Error('createAndCacheVolume: parameter volumeId must not be undefined');\n    }\n    let volumeLoadObject = cache.getVolumeLoadObject(volumeId);\n    if (volumeLoadObject !== undefined) {\n        return volumeLoadObject.promise;\n    }\n    volumeLoadObject = loadVolumeFromVolumeLoader(volumeId, options);\n    cache.putVolumeLoadObject(volumeId, volumeLoadObject);\n    return volumeLoadObject.promise;\n}\nexport function createAndCacheDerivedVolume(referencedVolumeId, options) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    if (!referencedVolume) {\n        throw new Error(`Cannot created derived volume: Referenced volume with id ${referencedVolumeId} does not exist.`);\n    }\n    let { volumeId } = options;\n    if (volumeId === undefined) {\n        volumeId = uuidv4();\n    }\n    const { metadata, dimensions, spacing, origin, direction } = referencedVolume;\n    const referencedImageIds = referencedVolume.isDynamicVolume()\n        ? referencedVolume.getCurrentTimePointImageIds()\n        : referencedVolume.imageIds ?? [];\n    const derivedImages = createAndCacheDerivedImages(referencedImageIds, {\n        targetBuffer: options.targetBuffer,\n    });\n    const dataType = derivedImages[0].dataType;\n    const derivedVolumeImageIds = derivedImages.map((image) => image.imageId);\n    const derivedVolume = new ImageVolume({\n        volumeId,\n        dataType,\n        metadata: structuredClone(metadata),\n        dimensions: [dimensions[0], dimensions[1], dimensions[2]],\n        spacing,\n        origin,\n        direction,\n        referencedVolumeId,\n        imageIds: derivedVolumeImageIds,\n        referencedImageIds: referencedVolume.imageIds ?? [],\n    });\n    cache.putVolumeSync(volumeId, derivedVolume);\n    return derivedVolume;\n}\nexport async function createAndCacheVolumeFromImages(volumeId, imageIds) {\n    if (imageIds === undefined) {\n        throw new Error('createAndCacheVolumeFromImages: parameter imageIds must not be undefined');\n    }\n    if (volumeId === undefined) {\n        throw new Error('createAndCacheVolumeFromImages: parameter volumeId must not be undefined');\n    }\n    const cachedVolume = cache.getVolume(volumeId);\n    if (cachedVolume) {\n        return cachedVolume;\n    }\n    const imageIdsToLoad = imageIds.filter((imageId) => !cache.getImage(imageId));\n    if (imageIdsToLoad.length === 0) {\n        return createAndCacheVolumeFromImagesSync(volumeId, imageIds);\n    }\n    const volume = (await createAndCacheVolume(volumeId, {\n        imageIds,\n    }));\n    return volume;\n}\nexport function createAndCacheVolumeFromImagesSync(volumeId, imageIds) {\n    if (imageIds === undefined) {\n        throw new Error('createAndCacheVolumeFromImagesSync: parameter imageIds must not be undefined');\n    }\n    if (volumeId === undefined) {\n        throw new Error('createAndCacheVolumeFromImagesSync: parameter volumeId must not be undefined');\n    }\n    const cachedVolume = cache.getVolume(volumeId);\n    if (cachedVolume) {\n        return cachedVolume;\n    }\n    const volumeProps = generateVolumePropsFromImageIds(imageIds, volumeId);\n    const derivedVolume = new ImageVolume({\n        volumeId,\n        dataType: volumeProps.dataType,\n        metadata: structuredClone(volumeProps.metadata),\n        dimensions: volumeProps.dimensions,\n        spacing: volumeProps.spacing,\n        origin: volumeProps.origin,\n        direction: volumeProps.direction,\n        referencedVolumeId: volumeProps.referencedVolumeId,\n        imageIds: volumeProps.imageIds,\n        referencedImageIds: volumeProps.referencedImageIds,\n    });\n    cache.putVolumeSync(volumeId, derivedVolume);\n    return derivedVolume;\n}\nexport function createLocalVolume(volumeId, options = {}) {\n    const { metadata, dimensions, spacing, origin, direction, scalarData, targetBuffer, preventCache = false, } = options;\n    const cachedVolume = cache.getVolume(volumeId);\n    if (cachedVolume) {\n        return cachedVolume;\n    }\n    const sliceLength = dimensions[0] * dimensions[1];\n    const dataType = scalarData\n        ? scalarData.constructor.name\n        : targetBuffer?.type ?? 'Float32Array';\n    const totalNumberOfVoxels = sliceLength * dimensions[2];\n    let byteLength;\n    switch (dataType) {\n        case 'Uint8Array':\n        case 'Int8Array':\n            byteLength = totalNumberOfVoxels;\n            break;\n        case 'Uint16Array':\n        case 'Int16Array':\n            byteLength = totalNumberOfVoxels * 2;\n            break;\n        case 'Float32Array':\n            byteLength = totalNumberOfVoxels * 4;\n            break;\n    }\n    const isCacheable = cache.isCacheable(byteLength);\n    if (!isCacheable) {\n        throw new Error(`Cannot created derived volume: Volume with id ${volumeId} is not cacheable.`);\n    }\n    const imageIds = [];\n    const derivedImages = [];\n    for (let i = 0; i < dimensions[2]; i++) {\n        const imageId = `${volumeId}_slice_${i}`;\n        imageIds.push(imageId);\n        const sliceData = scalarData.subarray(i * sliceLength, (i + 1) * sliceLength);\n        const derivedImage = createAndCacheLocalImage(imageId, {\n            scalarData: sliceData,\n            dimensions: [dimensions[0], dimensions[1]],\n            spacing: [spacing[0], spacing[1]],\n            origin,\n            direction,\n            targetBuffer: { type: dataType },\n        });\n        derivedImages.push(derivedImage);\n    }\n    const imageVolume = new ImageVolume({\n        volumeId,\n        metadata: structuredClone(metadata),\n        dimensions: [dimensions[0], dimensions[1], dimensions[2]],\n        spacing,\n        origin,\n        direction,\n        imageIds,\n        dataType,\n    });\n    const voxelManager = VoxelManager.createImageVolumeVoxelManager({\n        imageIds,\n        dimensions,\n        numberOfComponents: 1,\n    });\n    imageVolume.voxelManager = voxelManager;\n    if (!preventCache) {\n        cache.putVolumeSync(volumeId, imageVolume);\n    }\n    return imageVolume;\n}\nexport function registerVolumeLoader(scheme, volumeLoader) {\n    volumeLoaders[scheme] = volumeLoader;\n}\nexport function getVolumeLoaderSchemes() {\n    return Object.keys(volumeLoaders);\n}\nexport function registerUnknownVolumeLoader(volumeLoader) {\n    const oldVolumeLoader = unknownVolumeLoader;\n    unknownVolumeLoader = volumeLoader;\n    return oldVolumeLoader;\n}\nexport function getUnknownVolumeLoaderSchema() {\n    return unknownVolumeLoader.name;\n}\nexport function createAndCacheDerivedLabelmapVolume(referencedVolumeId, options = {}) {\n    return createAndCacheDerivedVolume(referencedVolumeId, {\n        ...options,\n        targetBuffer: { type: 'Uint8Array' },\n    });\n}\nexport function createLocalLabelmapVolume(options, volumeId, preventCache = false) {\n    if (!options.scalarData) {\n        options.scalarData = new Uint8Array(options.dimensions[0] * options.dimensions[1] * options.dimensions[2]);\n    }\n    return createLocalVolume(volumeId, { ...options, preventCache });\n}\n","export class PromiseIterator extends Promise {\n}\nexport default class ProgressiveIterator {\n    constructor(name) {\n        this.name = name || 'unknown';\n    }\n    static as(promise) {\n        if (promise.iterator) {\n            return promise.iterator;\n        }\n        const iterator = new ProgressiveIterator('as iterator');\n        promise.then((v) => {\n            try {\n                iterator.add(v, true);\n            }\n            catch (e) {\n                iterator.reject(e);\n            }\n        }, (reason) => {\n            iterator.reject(reason);\n        });\n        return iterator;\n    }\n    add(x, done = false) {\n        this.nextValue = x;\n        this.done ||= done;\n        if (this.waiting) {\n            this.waiting.resolve(x);\n            this.waiting = undefined;\n        }\n    }\n    resolve() {\n        this.done = true;\n        if (this.waiting) {\n            this.waiting.resolve(this.nextValue);\n            this.waiting = undefined;\n        }\n    }\n    reject(reason) {\n        this.rejectReason = reason;\n        this.waiting?.reject(reason);\n    }\n    getRecent() {\n        if (this.rejectReason) {\n            throw this.rejectReason;\n        }\n        return this.nextValue;\n    }\n    async *[Symbol.asyncIterator]() {\n        while (!this.done) {\n            if (this.rejectReason) {\n                throw this.rejectReason;\n            }\n            if (this.nextValue !== undefined) {\n                yield this.nextValue;\n                if (this.done) {\n                    break;\n                }\n            }\n            if (!this.waiting) {\n                this.waiting = {};\n                this.waiting.promise = new Promise((resolve, reject) => {\n                    this.waiting.resolve = resolve;\n                    this.waiting.reject = reject;\n                });\n            }\n            await this.waiting.promise;\n        }\n        yield this.nextValue;\n    }\n    async forEach(callback, errorCallback) {\n        let index = 0;\n        try {\n            for await (const value of this) {\n                const { done } = this;\n                try {\n                    await callback(value, done, index);\n                    index++;\n                }\n                catch (e) {\n                    if (!done) {\n                        console.warn('Caught exception in intermediate value', e);\n                        continue;\n                    }\n                    if (errorCallback) {\n                        errorCallback(e, done);\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n        }\n        catch (e) {\n            if (errorCallback) {\n                errorCallback(e, true);\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    generate(processFunction, errorCallback) {\n        return processFunction(this, this.reject.bind(this)).then(() => {\n            if (!this.done) {\n                this.resolve();\n            }\n        }, (reason) => {\n            this.reject(reason);\n            if (errorCallback) {\n                errorCallback(reason);\n            }\n            else {\n                console.warn(\"Couldn't process because\", reason);\n            }\n        });\n    }\n    async nextPromise() {\n        for await (const i of this) {\n            if (i) {\n                return i;\n            }\n        }\n        return this.nextValue;\n    }\n    async donePromise() {\n        for await (const i of this) {\n        }\n        return this.nextValue;\n    }\n    getNextPromise() {\n        const promise = this.nextPromise();\n        promise.iterator = this;\n        return promise;\n    }\n    getDonePromise() {\n        const promise = this.donePromise();\n        promise.iterator = this;\n        return promise;\n    }\n}\n","export default class RLEVoxelMap {\n    constructor(width, height, depth = 1) {\n        this.rows = new Map();\n        this.height = 1;\n        this.width = 1;\n        this.depth = 1;\n        this.jMultiple = 1;\n        this.kMultiple = 1;\n        this.numberOfComponents = 1;\n        this.defaultValue = 0;\n        this.pixelDataConstructor = Uint8Array;\n        this.get = (index) => {\n            const i = index % this.jMultiple;\n            const j = (index - i) / this.jMultiple;\n            const rle = this.getRLE(i, j);\n            return rle?.value || this.defaultValue;\n        };\n        this.getRun = (j, k) => {\n            const runIndex = j + k * this.height;\n            return this.rows.get(runIndex);\n        };\n        this.set = (index, value) => {\n            if (value === undefined) {\n                throw new Error(`Can't set undefined at ${index % this.width}`);\n            }\n            const i = index % this.width;\n            const j = (index - i) / this.width;\n            const row = this.rows.get(j);\n            if (!row) {\n                this.rows.set(j, [{ start: i, end: i + 1, value }]);\n                return;\n            }\n            const rleIndex = this.findIndex(row, i);\n            const rle1 = row[rleIndex];\n            const rle0 = row[rleIndex - 1];\n            if (!rle1) {\n                if (!rle0 || rle0.value !== value || rle0.end !== i) {\n                    row[rleIndex] = { start: i, end: i + 1, value };\n                    return;\n                }\n                rle0.end++;\n                return;\n            }\n            const { start, end, value: oldValue } = rle1;\n            if (value === oldValue && i >= start) {\n                return;\n            }\n            const rleInsert = { start: i, end: i + 1, value };\n            const isAfter = i > start;\n            const insertIndex = isAfter ? rleIndex + 1 : rleIndex;\n            const rlePrev = isAfter ? rle1 : rle0;\n            let rleNext = isAfter ? row[rleIndex + 1] : rle1;\n            if (rlePrev?.value === value && rlePrev.end === i) {\n                rlePrev.end++;\n                if (rleNext?.value === value && rleNext.start === i + 1) {\n                    rlePrev.end = rleNext.end;\n                    row.splice(rleIndex, 1);\n                }\n                else if (rleNext?.start === i) {\n                    rleNext.start++;\n                    if (rleNext.start === rleNext.end) {\n                        row.splice(rleIndex, 1);\n                        rleNext = row[rleIndex];\n                        if (rleNext?.start === i + 1 && rleNext.value === value) {\n                            rlePrev.end = rleNext.end;\n                            row.splice(rleIndex, 1);\n                        }\n                    }\n                }\n                return;\n            }\n            if (rleNext?.value === value && rleNext.start === i + 1) {\n                rleNext.start--;\n                if (rlePrev?.end > i) {\n                    rlePrev.end = i;\n                    if (rlePrev.end === rlePrev.start) {\n                        row.splice(rleIndex, 1);\n                    }\n                }\n                return;\n            }\n            if (rleNext?.start === i && rleNext.end === i + 1) {\n                rleNext.value = value;\n                const nextnext = row[rleIndex + 1];\n                if (nextnext?.start == i + 1 && nextnext?.value === value) {\n                    row.splice(rleIndex + 1, 1);\n                    rleNext.end = nextnext.end;\n                }\n                return;\n            }\n            if (i === rleNext?.start) {\n                rleNext.start++;\n            }\n            if (isAfter && end > i + 1) {\n                row.splice(insertIndex, 0, rleInsert, {\n                    start: i + 1,\n                    end: rlePrev.end,\n                    value: rlePrev.value,\n                });\n            }\n            else {\n                row.splice(insertIndex, 0, rleInsert);\n            }\n            if (rlePrev?.end > i) {\n                rlePrev.end = i;\n            }\n        };\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        this.jMultiple = width;\n        this.kMultiple = this.jMultiple * height;\n    }\n    getRLE(i, j, k = 0) {\n        const row = this.rows.get(j + k * this.height);\n        if (!row) {\n            return;\n        }\n        const index = this.findIndex(row, i);\n        const rle = row[index];\n        return i >= rle?.start ? rle : undefined;\n    }\n    findIndex(row, i) {\n        for (let index = 0; index < row.length; index++) {\n            const { end: iEnd } = row[index];\n            if (i < iEnd) {\n                return index;\n            }\n        }\n        return row.length;\n    }\n    clear() {\n        this.rows.clear();\n    }\n    keys() {\n        return [...this.rows.keys()];\n    }\n    getPixelData(k = 0, pixelData) {\n        if (!pixelData) {\n            pixelData = new this.pixelDataConstructor(this.width * this.height * this.numberOfComponents);\n        }\n        else {\n            pixelData.fill(0);\n        }\n        const { width, height, numberOfComponents } = this;\n        for (let j = 0; j < height; j++) {\n            const row = this.getRun(j, k);\n            if (!row) {\n                continue;\n            }\n            if (numberOfComponents === 1) {\n                for (const rle of row) {\n                    const rowOffset = j * width;\n                    const { start, end, value } = rle;\n                    for (let i = start; i < end; i++) {\n                        pixelData[rowOffset + i] = value;\n                    }\n                }\n            }\n            else {\n                for (const rle of row) {\n                    const rowOffset = j * width * numberOfComponents;\n                    const { start, end, value } = rle;\n                    for (let i = start; i < end; i += numberOfComponents) {\n                        for (let comp = 0; comp < numberOfComponents; comp++) {\n                            pixelData[rowOffset + i + comp] = value[comp];\n                        }\n                    }\n                }\n            }\n        }\n        return pixelData;\n    }\n}\n","export function isImageActor(actorEntry) {\n    return (actorIsA(actorEntry, 'vtkVolume') || actorIsA(actorEntry, 'vtkImageSlice'));\n}\nexport function actorIsA(actorEntry, actorType) {\n    const actorToCheck = 'isA' in actorEntry ? actorEntry : actorEntry.actor;\n    return !!actorToCheck.isA(actorType);\n}\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nexport default function applyPreset(actor, preset) {\n    const colorTransferArray = preset.colorTransfer\n        .split(' ')\n        .splice(1)\n        .map(parseFloat);\n    const { shiftRange } = getShiftRange(colorTransferArray);\n    const min = shiftRange[0];\n    const width = shiftRange[1] - shiftRange[0];\n    const cfun = vtkColorTransferFunction.newInstance();\n    const normColorTransferValuePoints = [];\n    for (let i = 0; i < colorTransferArray.length; i += 4) {\n        let value = colorTransferArray[i];\n        const r = colorTransferArray[i + 1];\n        const g = colorTransferArray[i + 2];\n        const b = colorTransferArray[i + 3];\n        value = (value - min) / width;\n        normColorTransferValuePoints.push([value, r, g, b]);\n    }\n    applyPointsToRGBFunction(normColorTransferValuePoints, shiftRange, cfun);\n    actor.getProperty().setRGBTransferFunction(0, cfun);\n    const scalarOpacityArray = preset.scalarOpacity\n        .split(' ')\n        .splice(1)\n        .map(parseFloat);\n    const ofun = vtkPiecewiseFunction.newInstance();\n    const normPoints = [];\n    for (let i = 0; i < scalarOpacityArray.length; i += 2) {\n        let value = scalarOpacityArray[i];\n        const opacity = scalarOpacityArray[i + 1];\n        value = (value - min) / width;\n        normPoints.push([value, opacity]);\n    }\n    applyPointsToPiecewiseFunction(normPoints, shiftRange, ofun);\n    const property = actor.getProperty();\n    property.setScalarOpacity(0, ofun);\n    const [gradientMinValue, gradientMinOpacity, gradientMaxValue, gradientMaxOpacity,] = preset.gradientOpacity.split(' ').splice(1).map(parseFloat);\n    property.setUseGradientOpacity(0, true);\n    property.setGradientOpacityMinimumValue(0, gradientMinValue);\n    property.setGradientOpacityMinimumOpacity(0, gradientMinOpacity);\n    property.setGradientOpacityMaximumValue(0, gradientMaxValue);\n    property.setGradientOpacityMaximumOpacity(0, gradientMaxOpacity);\n    if (preset.interpolation === '1') {\n        property.setInterpolationTypeToFastLinear();\n    }\n    property.setShade(preset.shade === '1');\n    const ambient = parseFloat(preset.ambient);\n    const diffuse = parseFloat(preset.diffuse);\n    const specular = parseFloat(preset.specular);\n    const specularPower = parseFloat(preset.specularPower);\n    property.setAmbient(ambient);\n    property.setDiffuse(diffuse);\n    property.setSpecular(specular);\n    property.setSpecularPower(specularPower);\n}\nfunction getShiftRange(colorTransferArray) {\n    let min = Infinity;\n    let max = -Infinity;\n    for (let i = 0; i < colorTransferArray.length; i += 4) {\n        min = Math.min(min, colorTransferArray[i]);\n        max = Math.max(max, colorTransferArray[i]);\n    }\n    const center = (max - min) / 2;\n    return {\n        shiftRange: [-center, center],\n        min,\n        max,\n    };\n}\nfunction applyPointsToRGBFunction(points, range, cfun) {\n    const width = range[1] - range[0];\n    const rescaled = points.map(([x, r, g, b]) => [\n        x * width + range[0],\n        r,\n        g,\n        b,\n    ]);\n    cfun.removeAllPoints();\n    rescaled.forEach(([x, r, g, b]) => cfun.addRGBPoint(x, r, g, b));\n    return rescaled;\n}\nfunction applyPointsToPiecewiseFunction(points, range, pwf) {\n    const width = range[1] - range[0];\n    const rescaled = points.map(([x, y]) => [x * width + range[0], y]);\n    pwf.removeAllPoints();\n    rescaled.forEach(([x, y]) => pwf.addPoint(x, y));\n    return rescaled;\n}\n","import { getRenderingEngines } from '../RenderingEngine/getRenderingEngine';\nimport getViewportsWithVolumeId from './getViewportsWithVolumeId';\nconst autoLoad = (volumeId) => {\n    const renderingEngineAndViewportIds = getRenderingEngineAndViewportsContainingVolume(volumeId);\n    if (!renderingEngineAndViewportIds?.length) {\n        return;\n    }\n    renderingEngineAndViewportIds.forEach(({ renderingEngine, viewportIds }) => {\n        if (!renderingEngine.hasBeenDestroyed) {\n            renderingEngine.renderViewports(viewportIds);\n        }\n    });\n};\nfunction getRenderingEngineAndViewportsContainingVolume(volumeId) {\n    const renderingEnginesArray = getRenderingEngines();\n    const renderingEngineAndViewportIds = [];\n    renderingEnginesArray.forEach((renderingEngine) => {\n        const viewports = getViewportsWithVolumeId(volumeId);\n        if (viewports.length) {\n            renderingEngineAndViewportIds.push({\n                renderingEngine,\n                viewportIds: viewports.map((viewport) => viewport.id),\n            });\n        }\n    });\n    return renderingEngineAndViewportIds;\n}\nexport default autoLoad;\n","function clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\nexport { clamp as default, clamp };\n","import vtkColorMaps from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport isEqual from './isEqual';\nimport { actorIsA } from './actorCheck';\nconst _colormaps = new Map();\nfunction registerColormap(colormap) {\n    _colormaps.set(colormap.Name, colormap);\n}\nfunction getColormap(name) {\n    return _colormaps.get(name);\n}\nfunction getColormapNames() {\n    return Array.from(_colormaps.keys());\n}\nfunction findMatchingColormap(rgbPoints, actor) {\n    const colormapsVTK = vtkColorMaps.rgbPresetNames.map((presetName) => vtkColorMaps.getPresetByName(presetName));\n    const colormapsCS3D = getColormapNames().map((colormapName) => getColormap(colormapName));\n    const colormaps = colormapsVTK.concat(colormapsCS3D);\n    const matchedColormap = colormaps.find((colormap) => {\n        const { RGBPoints: presetRGBPoints } = colormap;\n        if (presetRGBPoints.length !== rgbPoints.length) {\n            return false;\n        }\n        for (let i = 0; i < presetRGBPoints.length; i += 4) {\n            if (!isEqual(presetRGBPoints.slice(i + 1, i + 4), rgbPoints.slice(i + 1, i + 4))) {\n                return false;\n            }\n        }\n        return true;\n    });\n    if (!matchedColormap) {\n        return null;\n    }\n    const opacity = [];\n    if (actorIsA(actor, 'vtkVolume')) {\n        const opacityPoints = actor\n            .getProperty()\n            .getScalarOpacity(0)\n            .getDataPointer();\n        if (!opacityPoints) {\n            return {\n                name: matchedColormap.Name,\n            };\n        }\n        for (let i = 0; i < opacityPoints.length; i += 2) {\n            opacity.push({\n                value: opacityPoints[i],\n                opacity: opacityPoints[i + 1],\n            });\n        }\n    }\n    return {\n        name: matchedColormap.Name,\n        opacity,\n    };\n}\nexport { getColormap, getColormapNames, registerColormap, findMatchingColormap, };\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nexport default function createLinearRGBTransferFunction(voiRange) {\n    const cfun = vtkColorTransferFunction.newInstance();\n    let lower = 0;\n    let upper = 1024;\n    if (voiRange.lower !== undefined && voiRange.upper !== undefined) {\n        lower = voiRange.lower;\n        upper = voiRange.upper;\n    }\n    cfun.addRGBPoint(lower, 0.0, 0.0, 0.0);\n    cfun.addRGBPoint(upper, 1.0, 1.0, 1.0);\n    return cfun;\n}\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport * as windowLevelUtil from './windowLevel';\nexport default function createSigmoidRGBTransferFunction(voiRange, approximationNodes = 1024) {\n    const { windowWidth, windowCenter } = windowLevelUtil.toWindowLevel(voiRange.lower, voiRange.upper);\n    const sigmoid = (x, wc, ww) => {\n        return 1 / (1 + Math.exp((-4 * (x - wc)) / ww));\n    };\n    const logit = (y, wc, ww) => {\n        return wc - (ww / 4) * Math.log((1 - y) / y);\n    };\n    const range = Array.from({ length: approximationNodes }, (_, i) => (i + 1) / (approximationNodes + 2));\n    const table = range.flatMap((y) => {\n        const x = logit(y, windowCenter, windowWidth);\n        return [x, y, y, y, 0.5, 0.0];\n    });\n    const cfun = vtkColorTransferFunction.newInstance();\n    cfun.buildFunctionFromArray(vtkDataArray.newInstance({\n        values: table,\n        numberOfComponents: 6,\n    }));\n    return cfun;\n}\n","export default function decimate(list, interleave, offset = 0) {\n    const interleaveIndices = [];\n    for (let i = offset; i < list.length; i += interleave) {\n        interleaveIndices.push(i);\n    }\n    return interleaveIndices;\n}\n","export function deepClone(obj) {\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    if (typeof obj === 'function') {\n        return obj;\n    }\n    if (typeof structuredClone === 'function') {\n        return obj;\n    }\n    if (Array.isArray(obj)) {\n        return obj.map(deepClone);\n    }\n    else {\n        const clonedObj = {};\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clonedObj[key] = deepClone(obj[key]);\n            }\n        }\n        return clonedObj;\n    }\n}\n","import { vec3 } from 'gl-matrix';\nimport * as metaData from '../metaData';\nimport getSpacingInNormalDirection from './getSpacingInNormalDirection';\nimport { EPSILON } from '../constants';\nexport default function getClosestImageId(imageVolume, worldPos, viewPlaneNormal) {\n    const { direction, spacing, imageIds } = imageVolume;\n    if (!imageIds.length) {\n        return;\n    }\n    const kVector = direction.slice(6, 9);\n    const dotProducts = vec3.dot(kVector, viewPlaneNormal);\n    if (Math.abs(dotProducts) < 1 - EPSILON) {\n        return;\n    }\n    const spacingInNormalDirection = getSpacingInNormalDirection({ direction, spacing }, viewPlaneNormal);\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    let imageIdForTool;\n    for (let i = 0; i < imageIds.length; i++) {\n        const imageId = imageIds[i];\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const dir = vec3.create();\n        vec3.sub(dir, worldPos, imagePositionPatient);\n        const dot = vec3.dot(dir, viewPlaneNormal);\n        if (Math.abs(dot) < halfSpacingInNormalDirection) {\n            imageIdForTool = imageId;\n        }\n    }\n    return imageIdForTool;\n}\n","import getSliceRange from './getSliceRange';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\nfunction getImageSliceDataForVolumeViewport(viewport) {\n    const camera = viewport.getCamera();\n    const { spacingInNormalDirection, imageVolume } = getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n    if (!imageVolume) {\n        return;\n    }\n    const { viewPlaneNormal, focalPoint } = camera;\n    const actorEntry = viewport\n        .getActors()\n        .find((a) => a.referencedId === imageVolume.volumeId ||\n        a.uid === imageVolume.volumeId);\n    if (!actorEntry) {\n        console.warn('No actor found for with actorUID of', imageVolume.volumeId);\n    }\n    const volumeActor = actorEntry.actor;\n    const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);\n    const { min, max, current } = sliceRange;\n    const numberOfSlices = Math.round((max - min) / spacingInNormalDirection) + 1;\n    let imageIndex = ((current - min) / (max - min)) * numberOfSlices;\n    imageIndex = Math.floor(imageIndex);\n    if (imageIndex > numberOfSlices - 1) {\n        imageIndex = numberOfSlices - 1;\n    }\n    else if (imageIndex < 0) {\n        imageIndex = 0;\n    }\n    return {\n        numberOfSlices,\n        imageIndex,\n    };\n}\nexport default getImageSliceDataForVolumeViewport;\n","export default function getMinMax(storedPixelData) {\n    let min = storedPixelData[0];\n    let max = storedPixelData[0];\n    let storedPixel;\n    const numPixels = storedPixelData.length;\n    for (let index = 1; index < numPixels; index++) {\n        storedPixel = storedPixelData[index];\n        min = Math.min(min, storedPixel);\n        max = Math.max(max, storedPixel);\n    }\n    return {\n        min,\n        max,\n    };\n}\n","import * as metaData from '../metaData';\nexport default function getScalingParameters(imageId) {\n    const modalityLutModule = metaData.get('modalityLutModule', imageId) || {};\n    const generalSeriesModule = metaData.get('generalSeriesModule', imageId) || {};\n    const { modality } = generalSeriesModule;\n    const scalingParameters = {\n        rescaleSlope: modalityLutModule.rescaleSlope || 1,\n        rescaleIntercept: modalityLutModule.rescaleIntercept ?? 0,\n        modality,\n    };\n    const suvFactor = metaData.get('scalingModule', imageId) || {};\n    return {\n        ...scalingParameters,\n        ...(modality === 'PT' && {\n            suvbw: suvFactor.suvbw,\n            suvbsa: suvFactor.suvbsa,\n            suvlbm: suvFactor.suvlbm,\n        }),\n    };\n}\n","import vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\nimport getVolumeActorCorners from './getVolumeActorCorners';\nimport { EPSILON } from '../constants';\nconst SMALL_EPSILON = EPSILON * EPSILON;\nconst isOne = (v) => Math.abs(Math.abs(v) - 1) < SMALL_EPSILON;\nconst isUnit = (v, off) => isOne(v[off]) || isOne(v[off + 1]) || isOne(v[off + 2]);\nconst isOrthonormal = (v) => isUnit(v, 0) && isUnit(v, 3) && isUnit(v, 6);\nexport default function getSliceRange(volumeActor, viewPlaneNormal, focalPoint) {\n    const imageData = volumeActor.getMapper().getInputData();\n    let corners;\n    const direction = imageData.getDirection();\n    if (isOrthonormal(direction)) {\n        corners = getVolumeActorCorners(volumeActor);\n    }\n    else {\n        const [dx, dy, dz] = imageData.getDimensions();\n        const cornersIdx = [\n            [0, 0, 0],\n            [dx - 1, 0, 0],\n            [0, dy - 1, 0],\n            [dx - 1, dy - 1, 0],\n            [0, 0, dz - 1],\n            [dx - 1, 0, dz - 1],\n            [0, dy - 1, dz - 1],\n            [dx - 1, dy - 1, dz - 1],\n        ];\n        corners = cornersIdx.map((it) => imageData.indexToWorld(it));\n    }\n    const transform = vtkMatrixBuilder\n        .buildFromDegree()\n        .identity()\n        .rotateFromDirections(viewPlaneNormal, [1, 0, 0]);\n    corners.forEach((pt) => transform.apply(pt));\n    const transformedFocalPoint = [...focalPoint];\n    transform.apply(transformedFocalPoint);\n    const currentSlice = transformedFocalPoint[0];\n    let minX = Infinity;\n    let maxX = -Infinity;\n    for (let i = 0; i < 8; i++) {\n        const x = corners[i][0];\n        if (x > maxX) {\n            maxX = x;\n        }\n        if (x < minX) {\n            minX = x;\n        }\n    }\n    return {\n        min: minX,\n        max: maxX,\n        current: currentSlice,\n        actor: volumeActor,\n        viewPlaneNormal,\n        focalPoint,\n    };\n}\n","import { vec3 } from 'gl-matrix';\nexport default function getSpacingInNormalDirection(imageVolume, viewPlaneNormal) {\n    const { direction, spacing } = imageVolume;\n    const iVector = direction.slice(0, 3);\n    const jVector = direction.slice(3, 6);\n    const kVector = direction.slice(6, 9);\n    const dotProducts = [\n        vec3.dot(iVector, viewPlaneNormal),\n        vec3.dot(jVector, viewPlaneNormal),\n        vec3.dot(kVector, viewPlaneNormal),\n    ];\n    const projectedSpacing = vec3.create();\n    vec3.set(projectedSpacing, dotProducts[0] * spacing[0], dotProducts[1] * spacing[1], dotProducts[2] * spacing[2]);\n    const spacingInNormalDirection = vec3.length(projectedSpacing);\n    return spacingInNormalDirection;\n}\n","import cache from '../cache/cache';\nimport { EPSILON } from '../constants';\nimport getSpacingInNormalDirection from './getSpacingInNormalDirection';\nimport { getVolumeLoaderSchemes } from '../loaders/volumeLoader';\nimport { getVolumeId } from './getVolumeId';\nconst EPSILON_PART = 1 + EPSILON;\nconst startsWith = (str, starts) => starts === str.substring(0, Math.min(str.length, starts.length));\nconst isPrimaryVolume = (volume) => !!getVolumeLoaderSchemes().find((scheme) => startsWith(volume.volumeId, scheme));\nexport default function getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetId, useSlabThickness = false) {\n    const { viewPlaneNormal } = camera;\n    const volumeActors = viewport.getActors();\n    if (!volumeActors.length) {\n        return {\n            spacingInNormalDirection: null,\n            imageVolume: null,\n            actorUID: null,\n        };\n    }\n    const imageVolumes = volumeActors\n        .map((va) => {\n        const actorUID = va.referencedId ?? va.uid;\n        return cache.getVolume(actorUID);\n    })\n        .filter((iv) => !!iv);\n    if (targetId) {\n        const targetVolumeId = getVolumeId(targetId);\n        const imageVolumeIndex = imageVolumes.findIndex((iv) => targetVolumeId.includes(iv.volumeId));\n        const imageVolume = imageVolumes[imageVolumeIndex];\n        const { uid: actorUID } = volumeActors[imageVolumeIndex];\n        const spacingInNormalDirection = getSpacingInNormal(imageVolume, viewPlaneNormal, viewport, useSlabThickness);\n        return { imageVolume, spacingInNormalDirection, actorUID };\n    }\n    if (!imageVolumes.length) {\n        return {\n            spacingInNormalDirection: null,\n            imageVolume: null,\n            actorUID: null,\n        };\n    }\n    const smallest = {\n        spacingInNormalDirection: Infinity,\n        imageVolume: null,\n        actorUID: null,\n    };\n    const hasPrimaryVolume = imageVolumes.find(isPrimaryVolume);\n    for (let i = 0; i < imageVolumes.length; i++) {\n        const imageVolume = imageVolumes[i];\n        if (hasPrimaryVolume && !isPrimaryVolume(imageVolume)) {\n            continue;\n        }\n        const spacingInNormalDirection = getSpacingInNormal(imageVolume, viewPlaneNormal, viewport);\n        if (spacingInNormalDirection * EPSILON_PART <\n            smallest.spacingInNormalDirection) {\n            smallest.spacingInNormalDirection = spacingInNormalDirection;\n            smallest.imageVolume = imageVolume;\n            smallest.actorUID = volumeActors[i].uid;\n        }\n    }\n    return smallest;\n}\nfunction getSpacingInNormal(imageVolume, viewPlaneNormal, viewport, useSlabThickness = false) {\n    const { slabThickness } = viewport.getProperties();\n    let spacingInNormalDirection = slabThickness;\n    if (!slabThickness || !useSlabThickness) {\n        spacingInNormalDirection = getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n    }\n    return spacingInNormalDirection;\n}\n","import { getRenderingEngines } from '../RenderingEngine/getRenderingEngine';\nfunction getViewportsWithVolumeId(volumeId) {\n    const renderingEngines = getRenderingEngines();\n    const targetViewports = [];\n    renderingEngines.forEach((renderingEngine) => {\n        const viewports = renderingEngine.getVolumeViewports();\n        const filteredViewports = viewports.filter((vp) => vp.hasVolumeId(volumeId));\n        targetViewports.push(...filteredViewports);\n    });\n    return targetViewports;\n}\nexport default getViewportsWithVolumeId;\n","export default function getVoiFromSigmoidRGBTransferFunction(cfun) {\n    let cfunRange = [];\n    const [lower, upper] = cfun.getRange();\n    cfun.getTable(lower, upper, 1024, cfunRange);\n    cfunRange = cfunRange.filter((v, k) => k % 3 === 0);\n    const cfunDomain = [...Array(1024).keys()].map((v, k) => {\n        return lower + ((upper - lower) / (1024 - 1)) * k;\n    });\n    const y1 = cfunRange[256];\n    const logy1 = Math.log((1 - y1) / y1);\n    const x1 = cfunDomain[256];\n    const y2 = cfunRange[256 * 3];\n    const logy2 = Math.log((1 - y2) / y2);\n    const x2 = cfunDomain[256 * 3];\n    const ww = Math.round((4 * (x2 - x1)) / (logy1 - logy2));\n    const wc = Math.round(x1 + (ww * logy1) / 4);\n    return [Math.round(wc - ww / 2), Math.round(wc + ww / 2)];\n}\n","export default function getVolumeActorCorners(volumeActor) {\n    const imageData = volumeActor.getMapper().getInputData();\n    const bounds = imageData.extentToBounds(imageData.getExtent());\n    return [\n        [bounds[0], bounds[2], bounds[4]],\n        [bounds[0], bounds[2], bounds[5]],\n        [bounds[0], bounds[3], bounds[4]],\n        [bounds[0], bounds[3], bounds[5]],\n        [bounds[1], bounds[2], bounds[4]],\n        [bounds[1], bounds[2], bounds[5]],\n        [bounds[1], bounds[3], bounds[4]],\n        [bounds[1], bounds[3], bounds[5]],\n    ];\n}\n","export const getVolumeId = (targetId) => {\n    const prefix = 'volumeId:';\n    const str = targetId.includes(prefix)\n        ? targetId.substring(prefix.length)\n        : targetId;\n    const index = str.indexOf('sliceIndex=');\n    return index === -1 ? str : str.substring(0, index - 1);\n};\n","import getSliceRange from './getSliceRange';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\nfunction getVolumeSliceRangeInfo(viewport, volumeId, useSlabThickness = false) {\n    const camera = viewport.getCamera();\n    const { focalPoint, viewPlaneNormal } = camera;\n    const { spacingInNormalDirection, actorUID } = getTargetVolumeAndSpacingInNormalDir(viewport, camera, volumeId, useSlabThickness);\n    if (!actorUID) {\n        throw new Error(`Could not find image volume with id ${volumeId} in the viewport`);\n    }\n    const actorEntry = viewport.getActor(actorUID);\n    if (!actorEntry) {\n        console.warn('No actor found for with actorUID of', actorUID);\n        return null;\n    }\n    const volumeActor = actorEntry.actor;\n    const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);\n    return {\n        sliceRange,\n        spacingInNormalDirection,\n        camera,\n    };\n}\nexport default getVolumeSliceRangeInfo;\n","import getVolumeSliceRangeInfo from './getVolumeSliceRangeInfo';\nfunction getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness = false) {\n    const { sliceRange, spacingInNormalDirection, camera } = getVolumeSliceRangeInfo(viewport, volumeId, useSlabThickness);\n    const { min, max, current } = sliceRange;\n    const numScrollSteps = Math.round((max - min) / spacingInNormalDirection);\n    const fraction = (current - min) / (max - min);\n    const floatingStepNumber = fraction * numScrollSteps;\n    const currentStepIndex = Math.round(floatingStepNumber);\n    return {\n        numScrollSteps,\n        currentStepIndex,\n        sliceRangeInfo: {\n            sliceRange,\n            spacingInNormalDirection,\n            camera,\n        },\n    };\n}\nexport default getVolumeViewportScrollInfo;\n","export const hasFloatScalingParameters = (scalingParameters) => {\n    const hasFloatRescale = Object.values(scalingParameters).some((value) => typeof value === 'number' && !Number.isInteger(value));\n    return hasFloatRescale;\n};\n","export default function hasNaNValues(input) {\n    if (Array.isArray(input)) {\n        return input.some((value) => Number.isNaN(value));\n    }\n    return Number.isNaN(input);\n}\n","export default function imageIdToURI(imageId) {\n    const colonIndex = imageId.indexOf(':');\n    return imageId.substring(colonIndex + 1);\n}\n","import { addProvider } from '../metaData';\nconst retrieveConfigurationState = new Map();\nconst IMAGE_RETRIEVE_CONFIGURATION = 'imageRetrieveConfiguration';\nconst imageRetrieveMetadataProvider = {\n    IMAGE_RETRIEVE_CONFIGURATION,\n    clear: () => {\n        retrieveConfigurationState.clear();\n    },\n    add: (key, payload) => {\n        retrieveConfigurationState.set(key, payload);\n    },\n    clone: () => {\n        return new Map(retrieveConfigurationState);\n    },\n    restore: (state) => {\n        retrieveConfigurationState.clear();\n        state.forEach((value, key) => {\n            retrieveConfigurationState.set(key, value);\n        });\n    },\n    get: (type, ...queries) => {\n        if (type === IMAGE_RETRIEVE_CONFIGURATION) {\n            return queries\n                .map((query) => retrieveConfigurationState.get(query))\n                .find((it) => it !== undefined);\n        }\n    },\n};\naddProvider(imageRetrieveMetadataProvider.get.bind(imageRetrieveMetadataProvider));\nexport default imageRetrieveMetadataProvider;\n","var EventListenerPhases;\n(function (EventListenerPhases) {\n    EventListenerPhases[EventListenerPhases[\"None\"] = 0] = \"None\";\n    EventListenerPhases[EventListenerPhases[\"Capture\"] = 1] = \"Capture\";\n    EventListenerPhases[EventListenerPhases[\"Bubble\"] = 2] = \"Bubble\";\n})(EventListenerPhases || (EventListenerPhases = {}));\nclass TargetEventListeners {\n    constructor(target) {\n        this._eventListeners = new Map();\n        this._children = new Map();\n        this._target = target;\n    }\n    get isEmpty() {\n        return this._eventListeners.size === 0 && this._children.size === 0;\n    }\n    addEventListener(type, callback, options) {\n        const dotIndex = type.indexOf('.');\n        const isNamespace = dotIndex !== -1;\n        if (isNamespace) {\n            const namespaceToken = type.substring(0, dotIndex);\n            let childElementEventListener = this._children.get(namespaceToken);\n            if (!childElementEventListener) {\n                childElementEventListener = new TargetEventListeners(this._target);\n                this._children.set(namespaceToken, childElementEventListener);\n            }\n            type = type.substring(dotIndex + 1);\n            childElementEventListener.addEventListener(type, callback, options);\n        }\n        else {\n            this._addEventListener(type, callback, options);\n        }\n    }\n    removeEventListener(type, callback, options) {\n        const dotIndex = type.indexOf('.');\n        const isNamespace = dotIndex !== -1;\n        if (isNamespace) {\n            const namespaceToken = type.substring(0, dotIndex);\n            const childElementEventListener = this._children.get(namespaceToken);\n            if (!childElementEventListener) {\n                return;\n            }\n            type = type.substring(dotIndex + 1);\n            childElementEventListener.removeEventListener(type, callback, options);\n            if (childElementEventListener.isEmpty) {\n                this._children.delete(namespaceToken);\n            }\n        }\n        else {\n            this._removeEventListener(type, callback, options);\n        }\n    }\n    reset() {\n        Array.from(this._children.entries()).forEach(([namespace, child]) => {\n            child.reset();\n            if (child.isEmpty) {\n                this._children.delete(namespace);\n            }\n            else {\n                throw new Error('Child is not empty and cannot be removed');\n            }\n        });\n        this._unregisterAllEvents();\n    }\n    _addEventListener(type, callback, options) {\n        let listenersMap = this._eventListeners.get(type);\n        if (!listenersMap) {\n            listenersMap = new Map();\n            this._eventListeners.set(type, listenersMap);\n        }\n        const useCapture = options?.capture ?? false;\n        const listenerPhase = useCapture\n            ? EventListenerPhases.Capture\n            : EventListenerPhases.Bubble;\n        const registeredPhases = listenersMap.get(callback) ?? EventListenerPhases.None;\n        if (registeredPhases & listenerPhase) {\n            console.warn('A listener is already registered for this phase');\n            return;\n        }\n        listenersMap.set(callback, registeredPhases | listenerPhase);\n        this._target.addEventListener(type, callback, options);\n    }\n    _removeEventListener(type, callback, options) {\n        const useCapture = options?.capture ?? false;\n        const listenerPhase = useCapture\n            ? EventListenerPhases.Capture\n            : EventListenerPhases.Bubble;\n        const listenersMap = this._eventListeners.get(type);\n        if (!listenersMap) {\n            return;\n        }\n        const callbacks = callback ? [callback] : Array.from(listenersMap.keys());\n        callbacks.forEach((callbackItem) => {\n            const registeredPhases = listenersMap.get(callbackItem) ?? EventListenerPhases.None;\n            const phaseRegistered = !!(registeredPhases & listenerPhase);\n            if (!phaseRegistered) {\n                return;\n            }\n            this._target.removeEventListener(type, callbackItem, options);\n            const newListenerPhase = registeredPhases ^ listenerPhase;\n            if (newListenerPhase === EventListenerPhases.None) {\n                listenersMap.delete(callbackItem);\n            }\n            else {\n                listenersMap.set(callbackItem, newListenerPhase);\n            }\n        });\n        if (!listenersMap.size) {\n            this._eventListeners.delete(type);\n        }\n    }\n    _unregisterAllListeners(type, listenersMap) {\n        Array.from(listenersMap.entries()).forEach(([listener, eventPhases]) => {\n            const startPhase = EventListenerPhases.Capture;\n            for (let currentPhase = startPhase; eventPhases; currentPhase <<= 1) {\n                if (!(eventPhases & currentPhase)) {\n                    continue;\n                }\n                const useCapture = currentPhase === EventListenerPhases.Capture ? true : false;\n                this.removeEventListener(type, listener, { capture: useCapture });\n                eventPhases ^= currentPhase;\n            }\n        });\n    }\n    _unregisterAllEvents() {\n        Array.from(this._eventListeners.entries()).forEach(([type, listenersMap]) => {\n            this._unregisterAllListeners(type, listenersMap);\n        });\n    }\n}\nexport { TargetEventListeners as default, TargetEventListeners };\n","import TargetEventListeners from './TargetEventListeners';\nclass MultiTargetEventListenerManager {\n    constructor() {\n        this._targetsEventListeners = new Map();\n    }\n    addEventListener(target, type, callback, options) {\n        let eventListeners = this._targetsEventListeners.get(target);\n        if (!eventListeners) {\n            eventListeners = new TargetEventListeners(target);\n            this._targetsEventListeners.set(target, eventListeners);\n        }\n        eventListeners.addEventListener(type, callback, options);\n    }\n    removeEventListener(target, type, callback, options) {\n        const eventListeners = this._targetsEventListeners.get(target);\n        if (!eventListeners) {\n            return;\n        }\n        eventListeners.removeEventListener(type, callback, options);\n        if (eventListeners.isEmpty) {\n            this._targetsEventListeners.delete(target);\n        }\n    }\n    reset() {\n        Array.from(this._targetsEventListeners.entries()).forEach(([target, targetEventListeners]) => {\n            targetEventListeners.reset();\n            this._targetsEventListeners.delete(target);\n        });\n    }\n}\nexport { MultiTargetEventListenerManager as default, MultiTargetEventListenerManager, };\n","export default function scaleRGBTransferFunction(rgbTransferFunction, scalingFactor) {\n    const size = rgbTransferFunction.getSize();\n    for (let index = 0; index < size; index++) {\n        const nodeValue1 = [];\n        rgbTransferFunction.getNodeValue(index, nodeValue1);\n        nodeValue1[1] = nodeValue1[1] * scalingFactor;\n        nodeValue1[2] = nodeValue1[2] * scalingFactor;\n        nodeValue1[3] = nodeValue1[3] * scalingFactor;\n        rgbTransferFunction.setNodeValue(index, nodeValue1);\n    }\n}\n","const LAST_RUNTIME_ID = Symbol('LastRuntimeId');\nconst GLOBAL_CONTEXT = {};\nconst DEFAULT_MAX = 0xffffffff;\nconst DEFAULT_SEPARATOR = '-';\nexport default function getRuntimeId(context, separator, max) {\n    return getNextRuntimeId(context !== null && typeof context === 'object' ? context : GLOBAL_CONTEXT, LAST_RUNTIME_ID, (typeof max === 'number' && max > 0 ? max : DEFAULT_MAX) >>> 0).join(typeof separator === 'string' ? separator : DEFAULT_SEPARATOR);\n}\nfunction getNextRuntimeId(context, symbol, max) {\n    let idComponents = context[symbol];\n    if (!(idComponents instanceof Array)) {\n        idComponents = [0];\n        Object.defineProperty(context, symbol, { value: idComponents });\n    }\n    for (let carry = true, i = 0; carry && i < idComponents.length; ++i) {\n        let n = idComponents[i] | 0;\n        if (n < max) {\n            carry = false;\n            n = n + 1;\n        }\n        else {\n            n = 0;\n            if (i + 1 === idComponents.length) {\n                idComponents.push(0);\n            }\n        }\n        idComponents[i] = n;\n    }\n    return idComponents;\n}\n","import imageIdToURI from './imageIdToURI';\nconst state = {};\nconst metadataProvider = {\n    add: (imageId, payload) => {\n        const imageURI = imageIdToURI(imageId);\n        state[imageURI] = payload;\n    },\n    get: (type, imageId) => {\n        if (type === 'calibratedPixelSpacing') {\n            const imageURI = imageIdToURI(imageId);\n            return state[imageURI];\n        }\n    },\n};\nexport default metadataProvider;\n","export default function isOpposite(v1, v2, tolerance = 1e-5) {\n    return (Math.abs(v1[0] + v2[0]) < tolerance &&\n        Math.abs(v1[1] + v2[1]) < tolerance &&\n        Math.abs(v1[2] + v2[2]) < tolerance);\n}\n","export default function indexWithinDimensions(index, dimensions) {\n    if (index[0] < 0 ||\n        index[0] >= dimensions[0] ||\n        index[1] < 0 ||\n        index[1] >= dimensions[1] ||\n        index[2] < 0 ||\n        index[2] >= dimensions[2]) {\n        return false;\n    }\n    return true;\n}\n","import { getRenderingEngines, getRenderingEngine, } from '../RenderingEngine/getRenderingEngine';\nfunction getVolumeViewportsContainingSameVolumes(targetViewport, renderingEngineId) {\n    let renderingEngines;\n    if (renderingEngineId) {\n        renderingEngines = [getRenderingEngine(renderingEngineId)];\n    }\n    else {\n        renderingEngines = getRenderingEngines();\n    }\n    const sameVolumesViewports = [];\n    renderingEngines.forEach((renderingEngine) => {\n        const targetActors = targetViewport.getActors();\n        const viewports = renderingEngine.getVolumeViewports();\n        for (const vp of viewports) {\n            const vpActors = vp.getActors();\n            if (vpActors.length !== targetActors.length) {\n                continue;\n            }\n            const sameVolumes = targetActors.every(({ uid }) => vpActors.find((vpActor) => uid === vpActor.uid));\n            if (sameVolumes) {\n                sameVolumesViewports.push(vp);\n            }\n        }\n    });\n    return sameVolumesViewports;\n}\nexport default getVolumeViewportsContainingSameVolumes;\n","const isPTPrescaledWithSUV = (image) => {\n    return image.preScale.scaled && image.preScale.scalingParameters.suvbw;\n};\nexport default isPTPrescaledWithSUV;\n","import getOrCreateCanvas, { EPSILON, } from '../RenderingEngine/helpers/getOrCreateCanvas';\nimport { ViewportType, Events } from '../enums';\nimport { getRenderingEngine } from '../RenderingEngine/getRenderingEngine';\nimport RenderingEngine from '../RenderingEngine';\nimport isPTPrescaledWithSUV from './isPTPrescaledWithSUV';\nexport default function renderToCanvasGPU(canvas, imageOrVolume, modality = undefined, renderingEngineId = '_thumbnails', viewportOptions = {\n    displayArea: { imageArea: [1, 1] },\n}) {\n    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n        throw new Error('canvas element is required');\n    }\n    const isVolume = !imageOrVolume.imageId;\n    const image = !isVolume && imageOrVolume;\n    const volume = isVolume && imageOrVolume;\n    const imageIdToPrint = image.imageId || volume.volumeId;\n    const viewportId = `renderGPUViewport-${imageIdToPrint}`;\n    const element = document.createElement('div');\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    if (!viewportOptions.displayArea) {\n        viewportOptions.displayArea = { imageArea: [1, 1] };\n    }\n    const originalWidth = canvas.width;\n    const originalHeight = canvas.height;\n    element.style.width = `${originalWidth / devicePixelRatio + EPSILON}px`;\n    element.style.height = `${originalHeight / devicePixelRatio + EPSILON}px`;\n    element.style.visibility = 'hidden';\n    element.style.position = 'absolute';\n    document.body.appendChild(element);\n    const uniqueId = viewportId.split(':').join('-');\n    element.setAttribute('viewport-id-for-remove', uniqueId);\n    const temporaryCanvas = getOrCreateCanvas(element);\n    const renderingEngine = getRenderingEngine(renderingEngineId) ||\n        new RenderingEngine(renderingEngineId);\n    let viewport = renderingEngine.getViewport(viewportId);\n    if (!viewport) {\n        const viewportInput = {\n            viewportId,\n            type: isVolume ? ViewportType.ORTHOGRAPHIC : ViewportType.STACK,\n            element,\n            defaultOptions: {\n                ...viewportOptions,\n                suppressEvents: true,\n            },\n        };\n        renderingEngine.enableElement(viewportInput);\n        viewport = renderingEngine.getViewport(viewportId);\n    }\n    return new Promise((resolve) => {\n        let elementRendered = false;\n        let { viewReference } = viewportOptions;\n        const onImageRendered = (eventDetail) => {\n            if (elementRendered) {\n                return;\n            }\n            if (viewReference) {\n                const useViewRef = viewReference;\n                viewReference = null;\n                viewport.setViewReference(useViewRef);\n                viewport.render();\n                return;\n            }\n            const context = canvas.getContext('2d');\n            context.drawImage(temporaryCanvas, 0, 0, temporaryCanvas.width, temporaryCanvas.height, 0, 0, canvas.width, canvas.height);\n            const origin = viewport.canvasToWorld([0, 0]);\n            const topRight = viewport.canvasToWorld([\n                temporaryCanvas.width / devicePixelRatio,\n                0,\n            ]);\n            const bottomLeft = viewport.canvasToWorld([\n                0,\n                temporaryCanvas.height / devicePixelRatio,\n            ]);\n            const thicknessMm = 1;\n            elementRendered = true;\n            element.removeEventListener(Events.IMAGE_RENDERED, onImageRendered);\n            setTimeout(() => {\n                renderingEngine.disableElement(viewportId);\n                const elements = document.querySelectorAll(`[viewport-id-for-remove=\"${uniqueId}\"]`);\n                elements.forEach((element) => {\n                    element.remove();\n                });\n            }, 0);\n            resolve({\n                origin,\n                bottomLeft,\n                topRight,\n                thicknessMm,\n            });\n        };\n        element.addEventListener(Events.IMAGE_RENDERED, onImageRendered);\n        if (isVolume) {\n            viewport.setVolumes([volume], false, true);\n        }\n        else {\n            viewport.renderImageObject(imageOrVolume);\n        }\n        viewport.resetCamera();\n        if (modality === 'PT' && !isPTPrescaledWithSUV(image)) {\n            viewport.setProperties({\n                voiRange: {\n                    lower: image.minPixelValue,\n                    upper: image.maxPixelValue,\n                },\n            });\n        }\n        viewport.render();\n    });\n}\n","import getDefaultViewport from '../RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport';\nimport calculateTransform from '../RenderingEngine/helpers/cpuFallback/rendering/calculateTransform';\nimport drawImageSync from '../RenderingEngine/helpers/cpuFallback/drawImageSync';\nexport default function renderToCanvasCPU(canvas, imageOrVolume, modality, _renderingEngineId, _viewportOptions) {\n    const volume = imageOrVolume;\n    if (volume.volumeId) {\n        throw new Error('Unsupported volume rendering for CPU');\n    }\n    const image = imageOrVolume;\n    const viewport = getDefaultViewport(canvas, image, modality);\n    const enabledElement = {\n        canvas,\n        viewport,\n        image,\n        renderingTools: {},\n    };\n    enabledElement.transform = calculateTransform(enabledElement);\n    const invalidated = true;\n    return new Promise((resolve, reject) => {\n        drawImageSync(enabledElement, invalidated);\n        resolve(null);\n    });\n}\n","import { loadAndCacheImage } from '../loaders/imageLoader';\nimport * as metaData from '../metaData';\nimport { RequestType } from '../enums';\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\nimport renderToCanvasGPU from './renderToCanvasGPU';\nimport renderToCanvasCPU from './renderToCanvasCPU';\nimport { getConfiguration } from '../init';\nimport cache from '../cache/cache';\nexport default function loadImageToCanvas(options) {\n    const { canvas, imageId, viewReference, requestType = RequestType.Thumbnail, priority = -5, renderingEngineId = '_thumbnails', useCPURendering = false, thumbnail = false, imageAspect = false, viewportOptions: baseViewportOptions, } = options;\n    const volumeId = viewReference?.volumeId;\n    const isVolume = volumeId && !imageId;\n    const viewportOptions = viewReference && baseViewportOptions\n        ? { ...baseViewportOptions, viewReference }\n        : baseViewportOptions;\n    const renderFn = useCPURendering ? renderToCanvasCPU : renderToCanvasGPU;\n    return new Promise((resolve, reject) => {\n        function successCallback(imageOrVolume, imageId) {\n            const { modality } = metaData.get('generalSeriesModule', imageId) || {};\n            const image = !isVolume && imageOrVolume;\n            const volume = isVolume && imageOrVolume;\n            if (image) {\n                image.isPreScaled = image.isPreScaled || image.preScale?.scaled;\n            }\n            if (thumbnail) {\n                canvas.height = 256;\n                canvas.width = 256;\n            }\n            if (imageAspect && image) {\n                canvas.width = image && (canvas.height * image.width) / image.height;\n            }\n            canvas.style.width = `${canvas.width / devicePixelRatio}px`;\n            canvas.style.height = `${canvas.height / devicePixelRatio}px`;\n            if (volume && useCPURendering) {\n                reject(new Error('CPU rendering of volume not supported'));\n            }\n            renderFn(canvas, imageOrVolume, modality, renderingEngineId, viewportOptions).then(resolve);\n        }\n        function errorCallback(error, imageId) {\n            console.error(error, imageId);\n            reject(error);\n        }\n        function sendRequest(imageId, imageIdIndex, options) {\n            return loadAndCacheImage(imageId, options).then((image) => {\n                successCallback.call(this, image, imageId);\n            }, (error) => {\n                errorCallback.call(this, error, imageId);\n            });\n        }\n        const options = {\n            useRGBA: !!useCPURendering,\n            requestType,\n        };\n        if (volumeId) {\n            const volume = cache.getVolume(volumeId);\n            if (!volume) {\n                reject(new Error(`Volume id ${volumeId} not found in cache`));\n            }\n            const useImageId = volume.imageIds[0];\n            successCallback(volume, useImageId);\n        }\n        else {\n            imageLoadPoolManager.addRequest(sendRequest.bind(null, imageId, null, options), requestType, { imageId }, priority);\n        }\n    });\n}\n","import { vec3 } from 'gl-matrix';\nimport { get } from '../metaData';\nfunction worldToImageCoords(imageId, worldCoords) {\n    const imagePlaneModule = get('imagePlaneModule', imageId);\n    if (!imagePlaneModule) {\n        throw new Error(`No imagePlaneModule found for imageId: ${imageId}`);\n    }\n    const { columnCosines, rowCosines, imagePositionPatient: origin, } = imagePlaneModule;\n    let { columnPixelSpacing, rowPixelSpacing } = imagePlaneModule;\n    columnPixelSpacing ||= 1;\n    rowPixelSpacing ||= 1;\n    const newOrigin = vec3.create();\n    vec3.scaleAndAdd(newOrigin, origin, columnCosines, -columnPixelSpacing / 2);\n    vec3.scaleAndAdd(newOrigin, newOrigin, rowCosines, -rowPixelSpacing / 2);\n    const sub = vec3.create();\n    vec3.sub(sub, worldCoords, newOrigin);\n    const rowDistance = vec3.dot(sub, rowCosines);\n    const columnDistance = vec3.dot(sub, columnCosines);\n    const imageCoords = [\n        rowDistance / rowPixelSpacing,\n        columnDistance / columnPixelSpacing,\n    ];\n    return imageCoords;\n}\nexport default worldToImageCoords;\n","import { vec3 } from 'gl-matrix';\nimport { get } from '../metaData';\nexport default function imageToWorldCoords(imageId, imageCoords) {\n    const imagePlaneModule = get('imagePlaneModule', imageId);\n    if (!imagePlaneModule) {\n        throw new Error(`No imagePlaneModule found for imageId: ${imageId}`);\n    }\n    const { columnCosines, rowCosines, imagePositionPatient: origin, } = imagePlaneModule;\n    let { columnPixelSpacing, rowPixelSpacing } = imagePlaneModule;\n    columnPixelSpacing ||= 1;\n    rowPixelSpacing ||= 1;\n    const imageCoordsInWorld = vec3.create();\n    vec3.scaleAndAdd(imageCoordsInWorld, origin, rowCosines, rowPixelSpacing * (imageCoords[0] - 0.5));\n    vec3.scaleAndAdd(imageCoordsInWorld, imageCoordsInWorld, columnCosines, columnPixelSpacing * (imageCoords[1] - 0.5));\n    return Array.from(imageCoordsInWorld);\n}\n","import { getRenderingEngines } from '../RenderingEngine/getRenderingEngine';\nexport default function getViewportsWithImageURI(imageURI) {\n    const renderingEngines = getRenderingEngines();\n    const viewports = [];\n    renderingEngines.forEach((renderingEngine) => {\n        const viewportsForRenderingEngine = renderingEngine.getViewports();\n        viewportsForRenderingEngine.forEach((viewport) => {\n            if (viewport.hasImageURI(imageURI)) {\n                viewports.push(viewport);\n            }\n        });\n    });\n    return viewports;\n}\n","import { vec3 } from 'gl-matrix';\nimport * as planar from './planar';\nimport * as metaData from '../metaData';\nexport default function getClosestStackImageIndexForPoint(point, viewport) {\n    const minimalDistance = calculateMinimalDistanceForStackViewport(point, viewport);\n    return minimalDistance ? minimalDistance.index : null;\n}\nexport function calculateMinimalDistanceForStackViewport(point, viewport) {\n    const imageIds = viewport.getImageIds();\n    const currentImageIdIndex = viewport.getCurrentImageIdIndex();\n    if (imageIds.length === 0) {\n        return null;\n    }\n    const getDistance = (imageId) => {\n        const planeMetadata = getPlaneMetadata(imageId);\n        if (!planeMetadata) {\n            return null;\n        }\n        const plane = planar.planeEquation(planeMetadata.planeNormal, planeMetadata.imagePositionPatient);\n        const distance = planar.planeDistanceToPoint(plane, point);\n        return distance;\n    };\n    const closestStack = {\n        distance: getDistance(imageIds[currentImageIdIndex]) ?? Infinity,\n        index: currentImageIdIndex,\n    };\n    const higherImageIds = imageIds.slice(currentImageIdIndex + 1);\n    for (let i = 0; i < higherImageIds.length; i++) {\n        const id = higherImageIds[i];\n        const distance = getDistance(id);\n        if (distance === null) {\n            continue;\n        }\n        if (distance <= closestStack.distance) {\n            closestStack.distance = distance;\n            closestStack.index = i + currentImageIdIndex + 1;\n        }\n        else {\n            break;\n        }\n    }\n    const lowerImageIds = imageIds.slice(0, currentImageIdIndex);\n    for (let i = lowerImageIds.length - 1; i >= 0; i--) {\n        const id = lowerImageIds[i];\n        const distance = getDistance(id);\n        if (distance === null || distance === closestStack.distance) {\n            continue;\n        }\n        if (distance < closestStack.distance) {\n            closestStack.distance = distance;\n            closestStack.index = i;\n        }\n        else {\n            break;\n        }\n    }\n    return closestStack.distance === Infinity ? null : closestStack;\n}\nfunction getPlaneMetadata(imageId) {\n    const targetImagePlane = metaData.get('imagePlaneModule', imageId);\n    if (!targetImagePlane ||\n        !(targetImagePlane.rowCosines instanceof Array &&\n            targetImagePlane.rowCosines.length === 3) ||\n        !(targetImagePlane.columnCosines instanceof Array &&\n            targetImagePlane.columnCosines.length === 3) ||\n        !(targetImagePlane.imagePositionPatient instanceof Array &&\n            targetImagePlane.imagePositionPatient.length === 3)) {\n        return null;\n    }\n    const { rowCosines, columnCosines, imagePositionPatient, } = targetImagePlane;\n    const rowVec = vec3.set(vec3.create(), ...rowCosines);\n    const colVec = vec3.set(vec3.create(), ...columnCosines);\n    const planeNormal = vec3.cross(vec3.create(), rowVec, colVec);\n    return { rowCosines, columnCosines, imagePositionPatient, planeNormal };\n}\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { transformCanvasToIJK } from './transformCanvasToIJK';\nfunction getCurrentVolumeViewportSlice(viewport) {\n    const { width: canvasWidth, height: canvasHeight } = viewport.getCanvas();\n    const { sliceToIndexMatrix, indexToSliceMatrix } = viewport.getSliceViewInfo();\n    const ijkOriginPoint = transformCanvasToIJK(viewport, [0, 0]);\n    const ijkRowPoint = transformCanvasToIJK(viewport, [canvasWidth - 1, 0]);\n    const ijkColPoint = transformCanvasToIJK(viewport, [0, canvasHeight - 1]);\n    const ijkRowVec = vec3.sub(vec3.create(), ijkRowPoint, ijkOriginPoint);\n    const ijkColVec = vec3.sub(vec3.create(), ijkColPoint, ijkOriginPoint);\n    const ijkSliceVec = vec3.cross(vec3.create(), ijkRowVec, ijkColVec);\n    vec3.normalize(ijkRowVec, ijkRowVec);\n    vec3.normalize(ijkColVec, ijkColVec);\n    vec3.normalize(ijkSliceVec, ijkSliceVec);\n    const maxIJKRowVec = Math.max(Math.abs(ijkRowVec[0]), Math.abs(ijkRowVec[1]), Math.abs(ijkRowVec[2]));\n    const maxIJKColVec = Math.max(Math.abs(ijkColVec[0]), Math.abs(ijkColVec[1]), Math.abs(ijkColVec[2]));\n    if (!glMatrix.equals(1, maxIJKRowVec) || !glMatrix.equals(1, maxIJKColVec)) {\n        throw new Error('Livewire is not available for rotate/oblique viewports');\n    }\n    const { voxelManager } = viewport.getImageData();\n    const sliceViewInfo = viewport.getSliceViewInfo();\n    const scalarData = voxelManager.getSliceData(sliceViewInfo);\n    return {\n        width: sliceViewInfo.width,\n        height: sliceViewInfo.height,\n        scalarData,\n        sliceToIndexMatrix,\n        indexToSliceMatrix,\n    };\n}\nexport { getCurrentVolumeViewportSlice as default, getCurrentVolumeViewportSlice, };\n","import { mat4 } from 'gl-matrix';\nimport { addProvider } from '../metaData';\nconst state = {};\nconst spatialRegistrationMetadataProvider = {\n    add: (query, payload) => {\n        const [viewportId1, viewportId2] = query;\n        const entryId = `${viewportId1}_${viewportId2}`;\n        if (!state[entryId]) {\n            state[entryId] = {};\n        }\n        state[entryId] = payload;\n    },\n    get: (type, viewportId1, viewportId2) => {\n        if (type !== 'spatialRegistrationModule') {\n            return;\n        }\n        const entryId = `${viewportId1}_${viewportId2}`;\n        if (state[entryId]) {\n            return state[entryId];\n        }\n        const entryIdReverse = `${viewportId2}_${viewportId1}`;\n        if (state[entryIdReverse]) {\n            return mat4.invert(mat4.create(), state[entryIdReverse]);\n        }\n    },\n};\naddProvider(spatialRegistrationMetadataProvider.get.bind(spatialRegistrationMetadataProvider));\nexport default spatialRegistrationMetadataProvider;\n","import { vec3, mat4 } from 'gl-matrix';\nimport spatialRegistrationMetadataProvider from './spatialRegistrationMetadataProvider';\nimport { get } from '../metaData';\nconst ALLOWED_DELTA = 0.05;\nfunction calculateViewportsSpatialRegistration(viewport1, viewport2) {\n    const imageId1 = viewport1.getSliceIndex();\n    const imageId2 = viewport2.getSliceIndex();\n    const imagePlaneModule1 = get('imagePlaneModule', imageId1.toString());\n    const imagePlaneModule2 = get('imagePlaneModule', imageId2.toString());\n    if (!imagePlaneModule1 || !imagePlaneModule2) {\n        console.log('Viewport spatial registration requires image plane module');\n        return;\n    }\n    const { imageOrientationPatient: iop2 } = imagePlaneModule2;\n    const isSameImagePlane = imagePlaneModule1.imageOrientationPatient.every((v, i) => Math.abs(v - iop2[i]) < ALLOWED_DELTA);\n    if (!isSameImagePlane) {\n        console.log('Viewport spatial registration only supported for same orientation (hence translation only) for now', imagePlaneModule1?.imageOrientationPatient, imagePlaneModule2?.imageOrientationPatient);\n        return;\n    }\n    const imagePositionPatient1 = imagePlaneModule1.imagePositionPatient;\n    const imagePositionPatient2 = imagePlaneModule2.imagePositionPatient;\n    const translation = vec3.subtract(vec3.create(), imagePositionPatient1, imagePositionPatient2);\n    const mat = mat4.fromTranslation(mat4.create(), translation);\n    spatialRegistrationMetadataProvider.add([viewport1.id, viewport2.id], mat);\n}\nexport default calculateViewportsSpatialRegistration;\n","export default function getViewportImageCornersInWorld(viewport) {\n    const { imageData, dimensions } = viewport.getImageData() || {};\n    if (!imageData || !dimensions) {\n        return [];\n    }\n    const { canvas } = viewport;\n    const ratio = window.devicePixelRatio;\n    const topLeftCanvas = [0, 0];\n    const topRightCanvas = [canvas.width / ratio, 0];\n    const bottomRightCanvas = [\n        canvas.width / ratio,\n        canvas.height / ratio,\n    ];\n    const bottomLeftCanvas = [0, canvas.height / ratio];\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const topRightWorld = viewport.canvasToWorld(topRightCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const bottomLeftWorld = viewport.canvasToWorld(bottomLeftCanvas);\n    const topLeftImage = imageData.worldToIndex(topLeftWorld);\n    const topRightImage = imageData.worldToIndex(topRightWorld);\n    const bottomRightImage = imageData.worldToIndex(bottomRightWorld);\n    const bottomLeftImage = imageData.worldToIndex(bottomLeftWorld);\n    return _getStackViewportImageCorners({\n        dimensions,\n        imageData,\n        topLeftImage,\n        topRightImage,\n        bottomRightImage,\n        bottomLeftImage,\n        topLeftWorld,\n        topRightWorld,\n        bottomRightWorld,\n        bottomLeftWorld,\n    });\n}\nfunction _getStackViewportImageCorners({ dimensions, imageData, topLeftImage, topRightImage, bottomRightImage, bottomLeftImage, topLeftWorld, topRightWorld, bottomRightWorld, bottomLeftWorld, }) {\n    const topLeftImageWorld = _isInBounds(topLeftImage, dimensions)\n        ? topLeftWorld\n        : imageData.indexToWorld([0, 0, 0]);\n    const topRightImageWorld = _isInBounds(topRightImage, dimensions)\n        ? topRightWorld\n        : imageData.indexToWorld([dimensions[0] - 1, 0, 0]);\n    const bottomRightImageWorld = _isInBounds(bottomRightImage, dimensions)\n        ? bottomRightWorld\n        : imageData.indexToWorld([\n            dimensions[0] - 1,\n            dimensions[1] - 1,\n            0,\n        ]);\n    const bottomLeftImageWorld = _isInBounds(bottomLeftImage, dimensions)\n        ? bottomLeftWorld\n        : imageData.indexToWorld([0, dimensions[1] - 1, 0]);\n    return [\n        topLeftImageWorld,\n        topRightImageWorld,\n        bottomLeftImageWorld,\n        bottomRightImageWorld,\n    ];\n}\nfunction _isInBounds(imageCoord, dimensions) {\n    return (imageCoord[0] > 0 ||\n        imageCoord[0] < dimensions[0] - 1 ||\n        imageCoord[1] > 0 ||\n        imageCoord[1] < dimensions[1] - 1 ||\n        imageCoord[2] > 0 ||\n        imageCoord[2] < dimensions[2] - 1);\n}\n","export default class PointsManager {\n    constructor(configuration = {}) {\n        this._dimensions = 3;\n        this._length = 0;\n        this._byteSize = 4;\n        this.growSize = 128;\n        const { initialSize = 1024, dimensions = 3, growSize = 128, } = configuration;\n        const itemLength = initialSize * dimensions;\n        this.growSize = growSize;\n        this.array = new ArrayBuffer(itemLength * this._byteSize);\n        this.data = new Float32Array(this.array);\n        this._dimensions = dimensions;\n    }\n    forEach(func) {\n        for (let i = 0; i < this._length; i++) {\n            func(this.getPoint(i), i);\n        }\n    }\n    get length() {\n        return this._length;\n    }\n    get dimensions() {\n        return this._dimensions;\n    }\n    get dimensionLength() {\n        return this._length * this._dimensions;\n    }\n    getPoint(index) {\n        if (index < 0) {\n            index += this._length;\n        }\n        if (index < 0 || index >= this._length) {\n            return;\n        }\n        const offset = this._dimensions * index;\n        return this.data.subarray(offset, offset + this._dimensions);\n    }\n    getPointArray(index) {\n        const array = [];\n        if (index < 0) {\n            index += this._length;\n        }\n        if (index < 0 || index >= this._length) {\n            return;\n        }\n        const offset = this._dimensions * index;\n        for (let i = 0; i < this._dimensions; i++) {\n            array.push(this.data[i + offset]);\n        }\n        return array;\n    }\n    grow(additionalSize = 1, growSize = this.growSize) {\n        if (this.dimensionLength + additionalSize * this._dimensions <=\n            this.data.length) {\n            return;\n        }\n        const newSize = this.data.length + growSize;\n        const newArray = new ArrayBuffer(newSize * this._dimensions * this._byteSize);\n        const newData = new Float32Array(newArray);\n        newData.set(this.data);\n        this.data = newData;\n        this.array = newArray;\n    }\n    reverse() {\n        const midLength = Math.floor(this._length / 2);\n        for (let i = 0; i < midLength; i++) {\n            const indexStart = i * this._dimensions;\n            const indexEnd = (this._length - 1 - i) * this._dimensions;\n            for (let dimension = 0; dimension < this._dimensions; dimension++) {\n                const valueStart = this.data[indexStart + dimension];\n                this.data[indexStart + dimension] = this.data[indexEnd + dimension];\n                this.data[indexEnd + dimension] = valueStart;\n            }\n        }\n    }\n    push(point) {\n        this.grow(1);\n        const offset = this.length * this._dimensions;\n        for (let i = 0; i < this._dimensions; i++) {\n            this.data[i + offset] = point[i];\n        }\n        this._length++;\n    }\n    map(f) {\n        const mapData = [];\n        for (let i = 0; i < this._length; i++) {\n            mapData.push(f(this.getPoint(i), i));\n        }\n        return mapData;\n    }\n    get points() {\n        return this.map((p) => p);\n    }\n    toXYZ() {\n        const xyz = { x: [], y: [] };\n        if (this._dimensions >= 3) {\n            xyz.z = [];\n        }\n        const { x, y, z } = xyz;\n        this.forEach((p) => {\n            x.push(p[0]);\n            y.push(p[1]);\n            if (z) {\n                z.push(p[2]);\n            }\n        });\n        return xyz;\n    }\n    static fromXYZ({ x, y, z }) {\n        const array = PointsManager.create3(x.length);\n        let offset = 0;\n        for (let i = 0; i < x.length; i++) {\n            array.data[offset++] = x[i];\n            array.data[offset++] = y[i];\n            array.data[offset++] = z ? z[i] : 0;\n        }\n        array._length = x.length;\n        return array;\n    }\n    subselect(count = 10, offset = 0) {\n        const selected = new PointsManager({\n            initialSize: count,\n            dimensions: this._dimensions,\n        });\n        for (let i = 0; i < count; i++) {\n            const index = (offset + Math.floor((this.length * i) / count)) % this.length;\n            selected.push(this.getPoint(index));\n        }\n        return selected;\n    }\n    static create3(initialSize = 128) {\n        return new PointsManager({ initialSize, dimensions: 3 });\n    }\n    static create2(initialSize = 128) {\n        return new PointsManager({ initialSize, dimensions: 2 });\n    }\n}\n","import StackViewport from '../RenderingEngine/StackViewport';\nimport getEnabledElement from '../getEnabledElement';\nfunction getImageLegacy(element) {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    if (!(viewport instanceof StackViewport)) {\n        throw new Error(`An image can only be fetched for a stack viewport and not for a viewport of type: ${viewport.type}`);\n    }\n    return viewport.getCornerstoneImage();\n}\nexport default getImageLegacy;\n","import * as metaData from '../metaData';\nimport isEqual from './isEqual';\nfunction isValidVolume(imageIds) {\n    const imageId0 = imageIds[0];\n    const { modality, seriesInstanceUID } = metaData.get('generalSeriesModule', imageId0);\n    const { imageOrientationPatient, pixelSpacing, frameOfReferenceUID, columns, rows, } = metaData.get('imagePlaneModule', imageId0);\n    const baseMetadata = {\n        modality,\n        imageOrientationPatient,\n        pixelSpacing,\n        frameOfReferenceUID,\n        columns,\n        rows,\n        seriesInstanceUID,\n    };\n    const validVolume = imageIds.every((imageId) => {\n        const { modality, seriesInstanceUID } = metaData.get('generalSeriesModule', imageId);\n        const { imageOrientationPatient, pixelSpacing, columns, rows } = metaData.get('imagePlaneModule', imageId);\n        return (seriesInstanceUID === baseMetadata.seriesInstanceUID &&\n            modality === baseMetadata.modality &&\n            columns === baseMetadata.columns &&\n            rows === baseMetadata.rows &&\n            isEqual(imageOrientationPatient, baseMetadata.imageOrientationPatient) &&\n            isEqual(pixelSpacing, baseMetadata.pixelSpacing));\n    });\n    return validVolume;\n}\nexport { isValidVolume };\n","export const videoUIDs = new Set([\n    '1.2.840.10008.1.2.4.100',\n    '1.2.840.10008.1.2.4.100.1',\n    '1.2.840.10008.1.2.4.101',\n    '1.2.840.10008.1.2.4.101.1',\n    '1.2.840.10008.1.2.4.102',\n    '1.2.840.10008.1.2.4.102.1',\n    '1.2.840.10008.1.2.4.103',\n    '1.2.840.10008.1.2.4.103.1',\n    '1.2.840.10008.1.2.4.104',\n    '1.2.840.10008.1.2.4.104.1',\n    '1.2.840.10008.1.2.4.105',\n    '1.2.840.10008.1.2.4.105.1',\n    '1.2.840.10008.1.2.4.106',\n    '1.2.840.10008.1.2.4.106.1',\n    '1.2.840.10008.1.2.4.107',\n    '1.2.840.10008.1.2.4.108',\n]);\nexport default function isVideoTransferSyntax(uidOrUids) {\n    if (!uidOrUids) {\n        return false;\n    }\n    const uids = Array.isArray(uidOrUids) ? uidOrUids : [uidOrUids];\n    return uids.find((uid) => videoUIDs.has(uid));\n}\n","import { setVolumesForViewports } from '../RenderingEngine/helpers';\nimport { createAndCacheVolume, getUnknownVolumeLoaderSchema, } from '../loaders/volumeLoader';\nimport { Events, ViewportType } from '../enums';\nimport uuidv4 from './uuidv4';\nasync function convertStackToVolumeViewport({ viewport, options = {}, }) {\n    const renderingEngine = viewport.getRenderingEngine();\n    let volumeId = options.volumeId || `${uuidv4()}`;\n    if (volumeId.split(':').length === 0) {\n        const schema = getUnknownVolumeLoaderSchema();\n        volumeId = `${schema}:${volumeId}`;\n    }\n    const { id, element } = viewport;\n    const viewportId = options.viewportId || id;\n    const imageIds = viewport.getImageIds();\n    const prevViewPresentation = viewport.getViewPresentation();\n    const prevViewReference = viewport.getViewReference();\n    renderingEngine.enableElement({\n        viewportId,\n        type: ViewportType.ORTHOGRAPHIC,\n        element,\n        defaultOptions: {\n            background: options.background,\n            orientation: options.orientation,\n        },\n    });\n    const volume = (await createAndCacheVolume(volumeId, {\n        imageIds,\n    }));\n    volume.load();\n    const volumeViewport = renderingEngine.getViewport(viewportId);\n    await setVolumesForViewports(renderingEngine, [\n        {\n            volumeId,\n        },\n    ], [viewportId]);\n    const volumeViewportNewVolumeHandler = () => {\n        volumeViewport.render();\n        element.removeEventListener(Events.VOLUME_VIEWPORT_NEW_VOLUME, volumeViewportNewVolumeHandler);\n    };\n    const addVolumeViewportNewVolumeListener = () => {\n        element.addEventListener(Events.VOLUME_VIEWPORT_NEW_VOLUME, volumeViewportNewVolumeHandler);\n    };\n    addVolumeViewportNewVolumeListener();\n    volumeViewport.setViewPresentation(prevViewPresentation);\n    volumeViewport.setViewReference(prevViewReference);\n    volumeViewport.render();\n    return volumeViewport;\n}\nexport { convertStackToVolumeViewport };\n","import cache from '../cache/cache';\nimport { ImageVolume } from '../cache/classes/ImageVolume';\nimport { ViewportType } from '../enums';\nasync function convertVolumeToStackViewport({ viewport, options, }) {\n    const volumeViewport = viewport;\n    const { id, element } = volumeViewport;\n    const renderingEngine = viewport.getRenderingEngine();\n    const { background } = options;\n    const viewportId = options.viewportId || id;\n    const volume = cache.getVolume(volumeViewport.getVolumeId());\n    if (!(volume instanceof ImageVolume)) {\n        throw new Error('Currently, you cannot decache a volume that is not an ImageVolume. So, unfortunately, volumes such as nifti  (which are basic Volume, without imageIds) cannot be decached.');\n    }\n    const viewportInput = {\n        viewportId,\n        type: ViewportType.STACK,\n        element,\n        defaultOptions: {\n            background,\n        },\n    };\n    const prevView = volumeViewport.getViewReference();\n    renderingEngine.enableElement(viewportInput);\n    const stackViewport = renderingEngine.getViewport(viewportId);\n    await stackViewport.setStack(volume.imageIds);\n    stackViewport.setViewReference(prevView);\n    stackViewport.render();\n    return stackViewport;\n}\nexport { convertVolumeToStackViewport };\n","import { EPSILON } from '../constants';\nfunction roundNumber(value, precision = 2) {\n    if (Array.isArray(value)) {\n        return value.map((v) => roundNumber(v, precision)).join(', ');\n    }\n    if (value === undefined || value === null || value === '') {\n        return 'NaN';\n    }\n    value = Number(value);\n    const absValue = Math.abs(value);\n    if (absValue < 0.0001) {\n        return `${value}`;\n    }\n    const fixedPrecision = absValue >= 100\n        ? precision - 2\n        : absValue >= 10\n            ? precision - 1\n            : absValue >= 1\n                ? precision\n                : absValue >= 0.1\n                    ? precision + 1\n                    : absValue >= 0.01\n                        ? precision + 2\n                        : absValue >= 0.001\n                            ? precision + 3\n                            : precision + 4;\n    return value.toFixed(fixedPrecision);\n}\nfunction roundToPrecision(value) {\n    return Math.round(value / EPSILON) * EPSILON;\n}\nexport { roundToPrecision };\nexport default roundNumber;\n","export default function convertToGrayscale(scalarData, width, height) {\n    const isRGBA = scalarData.length === width * height * 4;\n    const isRGB = scalarData.length === width * height * 3;\n    if (isRGBA || isRGB) {\n        const newScalarData = new Float32Array(width * height);\n        let offset = 0;\n        let destOffset = 0;\n        const increment = isRGBA ? 4 : 3;\n        for (let x = 0; x < width; x++) {\n            for (let y = 0; y < height; y++) {\n                const r = scalarData[offset];\n                const g = scalarData[offset + 1];\n                const b = scalarData[offset + 2];\n                newScalarData[destOffset] = (r + g + b) / 3;\n                offset += increment;\n                destOffset++;\n            }\n        }\n        return newScalarData;\n    }\n    else {\n        return scalarData;\n    }\n}\n","import { VolumeViewport } from '../RenderingEngine';\nimport cache from '../cache/cache';\nfunction getViewportImageIds(viewport) {\n    if (viewport instanceof VolumeViewport) {\n        const volume = cache.getVolume(viewport.getVolumeId());\n        return volume.imageIds;\n    }\n    else if (viewport.getImageIds) {\n        return viewport.getImageIds();\n    }\n}\nexport default getViewportImageIds;\n","export function getRandomSampleFromArray(array, size) {\n    const clonedArray = [...array];\n    if (size >= clonedArray.length) {\n        shuffleArray(clonedArray);\n        return clonedArray;\n    }\n    shuffleArray(clonedArray);\n    return clonedArray.slice(0, size);\n}\nfunction shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n}\n","function componentToHex(c) {\n    const hex = c.toString(16);\n    return hex.length == 1 ? '0' + hex : hex;\n}\nfunction rgbToHex(r, g, b) {\n    return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);\n}\nfunction hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result\n        ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16),\n        }\n        : null;\n}\nexport { hexToRgb, rgbToHex };\n","export function deepEqual(obj1, obj2) {\n    if (obj1 === obj2) {\n        return true;\n    }\n    if (obj1 == null || obj2 == null) {\n        return false;\n    }\n    try {\n        return JSON.stringify(obj1) === JSON.stringify(obj2);\n    }\n    catch (error) {\n        console.debug('Error in JSON.stringify during deep comparison:', error);\n        return obj1 === obj2;\n    }\n}\n","import * as metaData from '../metaData';\nconst groupBy = (array, key) => {\n    return array.reduce((rv, x) => {\n        (rv[x[key]] = rv[x[key]] || []).push(x);\n        return rv;\n    }, {});\n};\nfunction getIPPGroups(imageIds) {\n    const ippMetadata = imageIds.map((imageId) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId) || {};\n        return { imageId, imagePositionPatient };\n    });\n    if (!ippMetadata.every((item) => item.imagePositionPatient)) {\n        return null;\n    }\n    const positionGroups = groupBy(ippMetadata, 'imagePositionPatient');\n    const positions = Object.keys(positionGroups);\n    const frame_count = positionGroups[positions[0]].length;\n    if (frame_count === 1) {\n        return null;\n    }\n    const frame_count_equal = positions.every((k) => positionGroups[k].length === frame_count);\n    if (!frame_count_equal) {\n        return null;\n    }\n    return positionGroups;\n}\nfunction test4DTag(IPPGroups, value_getter) {\n    const frame_groups = {};\n    let first_frame_value_set = [];\n    const positions = Object.keys(IPPGroups);\n    for (let i = 0; i < positions.length; i++) {\n        const frame_value_set = new Set();\n        const frames = IPPGroups[positions[i]];\n        for (let j = 0; j < frames.length; j++) {\n            const frame_value = value_getter(frames[j].imageId) || 0;\n            frame_groups[frame_value] = frame_groups[frame_value] || [];\n            frame_groups[frame_value].push({ imageId: frames[j].imageId });\n            frame_value_set.add(frame_value);\n            if (frame_value_set.size - 1 < j) {\n                return undefined;\n            }\n        }\n        if (i == 0) {\n            first_frame_value_set = Array.from(frame_value_set);\n        }\n        else if (!setEquals(first_frame_value_set, frame_value_set)) {\n            return undefined;\n        }\n    }\n    return frame_groups;\n}\nfunction getTagValue(imageId, tag) {\n    const value = metaData.get(tag, imageId);\n    try {\n        return parseFloat(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction getPhilipsPrivateBValue(imageId) {\n    const value = metaData.get('20011003', imageId);\n    try {\n        const { InlineBinary } = value;\n        if (InlineBinary) {\n            const value_bytes = atob(InlineBinary);\n            const ary_buf = new ArrayBuffer(value_bytes.length);\n            const dv = new DataView(ary_buf);\n            for (let i = 0; i < value_bytes.length; i++) {\n                dv.setUint8(i, value_bytes.charCodeAt(i));\n            }\n            return new Float32Array(ary_buf)[0];\n        }\n        return parseFloat(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction getSiemensPrivateBValue(imageId) {\n    let value = metaData.get('0019100c', imageId) || metaData.get('0019100C', imageId);\n    try {\n        const { InlineBinary } = value;\n        if (InlineBinary) {\n            value = atob(InlineBinary);\n        }\n        return parseFloat(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction getGEPrivateBValue(imageId) {\n    let value = metaData.get('00431039', imageId);\n    try {\n        const { InlineBinary } = value;\n        if (InlineBinary) {\n            value = atob(InlineBinary).split('//');\n        }\n        return parseFloat(value[0]) % 100000;\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction setEquals(set_a, set_b) {\n    if (set_a.length != set_b.size) {\n        return false;\n    }\n    for (let i = 0; i < set_a.length; i++) {\n        if (!set_b.has(set_a[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getPetFrameReferenceTime(imageId) {\n    const moduleInfo = metaData.get('petImageModule', imageId);\n    return moduleInfo ? moduleInfo['frameReferenceTime'] : 0;\n}\nfunction splitImageIdsBy4DTags(imageIds) {\n    const positionGroups = getIPPGroups(imageIds);\n    if (!positionGroups) {\n        return { imageIdGroups: [imageIds], splittingTag: null };\n    }\n    const tags = [\n        'TemporalPositionIdentifier',\n        'DiffusionBValue',\n        'TriggerTime',\n        'EchoTime',\n        'EchoNumber',\n        'PhilipsPrivateBValue',\n        'SiemensPrivateBValue',\n        'GEPrivateBValue',\n        'PetFrameReferenceTime',\n    ];\n    const fncList2 = [\n        (imageId) => getTagValue(imageId, tags[0]),\n        (imageId) => getTagValue(imageId, tags[1]),\n        (imageId) => getTagValue(imageId, tags[2]),\n        (imageId) => getTagValue(imageId, tags[3]),\n        (imageId) => getTagValue(imageId, tags[4]),\n        getPhilipsPrivateBValue,\n        getSiemensPrivateBValue,\n        getGEPrivateBValue,\n        getPetFrameReferenceTime,\n    ];\n    for (let i = 0; i < fncList2.length; i++) {\n        const frame_groups = test4DTag(positionGroups, fncList2[i]);\n        if (frame_groups) {\n            const sortedKeys = Object.keys(frame_groups)\n                .map(Number.parseFloat)\n                .sort((a, b) => a - b);\n            const imageIdGroups = sortedKeys.map((key) => frame_groups[key].map((item) => item.imageId));\n            return { imageIdGroups, splittingTag: tags[i] };\n        }\n    }\n    return { imageIdGroups: [imageIds], splittingTag: null };\n}\nexport default splitImageIdsBy4DTags;\n","import splitImageIdsBy4DTags from './splitImageIdsBy4DTags';\nfunction getDynamicVolumeInfo(imageIds) {\n    const { imageIdGroups: timePoints, splittingTag } = splitImageIdsBy4DTags(imageIds);\n    const isDynamicVolume = timePoints.length > 1;\n    return { isDynamicVolume, timePoints, splittingTag };\n}\nexport default getDynamicVolumeInfo;\n","export default function scaleArray(array, scalingParameters) {\n    const arrayLength = array.length;\n    const { rescaleSlope, rescaleIntercept, suvbw } = scalingParameters;\n    if (scalingParameters.modality === 'PT' && typeof suvbw === 'number') {\n        for (let i = 0; i < arrayLength; i++) {\n            array[i] = suvbw * (array[i] * rescaleSlope + rescaleIntercept);\n        }\n    }\n    else {\n        for (let i = 0; i < arrayLength; i++) {\n            array[i] = array[i] * rescaleSlope + rescaleIntercept;\n        }\n    }\n    return array;\n}\n","export function clip(val, low, high) {\n    return Math.min(Math.max(low, val), high);\n}\nexport function clipToBox(point, box) {\n    point.x = clip(point.x, 0, box.width);\n    point.y = clip(point.y, 0, box.height);\n}\nexport default clip;\n","import { Events } from '../enums';\nimport { StackViewport, VolumeViewport } from '../RenderingEngine';\nimport getVolumeViewportScrollInfo from './getVolumeViewportScrollInfo';\nimport snapFocalPointToSlice from './snapFocalPointToSlice';\nimport getEnabledElement from '../getEnabledElement';\nimport triggerEvent from './triggerEvent';\nimport eventTarget from '../eventTarget';\nexport default function scroll(viewport, options) {\n    const enabledElement = getEnabledElement(viewport.element);\n    if (!enabledElement) {\n        throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n    }\n    if (viewport instanceof StackViewport &&\n        viewport.getImageIds().length === 0) {\n        throw new Error('Scroll::Stack Viewport has no images');\n    }\n    const { volumeId, delta, scrollSlabs } = options;\n    if (viewport instanceof VolumeViewport) {\n        scrollVolume(viewport, volumeId, delta, scrollSlabs);\n    }\n    else {\n        const imageIdIndex = viewport.getCurrentImageIdIndex();\n        if (imageIdIndex + delta >\n            viewport.getImageIds().length - 1 ||\n            imageIdIndex + delta < 0) {\n            const eventData = {\n                imageIdIndex,\n                direction: delta,\n            };\n            triggerEvent(eventTarget, Events.STACK_SCROLL_OUT_OF_BOUNDS, eventData);\n        }\n        viewport.scroll(delta, options.debounceLoading, options.loop);\n    }\n}\nexport function scrollVolume(viewport, volumeId, delta, scrollSlabs = false) {\n    const useSlabThickness = scrollSlabs;\n    const { numScrollSteps, currentStepIndex, sliceRangeInfo } = getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\n    if (!sliceRangeInfo) {\n        return;\n    }\n    const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n    const { focalPoint, viewPlaneNormal, position } = camera;\n    const { newFocalPoint, newPosition } = snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);\n    viewport.setCamera({\n        focalPoint: newFocalPoint,\n        position: newPosition,\n    });\n    viewport.render();\n    const desiredStepIndex = currentStepIndex + delta;\n    const VolumeScrollEventDetail = {\n        volumeId,\n        viewport,\n        delta,\n        desiredStepIndex,\n        currentStepIndex,\n        numScrollSteps,\n        currentImageId: viewport.getCurrentImageId(),\n    };\n    if ((desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n        viewport.getCurrentImageId()) {\n        triggerEvent(eventTarget, Events.VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS, VolumeScrollEventDetail);\n    }\n    else {\n        triggerEvent(eventTarget, Events.VOLUME_VIEWPORT_SCROLL, VolumeScrollEventDetail);\n    }\n}\n","import clip from './clip';\nimport scroll from './scroll';\nimport getEnabledElement from '../getEnabledElement';\nimport StackViewport from '../RenderingEngine/StackViewport';\nasync function jumpToSlice(element, options = {}) {\n    const { imageIndex, debounceLoading, volumeId } = options;\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('Element has been disabled');\n    }\n    const { viewport } = enabledElement;\n    const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(viewport, debounceLoading);\n    const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n    const delta = imageIndexToJump - currentImageIndex;\n    scroll(viewport, { delta, debounceLoading, volumeId });\n}\nfunction _getImageSliceData(viewport, debounceLoading) {\n    if (viewport instanceof StackViewport) {\n        return {\n            numberOfSlices: viewport.getImageIds().length,\n            imageIndex: debounceLoading\n                ? viewport.getTargetImageIdIndex()\n                : viewport.getCurrentImageIdIndex(),\n        };\n    }\n    return {\n        numberOfSlices: viewport.getNumberOfSlices(),\n        imageIndex: viewport.getSliceIndex(),\n    };\n}\nfunction _getImageIndexToJump(numberOfSlices, imageIndex) {\n    const lastSliceIndex = numberOfSlices - 1;\n    return clip(imageIndex, 0, lastSliceIndex);\n}\nexport { jumpToSlice };\n","import * as eventListener from './eventListener';\nimport csUtils from './invertRgbTransferFunction';\nimport createSigmoidRGBTransferFunction from './createSigmoidRGBTransferFunction';\nimport getVoiFromSigmoidRGBTransferFunction from './getVoiFromSigmoidRGBTransferFunction';\nimport createLinearRGBTransferFunction from './createLinearRGBTransferFunction';\nimport scaleRgbTransferFunction from './scaleRgbTransferFunction';\nimport triggerEvent from './triggerEvent';\nimport uuidv4 from './uuidv4';\nimport getMinMax from './getMinMax';\nimport getRuntimeId from './getRuntimeId';\nimport imageIdToURI from './imageIdToURI';\nimport calibratedPixelSpacingMetadataProvider from './calibratedPixelSpacingMetadataProvider';\nimport clamp from './clamp';\nimport { isEqual, isEqualAbs, isEqualNegative } from './isEqual';\nimport isOpposite from './isOpposite';\nimport getClosestImageId from './getClosestImageId';\nimport getSpacingInNormalDirection from './getSpacingInNormalDirection';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\nimport getVolumeActorCorners from './getVolumeActorCorners';\nimport indexWithinDimensions from './indexWithinDimensions';\nimport getVolumeViewportsContainingSameVolumes from './getVolumeViewportsContainingSameVolumes';\nimport getViewportsWithVolumeId from './getViewportsWithVolumeId';\nimport transformWorldToIndex from './transformWorldToIndex';\nimport transformIndexToWorld from './transformIndexToWorld';\nimport loadImageToCanvas from './loadImageToCanvas';\nimport renderToCanvasCPU from './renderToCanvasCPU';\nimport renderToCanvasGPU from './renderToCanvasGPU';\nimport worldToImageCoords from './worldToImageCoords';\nimport imageToWorldCoords from './imageToWorldCoords';\nimport getVolumeSliceRangeInfo from './getVolumeSliceRangeInfo';\nimport getVolumeViewportScrollInfo from './getVolumeViewportScrollInfo';\nimport getSliceRange from './getSliceRange';\nimport snapFocalPointToSlice from './snapFocalPointToSlice';\nimport getImageSliceDataForVolumeViewport from './getImageSliceDataForVolumeViewport';\nimport { isImageActor, actorIsA } from './actorCheck';\nimport getViewportsWithImageURI from './getViewportsWithImageURI';\nimport getClosestStackImageIndexForPoint from './getClosestStackImageIndexForPoint';\nimport getCurrentVolumeViewportSlice from './getCurrentVolumeViewportSlice';\nimport calculateViewportsSpatialRegistration from './calculateViewportsSpatialRegistration';\nimport spatialRegistrationMetadataProvider from './spatialRegistrationMetadataProvider';\nimport getViewportImageCornersInWorld from './getViewportImageCornersInWorld';\nimport hasNaNValues from './hasNaNValues';\nimport applyPreset from './applyPreset';\nimport PointsManager from './PointsManager';\nimport deepMerge from './deepMerge';\nimport getScalingParameters from './getScalingParameters';\nimport isPTPrescaledWithSUV from './isPTPrescaledWithSUV';\nimport getImageLegacy from './getImageLegacy';\nimport sortImageIdsAndGetSpacing from './sortImageIdsAndGetSpacing';\nimport makeVolumeMetadata from './makeVolumeMetadata';\nimport genericMetadataProvider from './genericMetadataProvider';\nimport { isValidVolume } from './isValidVolume';\nimport { updateVTKImageDataWithCornerstoneImage } from './updateVTKImageDataWithCornerstoneImage';\nimport ProgressiveIterator from './ProgressiveIterator';\nimport decimate from './decimate';\nimport imageRetrieveMetadataProvider from './imageRetrieveMetadataProvider';\nimport isVideoTransferSyntax from './isVideoTransferSyntax';\nimport { getBufferConfiguration } from './getBufferConfiguration';\nimport { generateVolumePropsFromImageIds } from './generateVolumePropsFromImageIds';\nimport { convertStackToVolumeViewport } from './convertStackToVolumeViewport';\nimport { convertVolumeToStackViewport } from './convertVolumeToStackViewport';\nimport VoxelManager from './VoxelManager';\nimport RLEVoxelMap from './RLEVoxelMap';\nimport roundNumber, { roundToPrecision } from './roundNumber';\nimport convertToGrayscale from './convertToGrayscale';\nimport getViewportImageIds from './getViewportImageIds';\nimport { getRandomSampleFromArray } from './getRandomSampleFromArray';\nimport { getVolumeId } from './getVolumeId';\nimport { hasFloatScalingParameters } from './hasFloatScalingParameters';\nimport { pointInShapeCallback } from './pointInShapeCallback';\nimport * as planar from './planar';\nimport * as windowLevel from './windowLevel';\nimport * as colormap from './colormap';\nimport * as transferFunctionUtils from './transferFunctionUtils';\nimport * as color from './color';\nimport { deepEqual } from './deepEqual';\nimport { _getViewportModality } from './getViewportModality';\nimport cache from '../cache/cache';\nimport getDynamicVolumeInfo from './getDynamicVolumeInfo';\nimport autoLoad from './autoLoad';\nimport scaleArray from './scaleArray';\nimport splitImageIdsBy4DTags from './splitImageIdsBy4DTags';\nimport { deepClone } from './deepClone';\nimport { jumpToSlice } from './jumpToSlice';\nimport scroll from './scroll';\nimport clip from './clip';\nconst getViewportModality = (viewport, volumeId) => _getViewportModality(viewport, volumeId, cache.getVolume);\nexport { eventListener, csUtils as invertRgbTransferFunction, createSigmoidRGBTransferFunction, getVoiFromSigmoidRGBTransferFunction, createLinearRGBTransferFunction, scaleRgbTransferFunction, triggerEvent, imageIdToURI, calibratedPixelSpacingMetadataProvider, clamp, uuidv4, planar, getMinMax, getRuntimeId, isEqual, isEqualAbs, isEqualNegative, isOpposite, getViewportModality, windowLevel, convertToGrayscale, getClosestImageId, getSpacingInNormalDirection, getTargetVolumeAndSpacingInNormalDir, getVolumeActorCorners, indexWithinDimensions, getVolumeViewportsContainingSameVolumes, getViewportsWithVolumeId, transformWorldToIndex, transformIndexToWorld, loadImageToCanvas, renderToCanvasCPU, renderToCanvasGPU, worldToImageCoords, imageToWorldCoords, getVolumeSliceRangeInfo, getVolumeViewportScrollInfo, getSliceRange, snapFocalPointToSlice, getImageSliceDataForVolumeViewport, isImageActor, isPTPrescaledWithSUV, actorIsA, getViewportsWithImageURI, getClosestStackImageIndexForPoint, getCurrentVolumeViewportSlice, calculateViewportsSpatialRegistration, spatialRegistrationMetadataProvider, getViewportImageCornersInWorld, hasNaNValues, applyPreset, deepMerge, PointsManager, getScalingParameters, colormap, getImageLegacy, ProgressiveIterator, decimate, imageRetrieveMetadataProvider, transferFunctionUtils, updateVTKImageDataWithCornerstoneImage, sortImageIdsAndGetSpacing, makeVolumeMetadata, isValidVolume, genericMetadataProvider, isVideoTransferSyntax, generateVolumePropsFromImageIds, getBufferConfiguration, VoxelManager, RLEVoxelMap, convertStackToVolumeViewport, convertVolumeToStackViewport, roundNumber, roundToPrecision, getViewportImageIds, getRandomSampleFromArray, getVolumeId, color, hasFloatScalingParameters, getDynamicVolumeInfo, autoLoad, scaleArray, deepClone, splitImageIdsBy4DTags, pointInShapeCallback, deepEqual, jumpToSlice, scroll, clip, };\n","function _getViewportModality(viewport, volumeId, getVolume) {\n    if (!getVolume) {\n        throw new Error('getVolume is required, use the utilities export instead ');\n    }\n    if (viewport.modality) {\n        return viewport.modality;\n    }\n    if (viewport.setVolumes) {\n        volumeId = volumeId ?? viewport.getVolumeId();\n        if (!volumeId || !getVolume) {\n            return;\n        }\n        const volume = getVolume(volumeId);\n        return volume.metadata.Modality;\n    }\n    throw new Error('Invalid viewport type');\n}\nexport { _getViewportModality };\n","export default function invertRgbTransferFunction(rgbTransferFunction) {\n    if (!rgbTransferFunction) {\n        return;\n    }\n    const size = rgbTransferFunction.getSize();\n    for (let index = 0; index < size; index++) {\n        const nodeValue1 = [];\n        rgbTransferFunction.getNodeValue(index, nodeValue1);\n        nodeValue1[1] = 1 - nodeValue1[1];\n        nodeValue1[2] = 1 - nodeValue1[2];\n        nodeValue1[3] = 1 - nodeValue1[3];\n        rgbTransferFunction.setNodeValue(index, nodeValue1);\n    }\n}\n","function areNumbersEqualWithTolerance(num1, num2, tolerance) {\n    return Math.abs(num1 - num2) <= tolerance;\n}\nfunction areArraysEqual(arr1, arr2, tolerance = 1e-5) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (!areNumbersEqualWithTolerance(arr1[i], arr2[i], tolerance)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isNumberType(value) {\n    return typeof value === 'number';\n}\nfunction isNumberArrayLike(value) {\n    return (value &&\n        typeof value === 'object' &&\n        'length' in value &&\n        typeof value.length === 'number' &&\n        value.length > 0 &&\n        typeof value[0] === 'number');\n}\nexport default function isEqual(v1, v2, tolerance = 1e-5) {\n    if (typeof v1 !== typeof v2 || v1 === null || v2 === null) {\n        return false;\n    }\n    if (isNumberType(v1) && isNumberType(v2)) {\n        return areNumbersEqualWithTolerance(v1, v2, tolerance);\n    }\n    if (isNumberArrayLike(v1) && isNumberArrayLike(v2)) {\n        return areArraysEqual(v1, v2, tolerance);\n    }\n    return false;\n}\nconst negative = (v) => typeof v === 'number' ? -v : v?.map ? v.map(negative) : !v;\nconst abs = (v) => typeof v === 'number' ? Math.abs(v) : v?.map ? v.map(abs) : v;\nconst isEqualNegative = (v1, v2, tolerance = undefined) => isEqual(v1, negative(v2), tolerance);\nconst isEqualAbs = (v1, v2, tolerance = undefined) => isEqual(abs(v1), abs(v2), tolerance);\nexport { isEqualNegative, isEqual, isEqualAbs };\n","import { get } from '../metaData';\nexport default function makeVolumeMetadata(imageIds) {\n    const imageId0 = imageIds[0];\n    const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel, } = get('imagePixelModule', imageId0);\n    const voiLut = [];\n    const voiLutModule = get('voiLutModule', imageId0);\n    let voiLUTFunction;\n    if (voiLutModule) {\n        const { windowWidth, windowCenter } = voiLutModule;\n        voiLUTFunction = voiLutModule?.voiLUTFunction;\n        if (Array.isArray(windowWidth)) {\n            for (let i = 0; i < windowWidth.length; i++) {\n                voiLut.push({\n                    windowWidth: windowWidth[i],\n                    windowCenter: windowCenter[i],\n                });\n            }\n        }\n        else {\n            voiLut.push({\n                windowWidth: windowWidth,\n                windowCenter: windowCenter,\n            });\n        }\n    }\n    else {\n        voiLut.push({\n            windowWidth: undefined,\n            windowCenter: undefined,\n        });\n    }\n    const { modality, seriesInstanceUID } = get('generalSeriesModule', imageId0);\n    const { imageOrientationPatient, pixelSpacing, frameOfReferenceUID, columns, rows, } = get('imagePlaneModule', imageId0);\n    return {\n        BitsAllocated: bitsAllocated,\n        BitsStored: bitsStored,\n        SamplesPerPixel: samplesPerPixel,\n        HighBit: highBit,\n        PhotometricInterpretation: photometricInterpretation,\n        PixelRepresentation: pixelRepresentation,\n        Modality: modality,\n        ImageOrientationPatient: imageOrientationPatient,\n        PixelSpacing: pixelSpacing,\n        FrameOfReferenceUID: frameOfReferenceUID,\n        Columns: columns,\n        Rows: rows,\n        voiLut,\n        VOILUTFunction: voiLUTFunction,\n        SeriesInstanceUID: seriesInstanceUID,\n    };\n}\n","import { mat3 } from 'gl-matrix';\nfunction linePlaneIntersection(p0, p1, plane) {\n    const [x0, y0, z0] = p0;\n    const [x1, y1, z1] = p1;\n    const [A, B, C, D] = plane;\n    const a = x1 - x0;\n    const b = y1 - y0;\n    const c = z1 - z0;\n    const t = (-1 * (A * x0 + B * y0 + C * z0 - D)) / (A * a + B * b + C * c);\n    const X = a * t + x0;\n    const Y = b * t + y0;\n    const Z = c * t + z0;\n    return [X, Y, Z];\n}\nfunction planeEquation(normal, point, normalized = false) {\n    const [A, B, C] = normal;\n    const D = A * point[0] + B * point[1] + C * point[2];\n    if (normalized) {\n        const length = Math.sqrt(A * A + B * B + C * C);\n        return [A / length, B / length, C / length, D / length];\n    }\n    return [A, B, C, D];\n}\nfunction threePlaneIntersection(firstPlane, secondPlane, thirdPlane) {\n    const [A1, B1, C1, D1] = firstPlane;\n    const [A2, B2, C2, D2] = secondPlane;\n    const [A3, B3, C3, D3] = thirdPlane;\n    const m0 = mat3.fromValues(A1, A2, A3, B1, B2, B3, C1, C2, C3);\n    const m1 = mat3.fromValues(D1, D2, D3, B1, B2, B3, C1, C2, C3);\n    const m2 = mat3.fromValues(A1, A2, A3, D1, D2, D3, C1, C2, C3);\n    const m3 = mat3.fromValues(A1, A2, A3, B1, B2, B3, D1, D2, D3);\n    const x = mat3.determinant(m1) / mat3.determinant(m0);\n    const y = mat3.determinant(m2) / mat3.determinant(m0);\n    const z = mat3.determinant(m3) / mat3.determinant(m0);\n    return [x, y, z];\n}\nfunction planeDistanceToPoint(plane, point, signed = false) {\n    const [A, B, C, D] = plane;\n    const [x, y, z] = point;\n    const numerator = A * x + B * y + C * z - D;\n    const distance = Math.abs(numerator) / Math.sqrt(A * A + B * B + C * C);\n    const sign = signed ? Math.sign(numerator) : 1;\n    return sign * distance;\n}\nexport { linePlaneIntersection, planeEquation, threePlaneIntersection, planeDistanceToPoint, };\n","import { vec3 } from 'gl-matrix';\nexport function pointInShapeCallback(imageData, options) {\n    const { pointInShapeFn, callback, boundsIJK, returnPoints = false, } = options;\n    let iMin, iMax, jMin, jMax, kMin, kMax;\n    let scalarData;\n    const { numComps } = imageData;\n    if (imageData.getScalarData) {\n        scalarData = imageData.getScalarData();\n    }\n    else {\n        scalarData = imageData\n            .getPointData()\n            .getScalars()\n            .getData();\n    }\n    if (!scalarData) {\n        console.warn('No scalar data found for imageData', imageData);\n        return;\n    }\n    const dimensions = imageData.getDimensions();\n    if (!boundsIJK) {\n        iMin = 0;\n        iMax = dimensions[0];\n        jMin = 0;\n        jMax = dimensions[1];\n        kMin = 0;\n        kMax = dimensions[2];\n    }\n    else {\n        [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n    }\n    const start = vec3.fromValues(iMin, jMin, kMin);\n    const direction = imageData.getDirection();\n    const rowCosines = direction.slice(0, 3);\n    const columnCosines = direction.slice(3, 6);\n    const scanAxisNormal = direction.slice(6, 9);\n    const spacing = imageData.getSpacing();\n    const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n    const worldPosStart = imageData.indexToWorld(start);\n    const rowStep = vec3.fromValues(rowCosines[0] * rowSpacing, rowCosines[1] * rowSpacing, rowCosines[2] * rowSpacing);\n    const columnStep = vec3.fromValues(columnCosines[0] * columnSpacing, columnCosines[1] * columnSpacing, columnCosines[2] * columnSpacing);\n    const scanAxisStep = vec3.fromValues(scanAxisNormal[0] * scanAxisSpacing, scanAxisNormal[1] * scanAxisSpacing, scanAxisNormal[2] * scanAxisSpacing);\n    const xMultiple = numComps ||\n        scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n    const yMultiple = dimensions[0] * xMultiple;\n    const zMultiple = dimensions[1] * yMultiple;\n    const pointsInShape = [];\n    const currentPos = vec3.clone(worldPosStart);\n    for (let k = kMin; k <= kMax; k++) {\n        const startPosJ = vec3.clone(currentPos);\n        for (let j = jMin; j <= jMax; j++) {\n            const startPosI = vec3.clone(currentPos);\n            for (let i = iMin; i <= iMax; i++) {\n                const pointIJK = [i, j, k];\n                if (pointInShapeFn(currentPos, pointIJK)) {\n                    const index = k * zMultiple + j * yMultiple + i * xMultiple;\n                    let value;\n                    if (xMultiple > 2) {\n                        value = [\n                            scalarData[index],\n                            scalarData[index + 1],\n                            scalarData[index + 2],\n                        ];\n                    }\n                    else {\n                        value = scalarData[index];\n                    }\n                    pointsInShape.push({\n                        value,\n                        index,\n                        pointIJK,\n                        pointLPS: currentPos.slice(),\n                    });\n                    if (callback) {\n                        callback({\n                            value,\n                            index,\n                            pointIJK,\n                            pointLPS: currentPos,\n                        });\n                    }\n                }\n                vec3.add(currentPos, currentPos, rowStep);\n            }\n            vec3.copy(currentPos, startPosI);\n            vec3.add(currentPos, currentPos, columnStep);\n        }\n        vec3.copy(currentPos, startPosJ);\n        vec3.add(currentPos, currentPos, scanAxisStep);\n    }\n    return returnPoints ? pointsInShape : undefined;\n}\n","import { vec3 } from 'gl-matrix';\nexport default function snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, deltaFrames) {\n    const { min, max, current } = sliceRange;\n    const posDiffFromFocalPoint = vec3.create();\n    vec3.sub(posDiffFromFocalPoint, position, focalPoint);\n    const steps = Math.round((max - min) / spacingInNormalDirection);\n    const fraction = (current - min) / (max - min);\n    const floatingStepNumber = fraction * steps;\n    let frameIndex = Math.round(floatingStepNumber);\n    let newFocalPoint = [\n        focalPoint[0] -\n            viewPlaneNormal[0] * floatingStepNumber * spacingInNormalDirection,\n        focalPoint[1] -\n            viewPlaneNormal[1] * floatingStepNumber * spacingInNormalDirection,\n        focalPoint[2] -\n            viewPlaneNormal[2] * floatingStepNumber * spacingInNormalDirection,\n    ];\n    frameIndex += deltaFrames;\n    if (frameIndex > steps) {\n        frameIndex = steps;\n    }\n    else if (frameIndex < 0) {\n        frameIndex = 0;\n    }\n    const newSlicePosFromMin = frameIndex * spacingInNormalDirection;\n    newFocalPoint = [\n        newFocalPoint[0] + viewPlaneNormal[0] * newSlicePosFromMin,\n        newFocalPoint[1] + viewPlaneNormal[1] * newSlicePosFromMin,\n        newFocalPoint[2] + viewPlaneNormal[2] * newSlicePosFromMin,\n    ];\n    const newPosition = [\n        newFocalPoint[0] + posDiffFromFocalPoint[0],\n        newFocalPoint[1] + posDiffFromFocalPoint[1],\n        newFocalPoint[2] + posDiffFromFocalPoint[2],\n    ];\n    return { newFocalPoint, newPosition };\n}\n","import { vec3 } from 'gl-matrix';\nimport * as metaData from '../metaData';\nimport { getConfiguration } from '../init';\nexport default function sortImageIdsAndGetSpacing(imageIds, scanAxisNormal) {\n    const { imagePositionPatient: referenceImagePositionPatient, imageOrientationPatient, } = metaData.get('imagePlaneModule', imageIds[0]);\n    if (!scanAxisNormal) {\n        const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n        const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n        scanAxisNormal = vec3.create();\n        vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n    }\n    const refIppVec = vec3.create();\n    const usingWadoUri = imageIds[0].split(':')[0] === 'wadouri';\n    vec3.set(refIppVec, referenceImagePositionPatient[0], referenceImagePositionPatient[1], referenceImagePositionPatient[2]);\n    let sortedImageIds;\n    let zSpacing;\n    function getDistance(imageId) {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const positionVector = vec3.create();\n        vec3.sub(positionVector, referenceImagePositionPatient, imagePositionPatient);\n        return vec3.dot(positionVector, scanAxisNormal);\n    }\n    if (!usingWadoUri) {\n        const distanceImagePairs = imageIds.map((imageId) => {\n            const distance = getDistance(imageId);\n            return {\n                distance,\n                imageId,\n            };\n        });\n        distanceImagePairs.sort((a, b) => b.distance - a.distance);\n        sortedImageIds = distanceImagePairs.map((a) => a.imageId);\n        const numImages = distanceImagePairs.length;\n        zSpacing =\n            Math.abs(distanceImagePairs[numImages - 1].distance -\n                distanceImagePairs[0].distance) /\n                (numImages - 1);\n    }\n    else {\n        const prefetchedImageIds = [\n            imageIds[0],\n            imageIds[Math.floor(imageIds.length / 2)],\n        ];\n        sortedImageIds = imageIds;\n        const firstImageDistance = getDistance(prefetchedImageIds[0]);\n        const middleImageDistance = getDistance(prefetchedImageIds[1]);\n        if (firstImageDistance - middleImageDistance < 0) {\n            sortedImageIds.reverse();\n        }\n        const metadataForMiddleImage = metaData.get('imagePlaneModule', prefetchedImageIds[1]);\n        if (!metadataForMiddleImage) {\n            throw new Error('Incomplete metadata required for volume construction.');\n        }\n        const positionVector = vec3.create();\n        vec3.sub(positionVector, referenceImagePositionPatient, metadataForMiddleImage.imagePositionPatient);\n        const distanceBetweenFirstAndMiddleImages = vec3.dot(positionVector, scanAxisNormal);\n        zSpacing =\n            Math.abs(distanceBetweenFirstAndMiddleImages) /\n                Math.floor(imageIds.length / 2);\n    }\n    const { imagePositionPatient: origin, sliceThickness, spacingBetweenSlices, } = metaData.get('imagePlaneModule', sortedImageIds[0]);\n    const { strictZSpacingForVolumeViewport } = getConfiguration().rendering;\n    if (zSpacing === 0 && !strictZSpacingForVolumeViewport) {\n        if (sliceThickness && spacingBetweenSlices) {\n            console.log('Could not calculate zSpacing. Using spacingBetweenSlices');\n            zSpacing = spacingBetweenSlices;\n        }\n        else if (sliceThickness) {\n            console.log('Could not calculate zSpacing and no spacingBetweenSlices. Using sliceThickness');\n            zSpacing = sliceThickness;\n        }\n        else {\n            console.log('Could not calculate zSpacing. The VolumeViewport visualization is compromised. Setting zSpacing to 1 to render');\n            zSpacing = 1;\n        }\n    }\n    const result = {\n        zSpacing,\n        origin,\n        sortedImageIds,\n    };\n    return result;\n}\n","function getTransferFunctionNodes(transferFunction) {\n    const size = transferFunction.getSize();\n    const values = [];\n    for (let index = 0; index < size; index++) {\n        const nodeValue1 = [];\n        transferFunction.getNodeValue(index, nodeValue1);\n        values.push(nodeValue1);\n    }\n    return values;\n}\nfunction setTransferFunctionNodes(transferFunction, nodes) {\n    if (!nodes?.length) {\n        return;\n    }\n    transferFunction.removeAllPoints();\n    nodes.forEach((node) => {\n        transferFunction.addRGBPoint(...node);\n    });\n}\nexport { getTransferFunctionNodes, setTransferFunctionNodes };\n","import transformWorldToIndex from './transformWorldToIndex';\nexport function transformCanvasToIJK(viewport, canvasPoint) {\n    const { imageData: vtkImageData } = viewport.getImageData();\n    const worldPoint = viewport.canvasToWorld(canvasPoint);\n    return transformWorldToIndex(vtkImageData, worldPoint);\n}\n","export default function transformIndexToWorld(imageData, voxelPos) {\n    return imageData.indexToWorld(voxelPos);\n}\n","export default function transformWorldToIndex(imageData, worldPos) {\n    const continuousIndex = imageData.worldToIndex(worldPos);\n    const index = continuousIndex.map(Math.round);\n    return index;\n}\n","function updateVTKImageDataWithCornerstoneImage(sourceImageData, image) {\n    const pixelData = image.voxelManager.getScalarData();\n    if (!sourceImageData.getPointData) {\n        return;\n    }\n    const scalarData = sourceImageData\n        .getPointData()\n        .getScalars()\n        .getData();\n    if (image.color && image.rgba) {\n        const newPixelData = new Uint8Array(image.columns * image.rows * 3);\n        for (let i = 0; i < image.columns * image.rows; i++) {\n            newPixelData[i * 3] = pixelData[i * 4];\n            newPixelData[i * 3 + 1] = pixelData[i * 4 + 1];\n            newPixelData[i * 3 + 2] = pixelData[i * 4 + 2];\n        }\n        image.rgba = false;\n        image.getPixelData = () => newPixelData;\n        scalarData.set(newPixelData);\n    }\n    else {\n        scalarData.set(pixelData);\n    }\n    sourceImageData.modified();\n}\nexport { updateVTKImageDataWithCornerstoneImage };\n","function toWindowLevel(low, high) {\n    const windowWidth = Math.abs(high - low) + 1;\n    const windowCenter = (low + high + 1) / 2;\n    return { windowWidth, windowCenter };\n}\nfunction toLowHighRange(windowWidth, windowCenter) {\n    const lower = windowCenter - 0.5 - (windowWidth - 1) / 2;\n    const upper = windowCenter - 0.5 + (windowWidth - 1) / 2;\n    return { lower, upper };\n}\nexport { toWindowLevel, toLowHighRange };\n","const CORNERSTONE_COLOR_LUT = [\n    [0, 0, 0, 0],\n    [221, 84, 84, 255],\n    [77, 228, 121, 255],\n    [166, 70, 235, 255],\n    [189, 180, 116, 255],\n    [109, 182, 196, 255],\n    [204, 101, 157, 255],\n    [123, 211, 94, 255],\n    [93, 87, 218, 255],\n    [225, 128, 80, 255],\n    [73, 232, 172, 255],\n    [181, 119, 186, 255],\n    [176, 193, 112, 255],\n    [105, 153, 200, 255],\n    [208, 97, 120, 255],\n    [90, 215, 101, 255],\n    [135, 83, 222, 255],\n    [229, 178, 76, 255],\n    [122, 183, 181, 255],\n    [190, 115, 171, 255],\n    [149, 197, 108, 255],\n    [100, 118, 205, 255],\n    [212, 108, 93, 255],\n    [86, 219, 141, 255],\n    [183, 79, 226, 255],\n    [233, 233, 72, 255],\n    [118, 167, 187, 255],\n    [194, 111, 146, 255],\n    [116, 201, 104, 255],\n    [115, 96, 209, 255],\n    [216, 147, 89, 255],\n    [82, 223, 188, 255],\n    [230, 75, 224, 255],\n    [163, 184, 121, 255],\n    [114, 143, 191, 255],\n    [198, 107, 114, 255],\n    [99, 206, 122, 255],\n    [153, 92, 213, 255],\n    [220, 192, 85, 255],\n    [78, 215, 227, 255],\n    [234, 71, 173, 255],\n    [141, 188, 117, 255],\n    [110, 113, 195, 255],\n    [202, 128, 103, 255],\n    [95, 210, 157, 255],\n    [195, 88, 217, 255],\n    [206, 224, 81, 255],\n    [74, 166, 231, 255],\n    [185, 120, 139, 255],\n    [113, 192, 113, 255],\n    [133, 106, 199, 255],\n    [207, 162, 98, 255],\n    [91, 214, 198, 255],\n    [221, 84, 198, 255],\n    [159, 228, 77, 255],\n    [70, 111, 235, 255],\n    [189, 119, 116, 255],\n    [109, 196, 138, 255],\n    [165, 101, 204, 255],\n    [211, 201, 94, 255],\n    [87, 191, 218, 255],\n    [225, 80, 153, 255],\n    [106, 232, 73, 255],\n    [124, 119, 186, 255],\n    [193, 142, 112, 255],\n    [105, 200, 168, 255],\n    [203, 97, 208, 255],\n    [184, 215, 90, 255],\n    [83, 147, 222, 255],\n    [229, 76, 101, 255],\n    [122, 183, 130, 255],\n    [146, 115, 190, 255],\n    [197, 171, 108, 255],\n    [100, 205, 205, 255],\n    [212, 93, 177, 255],\n    [141, 219, 86, 255],\n    [79, 97, 226, 255],\n    [233, 99, 72, 255],\n    [118, 187, 150, 255],\n    [173, 111, 194, 255],\n    [197, 201, 104, 255],\n    [96, 171, 209, 255],\n    [216, 89, 137, 255],\n    [94, 223, 82, 255],\n    [107, 75, 230, 255],\n    [184, 153, 121, 255],\n    [114, 191, 175, 255],\n    [198, 107, 191, 255],\n    [166, 206, 99, 255],\n    [92, 132, 213, 255],\n    [220, 85, 91, 255],\n    [78, 227, 115, 255],\n    [159, 71, 234, 255],\n    [188, 176, 117, 255],\n    [110, 185, 195, 255],\n    [202, 103, 161, 255],\n    [129, 210, 95, 255],\n    [88, 88, 217, 255],\n    [224, 123, 81, 255],\n    [74, 231, 166, 255],\n    [177, 120, 185, 255],\n    [179, 192, 113, 255],\n    [106, 156, 199, 255],\n    [207, 98, 125, 255],\n    [91, 214, 96, 255],\n    [130, 84, 221, 255],\n    [228, 171, 77, 255],\n    [70, 235, 221, 255],\n    [189, 116, 174, 255],\n    [153, 196, 109, 255],\n    [101, 123, 204, 255],\n    [211, 104, 94, 255],\n    [87, 218, 136, 255],\n    [177, 80, 225, 255],\n    [232, 225, 73, 255],\n    [119, 169, 186, 255],\n    [193, 112, 149, 255],\n    [121, 200, 105, 255],\n    [111, 97, 208, 255],\n    [215, 142, 90, 255],\n    [83, 222, 181, 255],\n    [229, 76, 229, 255],\n    [165, 183, 122, 255],\n    [115, 146, 190, 255],\n    [197, 108, 119, 255],\n    [100, 205, 118, 255],\n    [148, 93, 212, 255],\n    [219, 186, 86, 255],\n    [79, 220, 226, 255],\n    [233, 72, 179, 255],\n    [144, 187, 118, 255],\n    [111, 118, 194, 255],\n    [201, 124, 104, 255],\n    [96, 209, 153, 255],\n    [189, 89, 216, 255],\n    [211, 223, 82, 255],\n    [75, 172, 230, 255],\n    [184, 121, 142, 255],\n    [117, 191, 114, 255],\n    [130, 107, 198, 255],\n    [206, 157, 99, 255],\n    [92, 213, 193, 255],\n    [220, 85, 203, 255],\n    [165, 227, 78, 255],\n    [71, 118, 234, 255],\n    [188, 117, 117, 255],\n    [110, 195, 135, 255],\n    [161, 103, 202, 255],\n    [210, 195, 95, 255],\n    [88, 195, 217, 255],\n    [224, 81, 158, 255],\n    [113, 231, 74, 255],\n    [123, 120, 185, 255],\n    [192, 139, 113, 255],\n    [106, 199, 164, 255],\n    [198, 98, 207, 255],\n    [188, 214, 91, 255],\n    [84, 153, 221, 255],\n    [228, 77, 108, 255],\n    [70, 235, 84, 255],\n    [143, 116, 189, 255],\n    [196, 167, 109, 255],\n    [101, 204, 199, 255],\n    [211, 94, 182, 255],\n    [147, 218, 87, 255],\n    [80, 104, 225, 255],\n    [232, 93, 73, 255],\n    [119, 186, 147, 255],\n    [170, 112, 193, 255],\n    [200, 200, 105, 255],\n    [97, 175, 208, 255],\n    [215, 90, 142, 255],\n    [100, 222, 83, 255],\n    [101, 76, 229, 255],\n    [183, 150, 122, 255],\n    [115, 190, 171, 255],\n    [197, 108, 194, 255],\n    [170, 205, 100, 255],\n    [93, 138, 212, 255],\n    [219, 86, 97, 255],\n    [79, 226, 110, 255],\n    [153, 72, 233, 255],\n    [187, 173, 118, 255],\n    [111, 187, 194, 255],\n    [201, 104, 165, 255],\n    [134, 209, 96, 255],\n    [89, 95, 216, 255],\n    [223, 117, 82, 255],\n    [75, 230, 159, 255],\n    [174, 121, 184, 255],\n    [182, 191, 114, 255],\n    [107, 160, 198, 255],\n    [206, 99, 130, 255],\n    [92, 213, 92, 255],\n    [124, 85, 220, 255],\n    [227, 165, 78, 255],\n    [71, 234, 214, 255],\n    [188, 117, 176, 255],\n    [156, 195, 110, 255],\n    [103, 128, 202, 255],\n    [210, 100, 95, 255],\n    [88, 217, 131, 255],\n    [170, 81, 224, 255],\n    [231, 218, 74, 255],\n    [120, 172, 185, 255],\n    [192, 113, 153, 255],\n    [125, 199, 106, 255],\n    [107, 98, 207, 255],\n    [214, 137, 91, 255],\n    [84, 221, 175, 255],\n    [222, 77, 228, 255],\n    [194, 235, 70, 255],\n    [116, 149, 189, 255],\n    [196, 109, 123, 255],\n    [101, 204, 114, 255],\n    [143, 94, 211, 255],\n    [218, 180, 87, 255],\n    [80, 225, 225, 255],\n    [232, 73, 186, 255],\n    [147, 186, 119, 255],\n    [112, 122, 193, 255],\n    [200, 121, 105, 255],\n    [97, 208, 148, 255],\n    [184, 90, 215, 255],\n    [216, 222, 83, 255],\n    [76, 178, 229, 255],\n    [183, 122, 145, 255],\n    [121, 190, 115, 255],\n    [126, 108, 197, 255],\n    [205, 153, 100, 255],\n    [93, 212, 187, 255],\n    [219, 86, 208, 255],\n    [171, 226, 79, 255],\n    [72, 126, 233, 255],\n    [187, 118, 121, 255],\n    [111, 194, 132, 255],\n    [157, 104, 201, 255],\n    [209, 190, 96, 255],\n    [89, 200, 216, 255],\n    [223, 82, 164, 255],\n    [120, 230, 75, 255],\n    [121, 121, 184, 255],\n    [191, 136, 114, 255],\n    [107, 198, 160, 255],\n    [192, 99, 206, 255],\n    [193, 213, 92, 255],\n    [85, 158, 220, 255],\n    [227, 78, 115, 255],\n    [71, 234, 78, 255],\n    [141, 117, 188, 255],\n    [195, 163, 110, 255],\n    [103, 202, 194, 255],\n    [210, 95, 186, 255],\n    [153, 217, 88, 255],\n    [81, 111, 224, 255],\n];\nexport default CORNERSTONE_COLOR_LUT;\n","const DEFINED_CURSORS = Symbol('DefinedCursors');\nconst STANDARD_CURSORS = new Set([\n    'alias',\n    'all-scroll',\n    'auto',\n    'cell',\n    'col-resize',\n    'context-menu',\n    'copy',\n    'crosshair',\n    'default',\n    'e-resize',\n    'ew-resize',\n    'grab',\n    'grabbing',\n    'help',\n    'move',\n    'ne-resize',\n    'nesw-resize',\n    'no-drop',\n    'none',\n    'not-allowed',\n    'n-resize',\n    'ns-resize',\n    'nw-resize',\n    'nwse-resize',\n    'pointer',\n    'progress',\n    'row-resize',\n    'se-resize',\n    's-resize',\n    'sw-resize',\n    'text',\n    'vertical-text',\n    'wait',\n    'w-resize',\n    'zoom-in',\n    'zoom-out',\n]);\nexport default class MouseCursor {\n    constructor(name, fallback) {\n        this.name = name + '';\n        this.fallback = fallback;\n    }\n    getName() {\n        return this.name + '';\n    }\n    addFallbackStyleProperty(style) {\n        const { fallback } = this;\n        if (fallback instanceof MouseCursor) {\n            return `${style}, ${fallback.getStyleProperty()}`;\n        }\n        return style + '';\n    }\n    getStyleProperty() {\n        return this.addFallbackStyleProperty(this.name) + '';\n    }\n    static getDefinedCursor(name) {\n        const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);\n        let mouseCursor = definedCursors.get(name);\n        if (mouseCursor instanceof MouseCursor) {\n            return mouseCursor;\n        }\n        if (STANDARD_CURSORS.has(name)) {\n            mouseCursor = new MouseCursor(name);\n            definedCursors.set(name, mouseCursor);\n            return mouseCursor;\n        }\n    }\n    static setDefinedCursor(name, cursor) {\n        if (cursor instanceof MouseCursor) {\n            const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);\n            definedCursors.set(name, cursor);\n            return true;\n        }\n        return false;\n    }\n}\nfunction getDefinedCursors(context, symbol) {\n    let definedCursors = context[symbol];\n    if (!(definedCursors instanceof Map)) {\n        definedCursors = new Map();\n        Object.defineProperty(context, symbol, { value: definedCursors });\n    }\n    return definedCursors;\n}\nconst standardCursorNames = STANDARD_CURSORS.values();\nexport { standardCursorNames };\n","import MouseCursor from './MouseCursor';\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\nfunction initElementCursor(element, cursor) {\n    _getElementCursors(element)[0] = cursor;\n    _setElementCursor(element, cursor);\n}\nfunction _setElementCursor(element, cursor) {\n    const cursors = _getElementCursors(element);\n    cursors[1] = cursors[0];\n    cursors[0] = cursor;\n    element.style.cursor = (cursor instanceof MouseCursor\n        ? cursor\n        : MouseCursor.getDefinedCursor('auto')).getStyleProperty();\n}\nfunction resetElementCursor(element) {\n    _setElementCursor(element, _getElementCursors(element)[1]);\n}\nfunction hideElementCursor(element) {\n    _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\n}\nfunction _getElementCursors(element) {\n    let map = _getElementCursors[ELEMENT_CURSORS_MAP];\n    if (!(map instanceof WeakMap)) {\n        map = new WeakMap();\n        Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\n            value: map,\n        });\n    }\n    let cursors = map.get(element);\n    if (!cursors) {\n        cursors = [null, null];\n        map.set(element, cursors);\n    }\n    return cursors;\n}\nexport { initElementCursor, resetElementCursor, hideElementCursor, _setElementCursor as setElementCursor, };\n","import { utilities } from '@cornerstonejs/core';\nimport MouseCursor from './MouseCursor';\nconst DEFAULT_NAME = 'image-cursor';\nexport default class ImageMouseCursor extends MouseCursor {\n    constructor(url, x, y, name, fallback) {\n        super(name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME), fallback);\n        this.url = url;\n        this.x = Number(x) || 0;\n        this.y = Number(y) || 0;\n    }\n    getStyleProperty() {\n        const { url, x, y } = this;\n        let style = `url('${url}')`;\n        if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\n            style += ` ${x} ${y}`;\n        }\n        return this.addFallbackStyleProperty(style);\n    }\n    static getUniqueInstanceName(prefix) {\n        return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\n    }\n}\n","const BASE = {\n    iconContent: '',\n    iconSize: 16,\n    viewBox: {\n        x: 16,\n        y: 16,\n    },\n    mousePoint: {\n        x: 8,\n        y: 8,\n    },\n    mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n    x: 127,\n    y: 60,\n};\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CursorSVG = {\n    Angle: extend(BASE, {\n        name: 'Angle',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    ArrowAnnotate: extend(BASE, {\n        name: 'ArrowAnnotate',\n        iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Bidirectional: extend(BASE, {\n        name: 'Bidirectional',\n        iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n        viewBox: {\n            x: 48,\n            y: 48,\n        },\n    }),\n    CobbAngle: extend(BASE, {\n        name: 'CobbAngle',\n        iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    CircleROI: extend(BASE, {\n        name: 'CircleROI',\n        iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    EllipticalROI: extend(BASE, {\n        name: 'EllipticalROI',\n        iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    FreehandROI: extend(BASE, {\n        name: 'FreehandROI',\n        iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    FreehandROISculptor: extend(BASE, {\n        name: 'FreehandROISculptor',\n        iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    Length: extend(BASE, {\n        name: 'Length',\n        iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Height: extend(BASE, {\n        name: 'Height',\n        iconContent: `<path d=\"m 6 22 l 8.5 0 v -16 h 8\" stroke-width=\"3\" fill=\"none\" stroke=\"{{color}}\" />`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Probe: extend(BASE, {\n        name: 'Probe',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    RectangleROI: extend(BASE, {\n        name: 'RectangleROI',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    TextMarker: extend(BASE, {\n        name: 'TextMarker',\n        iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Crosshairs: extend(BASE, {\n        name: 'Crosshairs',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Eraser: extend(BASE, {\n        name: 'Eraser',\n        iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n        viewBox: {\n            x: 2048,\n            y: 1792,\n        },\n    }),\n    Magnify: extend(BASE, {\n        name: 'Magnify',\n        iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n        viewBox: {\n            x: 512,\n            y: 512,\n        },\n    }),\n    Pan: extend(BASE, {\n        name: 'Pan',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Rotate: extend(BASE, {\n        name: 'Rotate',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    StackScroll: extend(BASE, {\n        name: 'StackScroll',\n        iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n        viewBox: {\n            x: 24,\n            y: 28,\n        },\n    }),\n    WindowLevelRegion: extend(BASE, {\n        name: 'WindowLevelRegion',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    WindowLevel: extend(BASE, {\n        name: 'WindowLevel',\n        iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    Zoom: extend(BASE, {\n        name: 'Zoom',\n        iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n        viewBox: {\n            x: 640,\n            y: 512,\n        },\n    }),\n    SegmentationFreeHandEraseInside: extend(BASE, {\n        name: 'SegmentationFreeHandEraseInside',\n        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandFillInside: extend(BASE, {\n        name: 'SegmentationFreeHandFillInside',\n        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandEraseOutside: extend(BASE, {\n        name: 'SegmentationFreeHandEraseOutside',\n        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandFillOutside: extend(BASE, {\n        name: 'SegmentationFreeHandFillOutside',\n        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationRectangleEraseInside: extend(BASE, {\n        name: 'SegmentationRectangleEraseInside',\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    RectangleScissor: extend(BASE, {\n        name: 'RectangleScissor',\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.FILL_INSIDE': extend(BASE, {\n        name: 'RectangleScissor.FILL_INSIDE',\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n        name: 'RectangleScissor.FILL_OUTSIDE',\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n        name: 'RectangleScissor.ERASE_OUTSIDE',\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n        name: 'RectangleScissor.ERASE_INSIDE',\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    CircleScissor: extend(BASE, {\n        name: 'CircleScissor',\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.FILL_INSIDE': extend(BASE, {\n        name: 'CircleScissor.FILL_INSIDE',\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n        name: 'CircleScissor.ERASE_OUTSIDE',\n        iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n        name: 'CircleScissor.FILL_OUTSIDE',\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n};\nfunction extend(base, values) {\n    return Object.assign(Object.create(base), {\n        ...values,\n        name: values.name || base.name,\n    });\n}\nfunction registerCursor(toolName, iconContent, viewBox) {\n    CursorSVG[toolName] = extend(BASE, {\n        iconContent,\n        viewBox,\n    });\n}\nfunction getDefinedSVGCursorDescriptor(name) {\n    return CursorSVG[name];\n}\nconst svgCursorNames = Object.keys(CursorSVG);\nexport { getDefinedSVGCursorDescriptor, registerCursor, svgCursorNames, CursorSVG, };\n","import { ToolModes, AnnotationStyleStates } from '../enums';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\nconst PROPERTY = 'color';\nconst STATE = AnnotationStyleStates.Highlighted;\nconst MODE = ToolModes.Active;\nexport default class SVGMouseCursor extends ImageMouseCursor {\n    constructor(url, x, y, name, fallback) {\n        super(url, x, y, name, fallback);\n    }\n    static getDefinedCursor(name, pointer = false, color) {\n        if (!color) {\n            color = getStyleProperty(PROPERTY, {}, STATE, MODE);\n        }\n        const urn = getCursorURN(name, pointer, color);\n        let cursor = super.getDefinedCursor(urn);\n        if (!cursor) {\n            const descriptor = getDefinedSVGCursorDescriptor(name);\n            if (descriptor) {\n                cursor = createSVGMouseCursor(descriptor, urn, pointer, color, super.getDefinedCursor('default'));\n                super.setDefinedCursor(urn, cursor);\n            }\n        }\n        return cursor;\n    }\n}\nfunction format(template, dictionary) {\n    const dict = Object(dictionary);\n    const defined = Object.prototype.hasOwnProperty.bind(dict);\n    return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n        return defined(key) ? dict[key] + '' : '';\n    });\n}\nfunction getCursorURN(name, pointer, color) {\n    const type = pointer ? 'pointer' : 'cursor';\n    return `${type}:${name}/${color}`;\n}\nfunction createSVGMouseCursor(descriptor, name, pointer, color, fallback) {\n    const { x, y } = descriptor.mousePoint;\n    return new SVGMouseCursor(createSVGIconUrl(descriptor, pointer, { color }), x, y, name, fallback);\n}\nfunction createSVGIconUrl(descriptor, pointer, options) {\n    const blob = createSVGIconBlob(descriptor, pointer, options);\n    const url = URL.createObjectURL(blob);\n    const urn = `${url}#${descriptor.name || 'unknown'}-${pointer ? 'pointer' : 'cursor'}`;\n    return urn;\n}\nfunction createSVGIconBlob(descriptor, pointer, options) {\n    const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(descriptor, options);\n    return new Blob([svgString], { type: 'image/svg+xml' });\n}\nfunction createSVGIcon(descriptor, options) {\n    const { iconContent, iconSize, viewBox } = descriptor;\n    const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\n      ${viewBox.x} ${viewBox.y}\">\n      ${iconContent}\n    </svg>`;\n    return format(svgString, options);\n}\nfunction createSVGIconWithPointer(descriptor, options) {\n    const { iconContent, iconSize, viewBox, mousePointerGroupString } = descriptor;\n    const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\n    const svgSize = 16 + iconSize;\n    const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\n      <g>${mousePointerGroupString}</g>\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\n    </svg>`;\n    return format(svgString, options);\n}\n","import MouseCursor, { standardCursorNames } from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nimport * as elementCursor from './elementCursor';\nimport setCursorForElement from './setCursorForElement';\nimport { registerCursor, svgCursorNames, CursorSVG, } from './SVGCursorDescriptor';\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\nexport { MouseCursor, ImageMouseCursor, SVGMouseCursor, elementCursor, registerCursor, CursorNames, CursorSVG, setCursorForElement, };\n","import { state } from '../store/state';\nimport { getEnabledElement } from '@cornerstonejs/core';\nconst VIEWPORT_ELEMENT = 'viewport-element';\nfunction getSvgDrawingHelper(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId, renderingEngineId } = enabledElement;\n    const canvasHash = `${viewportId}:${renderingEngineId}`;\n    const svgLayerElement = _getSvgLayer(element);\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        state.svgNodeCache[canvasHash][cacheKey].touched = false;\n    });\n    return {\n        svgLayerElement: svgLayerElement,\n        svgNodeCacheForCanvas: state.svgNodeCache,\n        getSvgNode: getSvgNode.bind(this, canvasHash),\n        appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n        setNodeTouched: setNodeTouched.bind(this, canvasHash),\n        clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n    };\n}\nfunction _getSvgLayer(element) {\n    const viewportElement = `.${VIEWPORT_ELEMENT}`;\n    const internalDivElement = element.querySelector(viewportElement);\n    const svgLayer = internalDivElement?.querySelector(':scope > .svg-layer');\n    return svgLayer;\n}\nfunction getSvgNode(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        return state.svgNodeCache[canvasHash][cacheKey].domRef;\n    }\n}\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return null;\n    }\n    state.svgNodeCache[canvasHash][cacheKey] = {\n        touched: true,\n        domRef: svgNode,\n    };\n    svgLayerElement.appendChild(svgNode);\n}\nfunction setNodeTouched(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        state.svgNodeCache[canvasHash][cacheKey].touched = true;\n    }\n}\nfunction clearUntouched(svgLayerElement, canvasHash) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n        if (!cacheEntry.touched && cacheEntry.domRef) {\n            svgLayerElement.removeChild(cacheEntry.domRef);\n            delete state.svgNodeCache[canvasHash][cacheKey];\n        }\n    });\n}\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\nfunction draw(element, fn) {\n    const svgDrawingHelper = getSvgDrawingHelper(element);\n    fn(svgDrawingHelper);\n    svgDrawingHelper.clearUntouched();\n}\nexport default draw;\n","export function setAttributesIfNecessary(attributes, svgNode) {\n    Object.keys(attributes).forEach((key) => {\n        const currentValue = svgNode.getAttribute(key);\n        const newValue = attributes[key];\n        if (newValue === undefined || newValue === '') {\n            svgNode.removeAttribute(key);\n        }\n        else if (currentValue !== newValue) {\n            svgNode.setAttribute(key, newValue);\n        }\n    });\n}\nexport default setAttributesIfNecessary;\n","export function setNewAttributesIfValid(attributes, svgNode) {\n    Object.keys(attributes).forEach((key) => {\n        const newValue = attributes[key];\n        if (newValue !== undefined && newValue !== '') {\n            svgNode.setAttribute(key, newValue);\n        }\n    });\n}\nexport default setNewAttributesIfValid;\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}, dataId = '') {\n    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        fill: 'transparent',\n        width: '2',\n        lineDash: undefined,\n        lineWidth: undefined,\n        strokeOpacity: 1,\n        fillOpacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n    const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        r: `${radius}`,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'fill-opacity': fillOpacity,\n        'stroke-opacity': strokeOpacity,\n    };\n    if (existingCircleElement) {\n        setAttributesIfNecessary(attributes, existingCircleElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newCircleElement = document.createElementNS(svgns, 'circle');\n        if (dataId !== '') {\n            newCircleElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, newCircleElement);\n        svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n    }\n}\nexport default drawCircle;\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, options = {}, dataId = '') {\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n    const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const [bottom, top, left, right] = canvasCoordinates;\n    const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n    const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n    const angle = (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;\n    const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n    const radiusX = w / 2;\n    const radiusY = h / 2;\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        rx: `${radiusX}`,\n        ry: `${radiusY}`,\n        stroke: color,\n        fill: 'transparent',\n        transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingEllipse) {\n        setAttributesIfNecessary(attributes, existingEllipse);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n        if (dataId !== '') {\n            svgEllipseElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, svgEllipseElement);\n        svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n    }\n}\nexport default drawEllipseByCoordinates;\n","import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nfunction drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options = {}, uniqueIndex) {\n    const { color, handleRadius, width, lineWidth, fill, type, opacity } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        handleRadius: '6',\n        width: '2',\n        lineWidth: undefined,\n        fill: 'transparent',\n        type: 'circle',\n        opacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'handle', `hg-${handleGroupUID}-index-${uniqueIndex}`);\n    let attributes;\n    if (type === 'circle') {\n        attributes = {\n            cx: `${handle[0]}`,\n            cy: `${handle[1]}`,\n            r: handleRadius,\n            stroke: color,\n            fill,\n            'stroke-width': strokeWidth,\n            opacity: opacity,\n        };\n    }\n    else if (type === 'rect') {\n        const handleRadiusFloat = parseFloat(handleRadius);\n        const side = handleRadiusFloat * 1.5;\n        const x = handle[0] - side * 0.5;\n        const y = handle[1] - side * 0.5;\n        attributes = {\n            x: `${x}`,\n            y: `${y}`,\n            width: `${side}`,\n            height: `${side}`,\n            stroke: color,\n            fill,\n            'stroke-width': strokeWidth,\n            rx: `${side * 0.1}`,\n            opacity: opacity,\n        };\n    }\n    else {\n        throw new Error(`Unsupported handle type: ${type}`);\n    }\n    const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    if (existingHandleElement) {\n        setAttributesIfNecessary(attributes, existingHandleElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newHandleElement = document.createElementNS(svgns, type);\n        setNewAttributesIfValid(attributes, newHandleElement);\n        svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\n    }\n}\nexport default drawHandle;\n","import drawHandle from './drawHandle';\nfunction drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {\n    handlePoints.forEach((handle, i) => {\n        drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options, i);\n    });\n}\nexport default drawHandles;\n","import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nexport default function drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, options = {}, dataId = '') {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash, shadow } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n        shadow: undefined,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\n    const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const dropShadowStyle = shadow\n        ? `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`\n        : '';\n    const attributes = {\n        x1: `${start[0]}`,\n        y1: `${start[1]}`,\n        x2: `${end[0]}`,\n        y2: `${end[1]}`,\n        stroke: color,\n        style: dropShadowStyle,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingLine) {\n        setAttributesIfNecessary(attributes, existingLine);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newLine = document.createElementNS(svgns, 'line');\n        if (dataId !== '') {\n            newLine.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, newLine);\n        svgDrawingHelper.appendNode(newLine, svgNodeHash);\n    }\n}\n","import drawLine from './drawLine';\nexport default function drawHeight(svgDrawingHelper, annotationUID, heightUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const midX = end[0] + (start[0] - end[0]) / 2;\n    const endfirstLine = [midX, start[1]];\n    const endsecondLine = [midX, end[1]];\n    const firstLine = {\n        start: start,\n        end: endfirstLine,\n    };\n    const secondLine = {\n        start: endfirstLine,\n        end: endsecondLine,\n    };\n    const threeLine = {\n        start: endsecondLine,\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, '1', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '2', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', threeLine.start, threeLine.end, {\n        color,\n        width,\n        lineWidth,\n    });\n}\n","import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nexport default function drawPolyline(svgDrawingHelper, annotationUID, polylineUID, points, options) {\n    if (points.length < 2) {\n        return;\n    }\n    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, } = options;\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n    const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n    let pointsAttribute = '';\n    for (const point of points) {\n        pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;\n    }\n    if (closePath) {\n        const firstPoint = points[0];\n        pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n    }\n    const attributes = {\n        points: pointsAttribute,\n        stroke: color,\n        fill: fillColor,\n        'fill-opacity': fillOpacity,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingPolyLine) {\n        setAttributesIfNecessary(attributes, existingPolyLine);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newPolyLine = document.createElementNS(svgns, 'polyline');\n        setNewAttributesIfValid(attributes, newPolyLine);\n        svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n    }\n}\n","import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nexport default function drawPath(svgDrawingHelper, annotationUID, pathUID, points, options) {\n    const hasSubArrays = points.length && points[0].length && Array.isArray(points[0][0]);\n    const pointsArrays = hasSubArrays ? points : [points];\n    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, } = options;\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'path', pathUID);\n    const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);\n    let pointsAttribute = '';\n    for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {\n        const points = pointsArrays[i];\n        const numPoints = points.length;\n        if (numPoints < 2) {\n            continue;\n        }\n        for (let j = 0; j < numPoints; j++) {\n            const point = points[j];\n            const cmd = j ? 'L' : 'M';\n            pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;\n        }\n        if (closePath) {\n            pointsAttribute += 'Z ';\n        }\n    }\n    if (!pointsAttribute) {\n        return;\n    }\n    const attributes = {\n        d: pointsAttribute,\n        stroke: color,\n        fill: fillColor,\n        'fill-opacity': fillOpacity,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingNode) {\n        setAttributesIfNecessary(attributes, existingNode);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newNode = document.createElementNS(svgns, 'path');\n        setNewAttributesIfValid(attributes, newNode);\n        svgDrawingHelper.appendNode(newNode, svgNodeHash);\n    }\n}\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nfunction drawTextBox(svgDrawingHelper, annotationUID, textUID, textLines, position, options = {}) {\n    const mergedOptions = Object.assign({\n        fontFamily: 'Helvetica, Arial, sans-serif',\n        fontSize: '14px',\n        color: 'rgb(255, 255, 0)',\n        background: '',\n        padding: 25,\n        centerX: false,\n        centerY: true,\n    }, options);\n    const textGroupBoundingBox = _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines, position, mergedOptions);\n    return textGroupBoundingBox;\n}\nfunction _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines = [''], position, options) {\n    const { padding, color, fontFamily, fontSize, background } = options;\n    let textGroupBoundingBox;\n    const [x, y] = [position[0] + padding, position[1] + padding];\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'text', textUID);\n    const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\n    if (existingTextGroup) {\n        const textElement = existingTextGroup.querySelector('text');\n        const textSpans = Array.from(textElement.children);\n        for (let i = 0; i < textSpans.length; i++) {\n            const textSpanElement = textSpans[i];\n            const text = textLines[i] || '';\n            textSpanElement.textContent = text;\n        }\n        if (textLines.length > textSpans.length) {\n            for (let i = 0; i < textLines.length - textSpans.length; i++) {\n                const textLine = textLines[i + textSpans.length];\n                const textSpan = _createTextSpan(textLine);\n                textElement.appendChild(textSpan);\n            }\n            existingTextGroup.appendChild(textElement);\n            svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\n        }\n        const textAttributes = {\n            fill: color,\n            'font-size': fontSize,\n            'font-family': fontFamily,\n        };\n        const textGroupAttributes = {\n            transform: `translate(${x} ${y})`,\n        };\n        setAttributesIfNecessary(textAttributes, textElement);\n        setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\n        textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const textGroup = document.createElementNS(svgns, 'g');\n        textGroup.setAttribute('transform', `translate(${x} ${y})`);\n        const textElement = _createTextElement(svgDrawingHelper, options);\n        for (let i = 0; i < textLines.length; i++) {\n            const textLine = textLines[i];\n            const textSpan = _createTextSpan(textLine);\n            textElement.appendChild(textSpan);\n        }\n        textGroup.appendChild(textElement);\n        svgDrawingHelper.appendNode(textGroup, svgNodeHash);\n        textGroupBoundingBox = _drawTextBackground(textGroup, background);\n    }\n    return Object.assign({}, textGroupBoundingBox, {\n        x,\n        y,\n        height: textGroupBoundingBox.height + padding,\n        width: textGroupBoundingBox.width + padding,\n    });\n}\nfunction _createTextElement(svgDrawingHelper, options) {\n    const { color, fontFamily, fontSize } = options;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const textElement = document.createElementNS(svgns, 'text');\n    const noSelectStyle = 'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\n    const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\n    const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\n    textElement.setAttribute('x', '0');\n    textElement.setAttribute('y', '0');\n    textElement.setAttribute('fill', color);\n    textElement.setAttribute('font-family', fontFamily);\n    textElement.setAttribute('font-size', fontSize);\n    textElement.setAttribute('style', combinedStyle);\n    return textElement;\n}\nfunction _createTextSpan(text) {\n    const svgns = 'http://www.w3.org/2000/svg';\n    const textSpanElement = document.createElementNS(svgns, 'tspan');\n    textSpanElement.setAttribute('x', '0');\n    textSpanElement.setAttribute('dy', '1.2em');\n    textSpanElement.textContent = text;\n    return textSpanElement;\n}\nfunction _drawTextBackground(group, color) {\n    let element = group.querySelector('rect.background');\n    if (!color) {\n        if (element) {\n            group.removeChild(element);\n        }\n        return group.getBBox();\n    }\n    if (!element) {\n        element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        element.setAttribute('class', 'background');\n        group.insertBefore(element, group.firstChild);\n    }\n    const bBox = group.getBBox();\n    const attributes = {\n        x: `${bBox.x}`,\n        y: `${bBox.y}`,\n        width: `${bBox.width}`,\n        height: `${bBox.height}`,\n        fill: color,\n    };\n    setAttributesIfNecessary(attributes, element);\n    return bBox;\n}\nexport default drawTextBox;\n","import drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nfunction drawLink(svgDrawingHelper, annotationUID, linkUID, annotationAnchorPoints, refPoint, boundingBox, options = {}) {\n    const start = annotationAnchorPoints.length > 0\n        ? findClosestPoint(annotationAnchorPoints, refPoint)\n        : refPoint;\n    const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n    const end = findClosestPoint(boundingBoxPoints, start);\n    const mergedOptions = Object.assign({\n        color: 'rgb(255, 255, 0)',\n        lineWidth: '1',\n        lineDash: '2,3',\n    }, options);\n    drawLine(svgDrawingHelper, annotationUID, `link-${linkUID}`, start, end, mergedOptions);\n}\nfunction _boundingBoxPoints(boundingBox) {\n    const { x: left, y: top, height, width } = boundingBox;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const topMiddle = [left + halfWidth, top];\n    const leftMiddle = [left, top + halfHeight];\n    const bottomMiddle = [left + halfWidth, top + height];\n    const rightMiddle = [left + width, top + halfHeight];\n    return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\nexport default drawLink;\n","import drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nfunction drawLinkedTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, annotationAnchorPoints, textBox, options = {}) {\n    const mergedOptions = Object.assign({\n        handleRadius: '6',\n        centering: {\n            x: false,\n            y: true,\n        },\n    }, options);\n    const canvasBoundingBox = drawTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, mergedOptions);\n    drawLink(svgDrawingHelper, annotationUID, textBoxUID, annotationAnchorPoints, textBoxPosition, canvasBoundingBox, mergedOptions);\n    return canvasBoundingBox;\n}\nexport default drawLinkedTextBox;\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nexport default function drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, options = {}, dataId = '') {\n    const { color, width: _width, lineWidth, lineDash, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || _width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const [topLeft, topRight, bottomLeft, bottomRight] = canvasCoordinates;\n    const width = Math.hypot(topLeft[0] - topRight[0], topLeft[1] - topRight[1]);\n    const height = Math.hypot(topLeft[0] - bottomLeft[0], topLeft[1] - bottomLeft[1]);\n    const center = [\n        (bottomRight[0] + topLeft[0]) / 2,\n        (bottomRight[1] + topLeft[1]) / 2,\n    ];\n    const leftEdgeCenter = [\n        (bottomLeft[0] + topLeft[0]) / 2,\n        (bottomLeft[1] + topLeft[1]) / 2,\n    ];\n    const angle = (Math.atan2(center[1] - leftEdgeCenter[1], center[0] - leftEdgeCenter[0]) *\n        180) /\n        Math.PI;\n    const attributes = {\n        x: `${center[0] - width / 2}`,\n        y: `${center[1] - height / 2}`,\n        width: `${width}`,\n        height: `${height}`,\n        stroke: color,\n        fill: 'transparent',\n        transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingRect) {\n        setAttributesIfNecessary(attributes, existingRect);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgRectElement = document.createElementNS(svgns, 'rect');\n        if (dataId !== '') {\n            svgRectElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, svgRectElement);\n        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n    }\n}\n","import _getHash from './_getHash';\nimport drawRectByCoordinates from './drawRectByCoordinates';\nexport default function drawRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}, dataId = '') {\n    const topLeft = [start[0], start[1]];\n    const topRight = [end[0], start[1]];\n    const bottomLeft = [start[0], end[1]];\n    const bottomRight = [end[0], end[1]];\n    drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, [topLeft, topRight, bottomLeft, bottomRight], options, dataId);\n}\n","import drawLine from './drawLine';\nexport default function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    const headLength = 10;\n    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n    const firstLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle - Math.PI / 7),\n            end[1] - headLength * Math.sin(angle - Math.PI / 7),\n        ],\n        end: end,\n    };\n    const secondLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle + Math.PI / 7),\n            end[1] - headLength * Math.sin(angle + Math.PI / 7),\n        ],\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, '2', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n    });\n}\n","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\nexport default function drawRedactionRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}) {\n    const { color, width: _width, lineWidth, lineDash, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || _width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n    const width = Math.abs(start[0] - end[0]);\n    const height = Math.abs(start[1] - end[1]);\n    const attributes = {\n        x: `${tlhc[0]}`,\n        y: `${tlhc[1]}`,\n        width: `${width}`,\n        height: `${height}`,\n        stroke: color,\n        fill: 'black',\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingRect) {\n        _setAttributesIfNecessary(attributes, existingRect);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgRectElement = document.createElementNS(svgns, 'rect');\n        _setNewAttributesIfValid(attributes, svgRectElement);\n        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n    }\n}\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"Interaction\"] = \"Interaction\";\n    ChangeTypes[\"HandlesUpdated\"] = \"HandlesUpdated\";\n    ChangeTypes[\"StatsUpdated\"] = \"StatsUpdated\";\n    ChangeTypes[\"InitialSetup\"] = \"InitialSetup\";\n    ChangeTypes[\"Completed\"] = \"Completed\";\n    ChangeTypes[\"InterpolationUpdated\"] = \"InterpolationUpdated\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","var Events;\n(function (Events) {\n    Events[\"TOOL_ACTIVATED\"] = \"CORNERSTONE_TOOLS_TOOL_ACTIVATED\";\n    Events[\"TOOLGROUP_VIEWPORT_ADDED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED\";\n    Events[\"TOOLGROUP_VIEWPORT_REMOVED\"] = \"CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED\";\n    Events[\"TOOL_MODE_CHANGED\"] = \"CORNERSTONE_TOOLS_TOOL_MODE_CHANGED\";\n    Events[\"ANNOTATION_ADDED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_ADDED\";\n    Events[\"ANNOTATION_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_COMPLETED\";\n    Events[\"ANNOTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_MODIFIED\";\n    Events[\"ANNOTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_REMOVED\";\n    Events[\"ANNOTATION_SELECTION_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE\";\n    Events[\"ANNOTATION_LOCK_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE\";\n    Events[\"ANNOTATION_VISIBILITY_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE\";\n    Events[\"ANNOTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_RENDERED\";\n    Events[\"ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED\";\n    Events[\"INTERPOLATED_ANNOTATIONS_REMOVED\"] = \"CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED\";\n    Events[\"SEGMENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_RENDERED\";\n    Events[\"SEGMENTATION_REPRESENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED\";\n    Events[\"SEGMENTATION_ADDED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_ADDED\";\n    Events[\"SEGMENTATION_REPRESENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REMOVED\";\n    Events[\"SEGMENTATION_REPRESENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED\";\n    Events[\"SEGMENTATION_DATA_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED\";\n    Events[\"KEY_DOWN\"] = \"CORNERSTONE_TOOLS_KEY_DOWN\";\n    Events[\"KEY_UP\"] = \"CORNERSTONE_TOOLS_KEY_UP\";\n    Events[\"MOUSE_DOWN\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN\";\n    Events[\"MOUSE_UP\"] = \"CORNERSTONE_TOOLS_MOUSE_UP\";\n    Events[\"MOUSE_DOWN_ACTIVATE\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE\";\n    Events[\"MOUSE_DRAG\"] = \"CORNERSTONE_TOOLS_MOUSE_DRAG\";\n    Events[\"MOUSE_MOVE\"] = \"CORNERSTONE_TOOLS_MOUSE_MOVE\";\n    Events[\"MOUSE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_CLICK\";\n    Events[\"MOUSE_DOUBLE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK\";\n    Events[\"MOUSE_WHEEL\"] = \"CORNERSTONE_TOOLS_MOUSE_WHEEL\";\n    Events[\"TOUCH_START\"] = \"CORNERSTONE_TOOLS_TOUCH_START\";\n    Events[\"TOUCH_START_ACTIVATE\"] = \"CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE\";\n    Events[\"TOUCH_PRESS\"] = \"CORNERSTONE_TOOLS_TOUCH_PRESS\";\n    Events[\"TOUCH_DRAG\"] = \"CORNERSTONE_TOOLS_TOUCH_DRAG\";\n    Events[\"TOUCH_END\"] = \"CORNERSTONE_TOOLS_TOUCH_END\";\n    Events[\"TOUCH_TAP\"] = \"CORNERSTONE_TOOLS_TAP\";\n    Events[\"TOUCH_SWIPE\"] = \"CORNERSTONE_TOOLS_SWIPE\";\n})(Events || (Events = {}));\nexport default Events;\n","var StrategyCallbacks;\n(function (StrategyCallbacks) {\n    StrategyCallbacks[\"OnInteractionStart\"] = \"onInteractionStart\";\n    StrategyCallbacks[\"OnInteractionEnd\"] = \"onInteractionEnd\";\n    StrategyCallbacks[\"Preview\"] = \"preview\";\n    StrategyCallbacks[\"RejectPreview\"] = \"rejectPreview\";\n    StrategyCallbacks[\"AcceptPreview\"] = \"acceptPreview\";\n    StrategyCallbacks[\"Fill\"] = \"fill\";\n    StrategyCallbacks[\"StrategyFunction\"] = \"strategyFunction\";\n    StrategyCallbacks[\"CreateIsInThreshold\"] = \"createIsInThreshold\";\n    StrategyCallbacks[\"Initialize\"] = \"initialize\";\n    StrategyCallbacks[\"INTERNAL_setValue\"] = \"setValue\";\n    StrategyCallbacks[\"ComputeInnerCircleRadius\"] = \"computeInnerCircleRadius\";\n})(StrategyCallbacks || (StrategyCallbacks = {}));\nexport default StrategyCallbacks;\n","var ToolModes;\n(function (ToolModes) {\n    ToolModes[\"Active\"] = \"Active\";\n    ToolModes[\"Passive\"] = \"Passive\";\n    ToolModes[\"Enabled\"] = \"Enabled\";\n    ToolModes[\"Disabled\"] = \"Disabled\";\n})(ToolModes || (ToolModes = {}));\nexport default ToolModes;\n","var Swipe;\n(function (Swipe) {\n    Swipe[\"UP\"] = \"UP\";\n    Swipe[\"DOWN\"] = \"DOWN\";\n    Swipe[\"LEFT\"] = \"LEFT\";\n    Swipe[\"RIGHT\"] = \"RIGHT\";\n})(Swipe || (Swipe = {}));\nexport { Swipe };\n","var AnnotationStyleStates;\n(function (AnnotationStyleStates) {\n    AnnotationStyleStates[\"Default\"] = \"\";\n    AnnotationStyleStates[\"Highlighted\"] = \"Highlighted\";\n    AnnotationStyleStates[\"Selected\"] = \"Selected\";\n    AnnotationStyleStates[\"Locked\"] = \"Locked\";\n    AnnotationStyleStates[\"AutoGenerated\"] = \"AutoGenerated\";\n})(AnnotationStyleStates || (AnnotationStyleStates = {}));\nexport default AnnotationStyleStates;\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_LABELMAP\"] = \"Converting Contour to Labelmap\";\n    ChangeTypes[\"POLYSEG_SURFACE_TO_LABELMAP\"] = \"Converting Surfaces to Labelmap\";\n    ChangeTypes[\"POLYSEG_CONTOUR_TO_SURFACE\"] = \"Converting Contour to Surface\";\n    ChangeTypes[\"POLYSEG_LABELMAP_TO_SURFACE\"] = \"Converting Labelmap to Surface\";\n    ChangeTypes[\"SURFACE_CLIPPING\"] = \"Clipping Surfaces\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","import { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport getViewportsForAnnotation from '../../../utilities/getViewportsForAnnotation';\nimport * as math from '../../../utilities/math';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getViewportIdsWithToolToRender } from '../../../utilities/viewportFilters';\nimport { addAnnotation, removeAnnotation, getAllAnnotations, getChildAnnotations, addChildAnnotation, clearParentAnnotation, } from '../../../stateManagement/annotation/annotationState';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport { addContourSegmentationAnnotation, areSameSegment, isContourSegmentationAnnotation, removeContourSegmentationAnnotation, } from '../../../utilities/contourSegmentation';\nimport { getToolGroupForViewport } from '../../../store/ToolGroupManager';\nimport { hasTool, hasToolByName } from '../../../store/addTool';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nexport default async function contourSegmentationCompletedListener(evt) {\n    const sourceAnnotation = evt.detail\n        .annotation;\n    if (!isContourSegmentationAnnotation(sourceAnnotation)) {\n        return;\n    }\n    const viewport = getViewport(sourceAnnotation);\n    const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(viewport, sourceAnnotation);\n    if (!contourSegmentationAnnotations.length) {\n        return;\n    }\n    const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);\n    const targetAnnotationInfo = findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations);\n    if (!targetAnnotationInfo) {\n        return;\n    }\n    const { targetAnnotation, targetPolyline, isContourHole } = targetAnnotationInfo;\n    if (isContourHole) {\n        const { contourHoleProcessingEnabled = false } = evt.detail;\n        if (!contourHoleProcessingEnabled) {\n            return;\n        }\n        createPolylineHole(viewport, targetAnnotation, sourceAnnotation);\n    }\n    else {\n        combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);\n    }\n}\nfunction isFreehandContourSegToolRegisteredForViewport(viewport, silent = false) {\n    const toolName = 'PlanarFreehandContourSegmentationTool';\n    const toolGroup = getToolGroupForViewport(viewport.id, viewport.renderingEngineId);\n    let errorMessage;\n    if (!toolGroup.hasTool(toolName)) {\n        errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;\n    }\n    else if (!toolGroup.getToolOptions(toolName)) {\n        errorMessage = `Tool ${toolName} must be in active/passive state`;\n    }\n    if (errorMessage && !silent) {\n        console.warn(errorMessage);\n    }\n    return !errorMessage;\n}\nfunction getViewport(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    const viewportWithToolRegistered = viewports.find((viewport) => isFreehandContourSegToolRegisteredForViewport(viewport, true));\n    return viewportWithToolRegistered ?? viewports[0];\n}\nfunction convertContourPolylineToCanvasSpace(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n    }\n    return projectedPolyline;\n}\nfunction getValidContourSegmentationAnnotations(viewport, sourceAnnotation) {\n    const { annotationUID: sourceAnnotationUID } = sourceAnnotation;\n    const allAnnotations = getAllAnnotations();\n    return allAnnotations.filter((targetAnnotation) => targetAnnotation.annotationUID &&\n        targetAnnotation.annotationUID !== sourceAnnotationUID &&\n        isContourSegmentationAnnotation(targetAnnotation) &&\n        areSameSegment(targetAnnotation, sourceAnnotation) &&\n        viewport.isReferenceViewable(targetAnnotation.metadata));\n}\nfunction findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations) {\n    const sourceAABB = math.polyline.getAABB(sourcePolyline);\n    for (let i = 0; i < contourSegmentationAnnotations.length; i++) {\n        const targetAnnotation = contourSegmentationAnnotations[i];\n        const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);\n        const targetAABB = math.polyline.getAABB(targetPolyline);\n        const aabbIntersect = math.aabb.intersectAABB(sourceAABB, targetAABB);\n        const lineSegmentsIntersect = aabbIntersect &&\n            math.polyline.intersectPolyline(sourcePolyline, targetPolyline);\n        const isContourHole = aabbIntersect &&\n            !lineSegmentsIntersect &&\n            math.polyline.containsPoints(targetPolyline, sourcePolyline);\n        if (lineSegmentsIntersect || isContourHole) {\n            return { targetAnnotation, targetPolyline, isContourHole };\n        }\n    }\n}\nexport function createPolylineHole(viewport, targetAnnotation, holeAnnotation) {\n    const { windingDirection: targetWindingDirection } = targetAnnotation.data.contour;\n    const { windingDirection: holeWindingDirection } = holeAnnotation.data.contour;\n    addChildAnnotation(targetAnnotation, holeAnnotation);\n    removeContourSegmentationAnnotation(holeAnnotation);\n    const { contour: holeContour } = holeAnnotation.data;\n    const holePolyline = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);\n    updateContourPolyline(holeAnnotation, {\n        points: holePolyline,\n        closed: holeContour.closed,\n    }, viewport);\n    const { element } = viewport;\n    const updatedToolNames = new Set([\n        DEFAULT_CONTOUR_SEG_TOOL_NAME,\n        targetAnnotation.metadata.toolName,\n        holeAnnotation.metadata.toolName,\n    ]);\n    for (const toolName of updatedToolNames.values()) {\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, toolName);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n}\nfunction getContourHolesData(viewport, annotation) {\n    return getChildAnnotations(annotation).map((holeAnnotation) => {\n        const polyline = convertContourPolylineToCanvasSpace(holeAnnotation.data.contour.polyline, viewport);\n        return { annotation: holeAnnotation, polyline };\n    });\n}\nfunction combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline) {\n    if (!hasToolByName(DEFAULT_CONTOUR_SEG_TOOL_NAME)) {\n        console.warn(`${DEFAULT_CONTOUR_SEG_TOOL_NAME} is not registered in cornerstone`);\n        return;\n    }\n    if (!isFreehandContourSegToolRegisteredForViewport(viewport)) {\n        return;\n    }\n    const sourceStartPoint = sourcePolyline[0];\n    const mergePolylines = math.polyline.containsPoint(targetPolyline, sourceStartPoint);\n    const contourHolesData = getContourHolesData(viewport, targetAnnotation);\n    const unassignedContourHolesSet = new Set(contourHolesData);\n    const reassignedContourHolesMap = new Map();\n    const assignHoleToPolyline = (parentPolyline, holeData) => {\n        let holes = reassignedContourHolesMap.get(parentPolyline);\n        if (!holes) {\n            holes = [];\n            reassignedContourHolesMap.set(parentPolyline, holes);\n        }\n        holes.push(holeData);\n        unassignedContourHolesSet.delete(holeData);\n    };\n    const newPolylines = [];\n    if (mergePolylines) {\n        const mergedPolyline = math.polyline.mergePolylines(targetPolyline, sourcePolyline);\n        newPolylines.push(mergedPolyline);\n        Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => assignHoleToPolyline(mergedPolyline, holeData));\n    }\n    else {\n        const subtractedPolylines = math.polyline.subtractPolylines(targetPolyline, sourcePolyline);\n        subtractedPolylines.forEach((newPolyline) => {\n            newPolylines.push(newPolyline);\n            Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {\n                const containsHole = math.polyline.containsPoints(newPolyline, holeData.polyline);\n                if (containsHole) {\n                    assignHoleToPolyline(newPolyline, holeData);\n                    unassignedContourHolesSet.delete(holeData);\n                }\n            });\n        });\n    }\n    Array.from(reassignedContourHolesMap.values()).forEach((contourHolesDataArray) => contourHolesDataArray.forEach((contourHoleData) => clearParentAnnotation(contourHoleData.annotation)));\n    const { element } = viewport;\n    const enabledElement = getEnabledElement(element);\n    const { metadata, data } = targetAnnotation;\n    const { handles, segmentation } = data;\n    const { textBox } = handles;\n    removeAnnotation(sourceAnnotation.annotationUID);\n    removeAnnotation(targetAnnotation.annotationUID);\n    for (let i = 0; i < newPolylines.length; i++) {\n        const polyline = newPolylines[i];\n        const startPoint = viewport.canvasToWorld(polyline[0]);\n        const endPoint = viewport.canvasToWorld(polyline[polyline.length - 1]);\n        const newAnnotation = {\n            metadata: {\n                ...metadata,\n                toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,\n                originalToolName: metadata.originalToolName || metadata.toolName,\n            },\n            data: {\n                cachedStats: {},\n                handles: {\n                    points: [startPoint, endPoint],\n                    textBox: textBox ? { ...textBox } : undefined,\n                },\n                contour: {\n                    polyline: [],\n                    closed: true,\n                },\n                spline: targetAnnotation.data.spline,\n                segmentation: {\n                    ...segmentation,\n                },\n            },\n            annotationUID: csUtils.uuidv4(),\n            highlighted: true,\n            invalidated: true,\n            isLocked: false,\n            isVisible: undefined,\n            interpolationUID: targetAnnotation.interpolationUID,\n            interpolationCompleted: targetAnnotation.interpolationCompleted,\n        };\n        updateContourPolyline(newAnnotation, {\n            points: polyline,\n            closed: true,\n            targetWindingDirection: ContourWindingDirection.Clockwise,\n        }, viewport);\n        addAnnotation(newAnnotation, element);\n        addContourSegmentationAnnotation(newAnnotation);\n        triggerAnnotationModified(newAnnotation, viewport.element);\n        reassignedContourHolesMap\n            .get(polyline)\n            ?.forEach((holeData) => addChildAnnotation(newAnnotation, holeData.annotation));\n    }\n    updateViewports(enabledElement, targetAnnotation, sourceAnnotation);\n}\nfunction updateViewports(enabledElement, targetAnnotation, sourceAnnotation) {\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    const updatedTtoolNames = new Set([\n        DEFAULT_CONTOUR_SEG_TOOL_NAME,\n        targetAnnotation.metadata.toolName,\n        sourceAnnotation.metadata.toolName,\n    ]);\n    for (const toolName of updatedTtoolNames.values()) {\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, toolName);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    return new Promise((resolve) => window.requestAnimationFrame(resolve));\n}\n","import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { BaseVolumeViewport, getEnabledElement, Enums, getEnabledElementByIds, cache, utilities, } from '@cornerstonejs/core';\nimport { triggerSegmentationRender } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nimport { updateLabelmapSegmentationImageReferences } from '../../stateManagement/segmentation/updateLabelmapSegmentationImageReferences';\nimport { getCurrentLabelmapImageIdForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getLabelmapActorEntry } from '../../stateManagement/segmentation/helpers/getSegmentationActor';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nconst enable = function (element) {\n    const { viewport } = getEnabledElement(element);\n    if (viewport instanceof BaseVolumeViewport) {\n        return;\n    }\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, _imageChangeEventListener);\n    element.addEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, _imageChangeEventListener);\n    element.removeEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n};\nconst perViewportManualTriggers = new Map();\nfunction _imageChangeEventListener(evt) {\n    const eventData = evt.detail;\n    const { viewportId, renderingEngineId } = eventData;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n    const representations = getSegmentationRepresentations(viewportId);\n    if (!representations?.length) {\n        return;\n    }\n    const labelmapRepresentations = representations.filter((representation) => representation.type === SegmentationRepresentations.Labelmap);\n    const actors = viewport.getActors();\n    labelmapRepresentations.forEach((representation) => {\n        const { segmentationId } = representation;\n        updateLabelmapSegmentationImageReferences(viewportId, segmentationId);\n    });\n    const labelmapActors = labelmapRepresentations\n        .map((representation) => {\n        return getLabelmapActorEntry(viewportId, representation.segmentationId);\n    })\n        .filter((actor) => actor !== undefined);\n    if (!labelmapActors.length) {\n        return;\n    }\n    labelmapActors.forEach((actor) => {\n        const validActor = labelmapRepresentations.find((representation) => {\n            const derivedImageId = getCurrentLabelmapImageIdForViewport(viewportId, representation.segmentationId);\n            return derivedImageId === actor.referencedId;\n        });\n        if (!validActor) {\n            viewport.removeActors([actor.uid]);\n        }\n    });\n    labelmapRepresentations.forEach((representation) => {\n        const { segmentationId } = representation;\n        const currentImageId = viewport.getCurrentImageId();\n        const derivedImageId = getCurrentLabelmapImageIdForViewport(viewportId, segmentationId);\n        if (!derivedImageId) {\n            return;\n        }\n        const derivedImage = cache.getImage(derivedImageId);\n        if (!derivedImage) {\n            console.warn('No derived image found in the cache for segmentation representation', representation);\n            return;\n        }\n        const segmentationActorInput = actors.find((actor) => actor.referencedId === derivedImageId);\n        if (!segmentationActorInput) {\n            const { dimensions, spacing, direction } = viewport.getImageDataMetadata(derivedImage);\n            const currentImage = cache.getImage(currentImageId) ||\n                {\n                    imageId: currentImageId,\n                };\n            const { origin: currentOrigin } = viewport.getImageDataMetadata(currentImage);\n            const originToUse = currentOrigin;\n            const constructor = derivedImage.voxelManager.getConstructor();\n            const newPixelData = derivedImage.voxelManager.getScalarData();\n            const scalarArray = vtkDataArray.newInstance({\n                name: 'Pixels',\n                numberOfComponents: 1,\n                values: new constructor(newPixelData),\n            });\n            const imageData = vtkImageData.newInstance();\n            imageData.setDimensions(dimensions[0], dimensions[1], 1);\n            imageData.setSpacing(spacing);\n            imageData.setDirection(direction);\n            imageData.setOrigin(originToUse);\n            imageData.getPointData().setScalars(scalarArray);\n            imageData.modified();\n            viewport.addImages([\n                {\n                    imageId: derivedImageId,\n                    representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n                    callback: ({ imageActor }) => {\n                        imageActor.getMapper().setInputData(imageData);\n                    },\n                },\n            ]);\n            triggerSegmentationRender(viewportId);\n            return;\n        }\n        else {\n            const segmentationImageData = segmentationActorInput.actor\n                .getMapper()\n                .getInputData();\n            if (segmentationImageData.setDerivedImage) {\n                segmentationImageData.setDerivedImage(derivedImage);\n            }\n            else {\n                utilities.updateVTKImageDataWithCornerstoneImage(segmentationImageData, derivedImage);\n            }\n        }\n        viewport.render();\n        if (evt.type === Enums.Events.IMAGE_RENDERED) {\n            viewport.element.removeEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n        }\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraModified = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onCameraModified) {\n            tool.onCameraModified(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onImageSpacingCalibrated = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onImageSpacingCalibrated) {\n            tool.onImageSpacingCalibrated(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport InterpolationManager from '../utilities/segmentation/InterpolationManager/InterpolationManager';\nconst enable = function () {\n    eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);\n    eventTarget.addEventListener(Events.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);\n    eventTarget.addEventListener(Events.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);\n};\nconst disable = function () {\n    eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);\n    eventTarget.removeEventListener(Events.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);\n    eventTarget.removeEventListener(Events.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraReset = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onResetCamera) {\n            tool.onResetCamera(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createCameraPositionSynchronizer(synchronizerName) {\n    const cameraPositionSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, cameraSyncCallback);\n    return cameraPositionSynchronizer;\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport presentationViewSyncCallback from '../callbacks/presentationViewSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createPresentationViewSynchronizer(synchronizerName, options) {\n    const presentationView = createSynchronizer(synchronizerName, CAMERA_MODIFIED, presentationViewSyncCallback, { viewPresentation: options });\n    return presentationView;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createZoomPanSynchronizer(synchronizerName) {\n    const zoomPanSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, zoomPanSyncCallback);\n    return zoomPanSynchronizer;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport imageSliceSyncCallback from '../callbacks/imageSliceSyncCallback';\nconst { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = Enums.Events;\nexport default function createImageSliceSynchronizer(synchronizerName) {\n    const stackImageSynchronizer = createSynchronizer(synchronizerName, STACK_NEW_IMAGE, imageSliceSyncCallback, {\n        auxiliaryEvents: [\n            {\n                name: 'VOLUME_NEW_IMAGE',\n            },\n        ],\n    });\n    return stackImageSynchronizer;\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport slabThicknessSyncCallback from '../callbacks/slabThicknessSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createPresentationViewSynchronizer(synchronizerName) {\n    const presentationView = createSynchronizer(synchronizerName, CAMERA_MODIFIED, slabThicknessSyncCallback);\n    return presentationView;\n}\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nclass PanTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _dragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        if (deltaPointsWorld[0] === 0 &&\n            deltaPointsWorld[1] === 0 &&\n            deltaPointsWorld[2] === 0) {\n            return;\n        }\n        const camera = enabledElement.viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        enabledElement.viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        enabledElement.viewport.render();\n    }\n}\nPanTool.toolName = 'Pan';\nexport default PanTool;\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { Events } from '../enums';\nimport { eventTarget, getEnabledElement, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass TrackballRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            rotateIncrementDegrees: 2,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this._hasResolutionChanged = false;\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const actorEntry = viewport.getDefaultActor();\n            const actor = actorEntry.actor;\n            const mapper = actor.getMapper();\n            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;\n            if (!hasSampleDistance) {\n                return true;\n            }\n            const originalSampleDistance = mapper.getSampleDistance();\n            if (!this._hasResolutionChanged) {\n                mapper.setSampleDistance(originalSampleDistance * 2);\n                this._hasResolutionChanged = true;\n                if (this.cleanUp !== null) {\n                    document.removeEventListener('mouseup', this.cleanUp);\n                }\n                this.cleanUp = () => {\n                    mapper.setSampleDistance(originalSampleDistance);\n                    viewport.render();\n                    this._hasResolutionChanged = false;\n                };\n                document.addEventListener('mouseup', this.cleanUp, { once: true });\n            }\n            return true;\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.onSetToolActive = () => {\n            const subscribeToElementResize = () => {\n                const viewportsInfo = this._getViewportsInfo();\n                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                    if (!this._resizeObservers.has(viewportId)) {\n                        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId) || { viewport: null };\n                        if (!viewport) {\n                            return;\n                        }\n                        const { element } = viewport;\n                        const resizeObserver = new ResizeObserver(() => {\n                            const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                            if (!element) {\n                                return;\n                            }\n                            const { viewport } = element;\n                            viewport.resetCamera();\n                            viewport.render();\n                        });\n                        resizeObserver.observe(element);\n                        this._resizeObservers.set(viewportId, resizeObserver);\n                    }\n                });\n            };\n            subscribeToElementResize();\n            this._viewportAddedListener = (evt) => {\n                if (evt.detail.toolGroupId === this.toolGroupId) {\n                    subscribeToElementResize();\n                }\n            };\n            eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n        };\n        this.onSetToolDisabled = () => {\n            this._resizeObservers.forEach((resizeObserver, viewportId) => {\n                resizeObserver.disconnect();\n                this._resizeObservers.delete(viewportId);\n            });\n            if (this._viewportAddedListener) {\n                eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n                this._viewportAddedListener = null;\n            }\n        };\n        this.rotateCamera = (viewport, centerWorld, axis, angle) => {\n            const vtkCamera = viewport.getVtkActiveCamera();\n            const viewUp = vtkCamera.getViewUp();\n            const focalPoint = vtkCamera.getFocalPoint();\n            const position = vtkCamera.getPosition();\n            const newPosition = [0, 0, 0];\n            const newFocalPoint = [0, 0, 0];\n            const newViewUp = [0, 0, 0];\n            const transform = mat4.identity(new Float32Array(16));\n            mat4.translate(transform, transform, centerWorld);\n            mat4.rotate(transform, transform, angle, axis);\n            mat4.translate(transform, transform, [\n                -centerWorld[0],\n                -centerWorld[1],\n                -centerWorld[2],\n            ]);\n            vec3.transformMat4(newPosition, position, transform);\n            vec3.transformMat4(newFocalPoint, focalPoint, transform);\n            mat4.identity(transform);\n            mat4.rotate(transform, transform, angle, axis);\n            vec3.transformMat4(newViewUp, viewUp, transform);\n            viewport.setCamera({\n                position: newPosition,\n                viewUp: newViewUp,\n                focalPoint: newFocalPoint,\n            });\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, lastPoints } = evt.detail;\n        const currentPointsCanvas = currentPoints.canvas;\n        const lastPointsCanvas = lastPoints.canvas;\n        const { rotateIncrementDegrees } = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const normalizedPosition = [\n            currentPointsCanvas[0] / width,\n            currentPointsCanvas[1] / height,\n        ];\n        const normalizedPreviousPosition = [\n            lastPointsCanvas[0] / width,\n            lastPointsCanvas[1] / height,\n        ];\n        const center = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(center);\n        const normalizedCenter = [0.5, 0.5];\n        const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n        const op = [normalizedPreviousPosition[0], 0, 0];\n        const oe = [normalizedPosition[0], 0, 0];\n        const opsq = op[0] ** 2;\n        const oesq = oe[0] ** 2;\n        const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n        const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n        const nop = [op[0], 0, lop];\n        vtkMath.normalize(nop);\n        const noe = [oe[0], 0, loe];\n        vtkMath.normalize(noe);\n        const dot = vtkMath.dot(nop, noe);\n        if (Math.abs(dot) > 0.0001) {\n            const angleX = -2 *\n                Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n                Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n                rotateIncrementDegrees;\n            const upVec = camera.viewUp;\n            const atV = camera.viewPlaneNormal;\n            const rightV = [0, 0, 0];\n            const forwardV = [0, 0, 0];\n            vtkMath.cross(upVec, atV, rightV);\n            vtkMath.normalize(rightV);\n            vtkMath.cross(atV, rightV, forwardV);\n            vtkMath.normalize(forwardV);\n            vtkMath.normalize(upVec);\n            this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n            const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n                rotateIncrementDegrees;\n            this.rotateCamera(viewport, centerWorld, rightV, angleY);\n            viewport.render();\n        }\n    }\n}\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport, cache, utilities, } from '@cornerstonejs/core';\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\nclass WindowLevelTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this._getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n            const middleSliceIndex = Math.floor(dimensions[2] / 2);\n            const frameLength = dimensions[0] * dimensions[1];\n            let bytesPerVoxel;\n            let TypedArrayConstructor;\n            if (scalarData instanceof Float32Array) {\n                bytesPerVoxel = 4;\n                TypedArrayConstructor = Float32Array;\n            }\n            else if (scalarData instanceof Uint8Array) {\n                bytesPerVoxel = 1;\n                TypedArrayConstructor = Uint8Array;\n            }\n            else if (scalarData instanceof Uint16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Uint16Array;\n            }\n            else if (scalarData instanceof Int16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Int16Array;\n            }\n            const buffer = scalarData.buffer;\n            const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n            const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n            const { max, min } = this._getMinMax(frame, frameLength);\n            return max - min;\n        };\n    }\n    touchDragCallback(evt) {\n        this.mouseDragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let volumeId, lower, upper, modality, newRange, viewportsContainingVolumeUID;\n        let isPreScaled = false;\n        const properties = viewport.getProperties();\n        if (viewport instanceof VolumeViewport) {\n            volumeId = viewport.getVolumeId();\n            viewportsContainingVolumeUID =\n                utilities.getViewportsWithVolumeId(volumeId);\n            ({ lower, upper } = properties.voiRange);\n            const volume = cache.getVolume(volumeId);\n            if (!volume) {\n                throw new Error('Volume not found ' + volumeId);\n            }\n            modality = volume.metadata.Modality;\n            isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n        }\n        else if (properties.voiRange) {\n            modality = viewport.modality;\n            ({ lower, upper } = properties.voiRange);\n            const { preScale = { scaled: false } } = viewport.getImageData?.() || {};\n            isPreScaled =\n                preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n        }\n        else {\n            throw new Error('Viewport is not a valid type');\n        }\n        if (modality === PT && isPreScaled) {\n            newRange = this.getPTScaledNewRange({\n                deltaPointsCanvas: deltaPoints.canvas,\n                lower,\n                upper,\n                clientHeight: element.clientHeight,\n                isPreScaled,\n                viewport,\n                volumeId,\n            });\n        }\n        else {\n            newRange = this.getNewRange({\n                viewport,\n                deltaPointsCanvas: deltaPoints.canvas,\n                volumeId,\n                lower,\n                upper,\n            });\n        }\n        if (newRange.lower >= newRange.upper) {\n            return;\n        }\n        viewport.setProperties({\n            voiRange: newRange,\n        });\n        viewport.render();\n        if (viewport instanceof VolumeViewport) {\n            viewportsContainingVolumeUID.forEach((vp) => {\n                if (viewport !== vp) {\n                    vp.render();\n                }\n            });\n            return;\n        }\n    }\n    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }) {\n        let multiplier = DEFAULT_MULTIPLIER;\n        if (isPreScaled) {\n            multiplier = 5 / clientHeight;\n        }\n        else {\n            multiplier =\n                this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n                    DEFAULT_MULTIPLIER;\n        }\n        const deltaY = deltaPointsCanvas[1];\n        const wcDelta = deltaY * multiplier;\n        upper -= wcDelta;\n        upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n        return { lower, upper };\n    }\n    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n        const multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n            DEFAULT_MULTIPLIER;\n        const wwDelta = deltaPointsCanvas[0] * multiplier;\n        const wcDelta = deltaPointsCanvas[1] * multiplier;\n        let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(lower, upper);\n        windowWidth += wwDelta;\n        windowCenter += wcDelta;\n        windowWidth = Math.max(windowWidth, 1);\n        return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);\n    }\n    _getMultiplierFromDynamicRange(viewport, volumeId) {\n        let imageDynamicRange;\n        if (volumeId) {\n            const imageVolume = cache.getVolume(volumeId);\n            const { voxelManager } = viewport.getImageData();\n            const middleSlicePixelData = voxelManager.getMiddleSliceData();\n            const calculatedDynamicRange = middleSlicePixelData.reduce((acc, pixel) => {\n                return [Math.min(acc[0], pixel), Math.max(acc[1], pixel)];\n            }, [Infinity, -Infinity]);\n            const BitsStored = imageVolume?.metadata?.BitsStored;\n            const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n            imageDynamicRange = Math.min(calculatedDynamicRange, metadataDynamicRange);\n        }\n        else {\n            imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n        }\n        const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n        return ratio > 1 ? Math.round(ratio) : ratio;\n    }\n    _getImageDynamicRangeFromViewport(viewport) {\n        const { imageData, voxelManager } = viewport.getImageData();\n        if (voxelManager?.getRange) {\n            const range = voxelManager.getRange();\n            return range[1] - range[0];\n        }\n        const dimensions = imageData.getDimensions();\n        if (imageData.getRange) {\n            const imageDataRange = imageData.getRange();\n            return imageDataRange[1] - imageDataRange[0];\n        }\n        let scalarData;\n        if (imageData.getScalarData) {\n            scalarData = imageData.getScalarData();\n        }\n        else {\n            scalarData = imageData.getPointData().getScalars().getData();\n        }\n        if (dimensions[2] !== 1) {\n            return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n        }\n        let range;\n        if (scalarData.getRange) {\n            range = scalarData.getRange();\n        }\n        else {\n            const { min, max } = this._getMinMax(scalarData, scalarData.length);\n            range = [min, max];\n        }\n        return range[1] - range[0];\n    }\n    _getMinMax(frame, frameLength) {\n        let min = Infinity;\n        let max = -Infinity;\n        for (let i = 0; i < frameLength; i++) {\n            const voxel = frame[i];\n            if (voxel < min) {\n                min = voxel;\n            }\n            if (voxel > max) {\n                max = voxel;\n            }\n        }\n        return { max, min };\n    }\n}\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n","import { AnnotationTool } from './base';\nimport { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawRect as drawRectSvg } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { windowLevel } from '../utilities/voi';\nclass WindowLevelRegionTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            minWindowWidth: 10,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            removeAnnotation(annotation.annotationUID);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationCompleted(annotation);\n            this.applyWindowLevelRegion(annotation, element);\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            const DEFAULT_HANDLE_INDEX = 3;\n            points[DEFAULT_HANDLE_INDEX] = [...worldPos];\n            const bottomLeftCanvas = worldToCanvas(points[0]);\n            const topRightCanvas = worldToCanvas(points[3]);\n            const bottomRightCanvas = [\n                topRightCanvas[0],\n                bottomLeftCanvas[1],\n            ];\n            const topLeftCanvas = [\n                bottomLeftCanvas[0],\n                topRightCanvas[1],\n            ];\n            const bottomRightWorld = canvasToWorld(bottomRightCanvas);\n            const topLeftWorld = canvasToWorld(topLeftCanvas);\n            points[1] = bottomRightWorld;\n            points[2] = topLeftWorld;\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this.applyWindowLevelRegion = (annotation, element) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const imageData = windowLevel.extractWindowLevelRegionToolData(viewport);\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const startCanvas = canvasCoordinates[0];\n            const endCanvas = canvasCoordinates[3];\n            let left = Math.min(startCanvas[0], endCanvas[0]);\n            let top = Math.min(startCanvas[1], endCanvas[1]);\n            let width = Math.abs(startCanvas[0] - endCanvas[0]);\n            let height = Math.abs(startCanvas[1] - endCanvas[1]);\n            left = utilities.clip(left, 0, imageData.width);\n            top = utilities.clip(top, 0, imageData.height);\n            width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));\n            height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));\n            const pixelLuminanceData = windowLevel.getLuminanceFromRegion(imageData, Math.round(left), Math.round(top), width, height);\n            const minMaxMean = windowLevel.calculateMinMaxMean(pixelLuminanceData, imageData.minPixelValue, imageData.maxPixelValue);\n            if (this.configuration.minWindowWidth === undefined) {\n                this.configuration.minWindowWidth = 10;\n            }\n            const windowWidth = Math.max(Math.abs(minMaxMean.max - minMaxMean.min), this.configuration.minWindowWidth);\n            const windowCenter = minMaxMean.mean;\n            const voiRange = utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);\n            viewport.setProperties({ voiRange });\n            viewport.render();\n        };\n        this.cancel = () => {\n            return null;\n        };\n        this.isPointNearTool = () => {\n            return null;\n        };\n        this.toolSelectedCallback = () => {\n            return null;\n        };\n        this.handleSelectedCallback = () => {\n            return null;\n        };\n        this._activateModify = () => {\n            return null;\n        };\n        this._deactivateModify = () => {\n            return null;\n        };\n    }\n}\nWindowLevelRegionTool.toolName = 'WindowLevelRegion';\nexport default WindowLevelRegionTool;\n","import { getEnabledElementByIds, getEnabledElement, VolumeViewport, BaseVolumeViewport, utilities, } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nclass StackScrollTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            invert: false,\n            debounceIfNotLoaded: true,\n            loop: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.deltaY = 1;\n    }\n    mouseWheelCallback(evt) {\n        this._scroll(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _dragCallback(evt) {\n        this._scrollDrag(evt);\n    }\n    _scrollDrag(evt) {\n        const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n        const { debounceIfNotLoaded, invert, loop } = this.configuration;\n        const deltaPointY = deltaPoints.canvas[1];\n        let volumeId;\n        if (viewport instanceof VolumeViewport) {\n            volumeId = viewport.getVolumeId();\n        }\n        const pixelsPerImage = this._getPixelPerImage(viewport);\n        const deltaY = deltaPointY + this.deltaY;\n        if (!pixelsPerImage) {\n            return;\n        }\n        if (Math.abs(deltaY) >= pixelsPerImage) {\n            const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n            utilities.scroll(viewport, {\n                delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n                volumeId,\n                debounceLoading: debounceIfNotLoaded,\n                loop: loop,\n            });\n            this.deltaY = deltaY % pixelsPerImage;\n        }\n        else {\n            this.deltaY = deltaY;\n        }\n    }\n    _scroll(evt) {\n        const { wheel, element } = evt.detail;\n        const { direction } = wheel;\n        const { invert } = this.configuration;\n        const { viewport } = getEnabledElement(element);\n        const delta = direction * (invert ? -1 : 1);\n        utilities.scroll(viewport, {\n            delta,\n            debounceLoading: this.configuration.debounceIfNotLoaded,\n            loop: this.configuration.loop,\n            volumeId: viewport instanceof BaseVolumeViewport\n                ? viewport.getVolumeId()\n                : undefined,\n            scrollSlabs: this.configuration.scrollSlabs,\n        });\n    }\n    _getPixelPerImage(viewport) {\n        const { element } = viewport;\n        const numberOfSlices = viewport.getNumberOfSlices();\n        return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n    }\n}\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n","import { BaseVolumeViewport, getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nclass PlanarRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseWheelCallback = (evt) => {\n            const { element, wheel } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { invert } = this.configuration;\n            const angle = wheel.direction * 10 * (invert ? -1 : 1);\n            this.setAngle(viewport, angle);\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, startPoints } = evt.detail;\n        const currentPointWorld = currentPoints.world;\n        const startPointWorld = startPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const centerCanvas = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(centerCanvas);\n        let angle = angleBetweenLines([startPointWorld, centerWorld], [centerWorld, currentPointWorld]);\n        const { viewPlaneNormal } = camera;\n        const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n        const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n        const cross = vec3.cross(vec3.create(), v1, v2);\n        if (vec3.dot(viewPlaneNormal, cross) > 0) {\n            angle = -angle;\n        }\n        if (Number.isNaN(angle)) {\n            return;\n        }\n        this.setAngle(viewport, angle);\n    }\n    setAngle(viewport, angle) {\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        if (viewport instanceof BaseVolumeViewport) {\n            const rotAngle = (((angle + 360) % 360) * Math.PI) / 180;\n            const rotMat = mat4.identity(new Float32Array(16));\n            mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n            const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n            viewport.setCamera({ viewUp: rotatedViewUp });\n        }\n        else {\n            const { rotation } = viewport.getViewPresentation();\n            viewport.setViewPresentation({\n                rotation: (rotation + angle + 360) % 360,\n            });\n        }\n        viewport.render();\n    }\n}\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nclass ZoomTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            zoomToCenter: false,\n            minZoomScale: 0.001,\n            maxZoomScale: 3000,\n            pinchToZoom: true,\n            pan: true,\n            invert: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const camera = enabledElement.viewport.getCamera();\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            return false;\n        };\n        this.preTouchStartCallback = (evt) => {\n            if (!this.configuration.pinchToZoom) {\n                return this.preMouseDownCallback(evt);\n            }\n        };\n        this._dragParallelProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { parallelScale, focalPoint, position } = camera;\n            const zoomScale = 5 / size[1];\n            const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n            const parallelScaleToSet = (1.0 - k) * parallelScale;\n            let focalPointToSet = focalPoint;\n            let positionToSet = position;\n            if (!this.configuration.zoomToCenter) {\n                const distanceToCanvasCenter = vec3.distance(focalPoint, this.initialMousePosWorld);\n                positionToSet = vec3.scaleAndAdd(vec3.create(), position, this.dirVec, -distanceToCanvasCenter * k);\n                focalPointToSet = vec3.scaleAndAdd(vec3.create(), focalPoint, this.dirVec, -distanceToCanvasCenter * k);\n            }\n            const imageData = viewport.getImageData();\n            let spacing = [1, 1, 1];\n            if (imageData) {\n                spacing = imageData.spacing;\n            }\n            const { minZoomScale, maxZoomScale } = this.configuration;\n            const t = element.clientHeight * spacing[1] * 0.5;\n            const scale = t / parallelScaleToSet;\n            let cappedParallelScale = parallelScaleToSet;\n            let thresholdExceeded = false;\n            if (imageData) {\n                if (scale < minZoomScale) {\n                    cappedParallelScale = t / minZoomScale;\n                    thresholdExceeded = true;\n                }\n                else if (scale >= maxZoomScale) {\n                    cappedParallelScale = t / maxZoomScale;\n                    thresholdExceeded = true;\n                }\n            }\n            viewport.setCamera({\n                parallelScale: cappedParallelScale,\n                focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n                position: thresholdExceeded ? position : positionToSet,\n            });\n        };\n        this._dragPerspectiveProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { position, focalPoint, viewPlaneNormal } = camera;\n            const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n            const zoomScale = Math.sqrt(distance) / size[1];\n            const directionOfProjection = [\n                -viewPlaneNormal[0],\n                -viewPlaneNormal[1],\n                -viewPlaneNormal[2],\n            ];\n            const k = this.configuration.invert\n                ? deltaY / zoomScale\n                : deltaY * zoomScale;\n            let tmp = k * directionOfProjection[0];\n            position[0] += tmp;\n            focalPoint[0] += tmp;\n            tmp = k * directionOfProjection[1];\n            position[1] += tmp;\n            focalPoint[1] += tmp;\n            tmp = k * directionOfProjection[2];\n            position[2] += tmp;\n            focalPoint[2] += tmp;\n            viewport.setCamera({ position, focalPoint });\n        };\n        this.initialMousePosWorld = [0, 0, 0];\n        this.dirVec = [0, 0, 0];\n        if (this.configuration.pinchToZoom) {\n            this.touchDragCallback = this._pinchCallback.bind(this);\n        }\n        else {\n            this.touchDragCallback = this._dragCallback.bind(this);\n        }\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _pinchCallback(evt) {\n        const pointsList = evt.detail\n            .currentPointsList;\n        if (pointsList.length > 1) {\n            const { element, currentPoints } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const worldPos = currentPoints.world;\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            if (camera.parallelProjection) {\n                this._dragParallelProjection(evt, viewport, camera, true);\n            }\n            else {\n                this._dragPerspectiveProjection(evt, viewport, camera, true);\n            }\n            viewport.render();\n        }\n        if (this.configuration.pan) {\n            this._panCallback(evt);\n        }\n    }\n    _dragCallback(evt) {\n        const { element } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        if (camera.parallelProjection) {\n            this._dragParallelProjection(evt, viewport, camera);\n        }\n        else {\n            this._dragPerspectiveProjection(evt, viewport, camera);\n        }\n        viewport.render();\n    }\n    _panCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        const camera = enabledElement.viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        enabledElement.viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        enabledElement.viewport.render();\n    }\n}\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass MIPJumpToClickTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            targetViewportIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseClickCallback(evt) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const volumeId = viewport.getVolumeId();\n        if (!volumeId) {\n            throw new Error(`MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`);\n        }\n        let maxIntensity = -Infinity;\n        const maxFn = (intensity, point) => {\n            if (intensity > maxIntensity) {\n                maxIntensity = intensity;\n                return point;\n            }\n        };\n        const brightestPoint = getPointInLineOfSightWithCriteria(viewport, currentPoints.world, volumeId, maxFn);\n        if (!brightestPoint || !brightestPoint.length) {\n            return;\n        }\n        const { targetViewportIds, toolGroupId } = this.configuration;\n        const viewports = renderingEngine.getViewports().filter((vp) => {\n            if (targetViewportIds?.indexOf(vp.id) >= 0) {\n                return true;\n            }\n            const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\n            if (toolGroupId && toolGroupId === foundToolGroup?.id) {\n                return true;\n            }\n            return false;\n        });\n        viewports.forEach((viewport) => {\n            if (viewport instanceof VolumeViewport) {\n                viewport.jumpToWorld(brightestPoint);\n            }\n            else {\n                console.warn('Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport');\n            }\n        });\n    }\n}\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\nimport { AnnotationTool } from './base';\nimport { getEnabledElementByIds, getEnabledElement, utilities as csUtils, Enums, CONSTANTS, } from '@cornerstonejs/core';\nimport { getToolGroup, getToolGroupForViewport, } from '../store/ToolGroupManager';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLine as drawLineSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\nimport * as lineSegment from '../utilities/math/line';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nconst { RENDERING_DEFAULTS } = CONSTANTS;\nfunction defaultReferenceLineColor() {\n    return 'rgb(0, 200, 0)';\n}\nfunction defaultReferenceLineControllable() {\n    return true;\n}\nfunction defaultReferenceLineDraggableRotatable() {\n    return true;\n}\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n    return true;\n}\nconst OPERATION = {\n    DRAG: 1,\n    ROTATE: 2,\n    SLAB: 3,\n};\nconst EPSILON = 1e-3;\nclass CrosshairsTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse'],\n        configuration: {\n            shadow: true,\n            viewportIndicators: false,\n            viewportIndicatorsConfig: {\n                radius: 5,\n                x: null,\n                y: null,\n            },\n            autoPan: {\n                enabled: false,\n                panSize: 10,\n            },\n            referenceLinesCenterGapRadius: 20,\n            filterActorUIDsToSetSlabThickness: [],\n            slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n                handleRadius: 9,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.toolCenter = [0, 0, 0];\n        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { FrameOfReferenceUID, viewport } = enabledElement;\n            const { element } = viewport;\n            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n            let annotations = this._getAnnotations(enabledElement);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (annotations.length) {\n                removeAnnotation(annotations[0].annotationUID);\n            }\n            const annotation = {\n                highlighted: false,\n                metadata: {\n                    cameraPosition: [...position],\n                    cameraFocalPoint: [...focalPoint],\n                    FrameOfReferenceUID,\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    handles: {\n                        rotationPoints: [],\n                        slabThicknessPoints: [],\n                        toolCenter: this.toolCenter,\n                    },\n                    activeOperation: null,\n                    activeViewportIds: [],\n                    viewportId,\n                },\n            };\n            addAnnotation(annotation, element);\n            return {\n                normal: viewPlaneNormal,\n                point: viewport.canvasToWorld([\n                    viewport.canvas.clientWidth / 2,\n                    viewport.canvas.clientHeight / 2,\n                ]),\n            };\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resetCrosshairs = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            for (const viewportInfo of viewportsInfo) {\n                const { viewportId, renderingEngineId } = viewportInfo;\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                const viewport = enabledElement.viewport;\n                const resetPan = true;\n                const resetZoom = true;\n                const resetToCenter = true;\n                const resetRotation = true;\n                const suppressEvents = true;\n                viewport.resetCamera({\n                    resetPan,\n                    resetZoom,\n                    resetToCenter,\n                    resetRotation,\n                    suppressEvents,\n                });\n                viewport.resetSlabThickness();\n                const { element } = viewport;\n                let annotations = this._getAnnotations(enabledElement);\n                annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n                if (annotations.length) {\n                    removeAnnotation(annotations[0].annotationUID);\n                }\n                viewport.render();\n            }\n            this._computeToolCenter(viewportsInfo);\n        };\n        this.computeToolCenter = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this._computeToolCenter(viewportsInfo);\n        };\n        this._computeToolCenter = (viewportsInfo) => {\n            if (!viewportsInfo.length || viewportsInfo.length === 1) {\n                console.warn('For crosshairs to operate, at least two viewports must be given.');\n                return;\n            }\n            const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n            const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);\n            const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);\n            let normal3 = [0, 0, 0];\n            let point3 = vec3.create();\n            if (thirdViewport) {\n                ({ normal: normal3, point: point3 } =\n                    this.initializeViewport(thirdViewport));\n            }\n            else {\n                vec3.add(point3, point1, point2);\n                vec3.scale(point3, point3, 0.5);\n                vec3.cross(normal3, normal1, normal2);\n            }\n            const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n            const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n            const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n            this.toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane);\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const jumpWorld = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this._jump(enabledElement, jumpWorld);\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);\n            const { data } = filteredAnnotations[0];\n            const { rotationPoints } = data.handles;\n            const viewportIdArray = [];\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                if (!viewportControllable || !viewportDraggableRotatable) {\n                    continue;\n                }\n                viewportIdArray.push(otherViewport.id);\n                i++;\n            }\n            data.activeViewportIds = [...viewportIdArray];\n            data.handles.activeOperation = OPERATION.DRAG;\n            evt.preventDefault();\n            hideElementCursor(element);\n            this._activateModify(element);\n            return filteredAnnotations[0];\n        };\n        this.cancel = () => {\n            console.log('Not implemented yet');\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const viewport = enabledElement.viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const currentCamera = viewport.getCamera();\n            const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n            const deltaCameraPosition = [0, 0, 0];\n            vtkMath.subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);\n            const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);\n            viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n            viewportAnnotation.metadata.cameraFocalPoint = [\n                ...currentCamera.focalPoint,\n            ];\n            const viewportControllable = this._getReferenceLineControllable(viewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);\n            if (!csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n                viewportControllable &&\n                viewportDraggableRotatable) {\n                let isRotation = false;\n                const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);\n                if (!cameraModifiedSameForPosAndFocalPoint) {\n                    isRotation = true;\n                }\n                const cameraModifiedInPlane = Math.abs(vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 1e-2;\n                if (!isRotation && !cameraModifiedInPlane) {\n                    this.toolCenter[0] += deltaCameraPosition[0];\n                    this.toolCenter[1] += deltaCameraPosition[1];\n                    this.toolCenter[2] += deltaCameraPosition[2];\n                }\n            }\n            if (this.configuration.autoPan?.enabled) {\n                const toolGroup = getToolGroupForViewport(viewport.id, renderingEngine.id);\n                const otherViewportIds = toolGroup\n                    .getViewportIds()\n                    .filter((id) => id !== viewport.id);\n                otherViewportIds.forEach((viewportId) => {\n                    this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n                });\n            }\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.onResetCamera = (evt) => {\n            this.resetCrosshairs();\n        };\n        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let imageNeedsUpdate = false;\n            for (let i = 0; i < filteredToolAnnotations.length; i++) {\n                const annotation = filteredToolAnnotations[i];\n                if (isAnnotationLocked(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data, highlighted } = annotation;\n                if (!data.handles) {\n                    continue;\n                }\n                const previousActiveOperation = data.handles.activeOperation;\n                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0\n                    ? [...data.activeViewportIds]\n                    : [];\n                data.activeViewportIds = [];\n                data.handles.activeOperation = null;\n                const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);\n                let near = false;\n                if (handleNearImagePoint) {\n                    near = true;\n                }\n                else {\n                    near = this._pointNearTool(element, annotation, canvasCoords, 6);\n                }\n                const nearToolAndNotMarkedActive = near && !highlighted;\n                const notNearToolAndMarkedActive = !near && highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !highlighted;\n                    imageNeedsUpdate = true;\n                }\n                else if (data.handles.activeOperation !== previousActiveOperation ||\n                    !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {\n                    imageNeedsUpdate = true;\n                }\n            }\n            return imageNeedsUpdate;\n        };\n        this.filterInteractableAnnotationsForElement = (element, annotations) => {\n            if (!annotations || !annotations.length) {\n                return [];\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewportId } = enabledElement;\n            const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);\n            return viewportUIDSpecificCrosshairs;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, renderingEngine } = enabledElement;\n            const { element } = viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const camera = viewport.getCamera();\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!annotations?.length || !viewportAnnotation?.data) {\n                return renderStatus;\n            }\n            const annotationUID = viewportAnnotation.annotationUID;\n            const { clientWidth, clientHeight } = viewport.canvas;\n            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n            const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n            const data = viewportAnnotation.data;\n            const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n            const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);\n            const referenceLines = [];\n            const canvasBox = [0, 0, clientWidth, clientHeight];\n            otherViewportAnnotations.forEach((annotation) => {\n                const { data } = annotation;\n                data.handles.toolCenter = this.toolCenter;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                const { clientWidth, clientHeight } = otherViewport.canvas;\n                const otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                const otherCanvasCenter = [\n                    clientWidth * 0.5,\n                    clientHeight * 0.5,\n                ];\n                const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);\n                const direction = [0, 0, 0];\n                vtkMath.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);\n                vtkMath.normalize(direction);\n                vtkMath.multiplyScalar(direction, otherCanvasDiagonalLength);\n                const pointWorld0 = [0, 0, 0];\n                vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n                const pointWorld1 = [0, 0, 0];\n                vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n                const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);\n                const canvasUnitVectorFromCenter = vec2.create();\n                vec2.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);\n                vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n                const canvasVectorFromCenterLong = vec2.create();\n                vec2.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);\n                const canvasVectorFromCenterMid = vec2.create();\n                vec2.scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.4);\n                const canvasVectorFromCenterShort = vec2.create();\n                vec2.scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.2);\n                const canvasVectorFromCenterStart = vec2.create();\n                const centerGap = this.configuration.referenceLinesCenterGapRadius;\n                vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? centerGap : 0);\n                const refLinePointOne = vec2.create();\n                const refLinePointTwo = vec2.create();\n                const refLinePointThree = vec2.create();\n                const refLinePointFour = vec2.create();\n                let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n                    refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n                }\n                vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.subtract(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n                liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n                const rotHandleOne = vec2.create();\n                vec2.subtract(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                const rotHandleTwo = vec2.create();\n                vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n                }\n                let stHandlesCenterWorld = [...this.toolCenter];\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterWorld = [...otherViewportCenterWorld];\n                }\n                const worldUnitVectorFromCenter = [0, 0, 0];\n                vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n                vtkMath.normalize(worldUnitVectorFromCenter);\n                const { viewPlaneNormal } = camera;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromDegree()\n                    .rotate(90, viewPlaneNormal);\n                const worldUnitOrthoVectorFromCenter = [0, 0, 0];\n                vec3.transformMat4(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);\n                const slabThicknessValue = otherViewport.getSlabThickness();\n                const worldOrthoVectorFromCenter = [\n                    ...worldUnitOrthoVectorFromCenter,\n                ];\n                vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n                const worldVerticalRefPoint = [0, 0, 0];\n                vtkMath.add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);\n                const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);\n                const canvasOrthoVectorFromCenter = vec2.create();\n                vec2.subtract(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);\n                const stLinePointOne = vec2.create();\n                vec2.subtract(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n                const stLinePointTwo = vec2.create();\n                vec2.add(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n                const stLinePointThree = vec2.create();\n                vec2.add(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);\n                const stLinePointFour = vec2.create();\n                vec2.subtract(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n                const stHandleOne = vec2.create();\n                const stHandleTwo = vec2.create();\n                const stHandleThree = vec2.create();\n                const stHandleFour = vec2.create();\n                vec2.subtract(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n                vec2.subtract(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointOne,\n                    refLinePointTwo,\n                    refLinePointThree,\n                    refLinePointFour,\n                    stLinePointOne,\n                    stLinePointTwo,\n                    stLinePointThree,\n                    stLinePointFour,\n                    rotHandleOne,\n                    rotHandleTwo,\n                    stHandleOne,\n                    stHandleTwo,\n                    stHandleThree,\n                    stHandleFour,\n                ]);\n            });\n            const newRtpoints = [];\n            const newStpoints = [];\n            const viewportColor = this._getReferenceLineColor(viewport.id);\n            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n            referenceLines.forEach((line, lineIndex) => {\n                const otherViewport = line[0];\n                const viewportColor = this._getReferenceLineColor(otherViewport.id);\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);\n                let color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                let lineWidth = 1;\n                const lineActive = data.handles.activeOperation !== null &&\n                    data.handles.activeOperation === OPERATION.DRAG &&\n                    selectedViewportId;\n                if (lineActive) {\n                    lineWidth = 2.5;\n                }\n                let lineUID = `${lineIndex}`;\n                if (viewportControllable && viewportDraggableRotatable) {\n                    lineUID = `${lineIndex}One`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {\n                        color,\n                        lineWidth,\n                    });\n                    lineUID = `${lineIndex}Two`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                else {\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                if (viewportControllable) {\n                    color =\n                        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                    const rotHandlesActive = data.handles.activeOperation === OPERATION.ROTATE;\n                    const rotationHandles = [line[9], line[10]];\n                    const rotHandleWorldOne = [\n                        viewport.canvasToWorld(line[9]),\n                        otherViewport,\n                        line[1],\n                        line[2],\n                    ];\n                    const rotHandleWorldTwo = [\n                        viewport.canvasToWorld(line[10]),\n                        otherViewport,\n                        line[3],\n                        line[4],\n                    ];\n                    newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n                    const slabThicknessHandlesActive = data.handles.activeOperation === OPERATION.SLAB;\n                    const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n                    const slabThicknessHandleWorldOne = [\n                        viewport.canvasToWorld(line[11]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldTwo = [\n                        viewport.canvasToWorld(line[12]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldThree = [\n                        viewport.canvasToWorld(line[13]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    const slabThicknessHandleWorldFour = [\n                        viewport.canvasToWorld(line[14]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);\n                    if ((lineActive || this.configuration.mobile?.enabled) &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable &&\n                        viewportSlabThicknessControlsOn) {\n                        let handleUID = `${lineIndex}One`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.handleRadius\n                                : 3,\n                            opacity: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.opacity\n                                : 1,\n                            type: 'circle',\n                        });\n                        handleUID = `${lineIndex}Two`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.handleRadius\n                                : 3,\n                            opacity: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.opacity\n                                : 1,\n                            type: 'rect',\n                        });\n                    }\n                    else if (lineActive &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.handleRadius\n                                : 3,\n                            opacity: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.opacity\n                                : 1,\n                            type: 'circle',\n                        });\n                    }\n                    else if (selectedViewportId &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportSlabThicknessControlsOn) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.handleRadius\n                                : 3,\n                            opacity: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.opacity\n                                : 1,\n                            type: 'rect',\n                        });\n                    }\n                    else if (rotHandlesActive && viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius: 2,\n                            fill: color,\n                            type: 'circle',\n                        });\n                    }\n                    else if (slabThicknessHandlesActive &&\n                        selectedViewportId &&\n                        viewportSlabThicknessControlsOn) {\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {\n                            color,\n                            handleRadius: 2,\n                            fill: color,\n                            type: 'rect',\n                        });\n                    }\n                    const slabThicknessValue = otherViewport.getSlabThickness();\n                    if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n                        lineUID = `${lineIndex}STOne`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {\n                            color,\n                            width: 1,\n                            lineDash: [2, 3],\n                        });\n                        lineUID = `${lineIndex}STTwo`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {\n                            color,\n                            width: line,\n                            lineDash: [2, 3],\n                        });\n                    }\n                }\n            });\n            renderStatus = true;\n            data.handles.rotationPoints = newRtpoints;\n            data.handles.slabThicknessPoints = newStpoints;\n            if (this.configuration.viewportIndicators) {\n                const { viewportIndicatorsConfig } = this.configuration;\n                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;\n                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;\n                const referenceColorCoordinates = [\n                    clientWidth * xOffset,\n                    clientHeight * yOffset,\n                ];\n                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });\n            }\n            return renderStatus;\n        };\n        this._getAnnotations = (enabledElement) => {\n            const { viewport } = enabledElement;\n            const annotations = getAnnotations(this.getToolName(), viewport.element) || [];\n            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);\n            const toolGroupAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                return viewportIds.includes(data.viewportId);\n            });\n            return toolGroupAnnotations;\n        };\n        this._onNewVolume = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this._computeToolCenter(viewportsInfo);\n        };\n        this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n            if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n                return false;\n            }\n            viewportIdArrayOne.forEach((id) => {\n                let itemFound = false;\n                for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n                    if (id === viewportIdArrayTwo[i]) {\n                        itemFound = true;\n                        break;\n                    }\n                }\n                if (itemFound === false) {\n                    return false;\n                }\n            });\n            return true;\n        };\n        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {\n            const { viewportId, renderingEngine, viewport } = enabledElement;\n            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);\n            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, position } = camera;\n            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const targetViewport = renderingEngine.getViewport(viewportId);\n                const cameraOfTarget = targetViewport.getCamera();\n                return !(csUtils.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && csUtils.isEqual(cameraOfTarget.position, position, 1));\n            });\n            return viewportsWithDifferentCameras;\n        };\n        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {\n            const { renderingEngine } = enabledElement;\n            const { data } = referenceAnnotation;\n            const viewport = renderingEngine.getViewport(data.viewportId);\n            const linkedViewportAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return otherViewportControllable === true;\n            });\n            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                return (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n                    csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));\n            });\n            return otherViewportsAnnotationsWithSameCameraDirection;\n        };\n        this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {\n            const { renderingEngine, viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable === true);\n            });\n            const otherViewportsAnnotationsWithUniqueCameras = [];\n            for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable !== true);\n            });\n            for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n                const annotation = otherViewportAnnotations[i];\n                if (otherViewportsAnnotationsWithUniqueCameras.some((element) => element === annotation)) {\n                    continue;\n                }\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            return otherViewportsAnnotationsWithUniqueCameras;\n        };\n        this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n            const volumeIds = viewport.getAllVolumeIds();\n            const otherVolumeIds = otherViewport.getAllVolumeIds();\n            return (volumeIds.length === otherVolumeIds.length &&\n                volumeIds.every((id) => otherVolumeIds.includes(id)));\n        };\n        this._jump = (enabledElement, jumpWorld) => {\n            state.isInteractingWithTool = true;\n            const { viewport, renderingEngine } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const delta = [0, 0, 0];\n            vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);\n                return (this._getReferenceLineControllable(otherViewport.id) &&\n                    this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n                    sameScene);\n            });\n            if (viewportsAnnotationsToUpdate.length === 0) {\n                state.isInteractingWithTool = false;\n                return false;\n            }\n            this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            state.isInteractingWithTool = false;\n            return true;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            this.editData.annotation.data.handles.activeOperation = null;\n            this.editData.annotation.data.activeViewportIds = [];\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const delta = eventDetail.deltaPoints.world;\n            if (Math.abs(delta[0]) < 1e-3 &&\n                Math.abs(delta[1]) < 1e-3 &&\n                Math.abs(delta[2]) < 1e-3) {\n                return;\n            }\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const { handles } = viewportAnnotation.data;\n            const { currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            if (handles.activeOperation === OPERATION.DRAG) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            }\n            else if (handles.activeOperation === OPERATION.ROTATE) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true);\n                });\n                const dir1 = vec2.create();\n                const dir2 = vec2.create();\n                const center = [\n                    this.toolCenter[0],\n                    this.toolCenter[1],\n                    this.toolCenter[2],\n                ];\n                const centerCanvas = viewport.worldToCanvas(center);\n                const finalPointCanvas = eventDetail.currentPoints.canvas;\n                const originalPointCanvas = vec2.create();\n                vec2.sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);\n                vec2.sub(dir1, originalPointCanvas, centerCanvas);\n                vec2.sub(dir2, finalPointCanvas, centerCanvas);\n                let angle = vec2.angle(dir1, dir2);\n                if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {\n                    angle *= -1;\n                }\n                angle = Math.round(angle * 100) / 100;\n                const rotationAxis = viewport.getCamera().viewPlaneNormal;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromRadian()\n                    .translate(center[0], center[1], center[2])\n                    .rotate(angle, rotationAxis)\n                    .translate(-center[0], -center[1], -center[2]);\n                const otherViewportsIds = [];\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    data.handles.toolCenter = center;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const { viewUp, position, focalPoint } = camera;\n                    viewUp[0] += position[0];\n                    viewUp[1] += position[1];\n                    viewUp[2] += position[2];\n                    vec3.transformMat4(focalPoint, focalPoint, matrix);\n                    vec3.transformMat4(position, position, matrix);\n                    vec3.transformMat4(viewUp, viewUp, matrix);\n                    viewUp[0] -= position[0];\n                    viewUp[1] -= position[1];\n                    viewUp[2] -= position[2];\n                    otherViewport.setCamera({\n                        position,\n                        viewUp,\n                        focalPoint,\n                    });\n                    otherViewportsIds.push(otherViewport.id);\n                });\n                renderingEngine.renderViewports(otherViewportsIds);\n            }\n            else if (handles.activeOperation === OPERATION.SLAB) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportSlabThicknessControlsOn === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                if (referenceAnnotations.length === 0) {\n                    return;\n                }\n                const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);\n                const viewportsIds = [];\n                viewportsIds.push(viewport.id);\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const normal = camera.viewPlaneNormal;\n                    const dotProd = vtkMath.dot(delta, normal);\n                    const projectedDelta = [...normal];\n                    vtkMath.multiplyScalar(projectedDelta, dotProd);\n                    if (Math.abs(projectedDelta[0]) > 1e-3 ||\n                        Math.abs(projectedDelta[1]) > 1e-3 ||\n                        Math.abs(projectedDelta[2]) > 1e-3) {\n                        const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] +\n                            projectedDelta[1] * projectedDelta[1] +\n                            projectedDelta[2] * projectedDelta[2]);\n                        const currentPoint = eventDetail.lastPoints.world;\n                        const direction = [0, 0, 0];\n                        const currentCenter = [\n                            this.toolCenter[0],\n                            this.toolCenter[1],\n                            this.toolCenter[2],\n                        ];\n                        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                        if (!viewportDraggableRotatable) {\n                            const { rotationPoints } = this.editData.annotation.data.handles;\n                            const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);\n                            if (otherViewportRotationPoints.length === 2) {\n                                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);\n                                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);\n                                vtkMath.add(point1, point2, currentCenter);\n                                vtkMath.multiplyScalar(currentCenter, 0.5);\n                            }\n                        }\n                        vtkMath.subtract(currentPoint, currentCenter, direction);\n                        const dotProdDirection = vtkMath.dot(direction, normal);\n                        const projectedDirection = [...normal];\n                        vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n                        const normalizedProjectedDirection = [\n                            projectedDirection[0],\n                            projectedDirection[1],\n                            projectedDirection[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDirection, normalizedProjectedDirection);\n                        const normalizedProjectedDelta = [\n                            projectedDelta[0],\n                            projectedDelta[1],\n                            projectedDelta[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n                        let slabThicknessValue = otherViewport.getSlabThickness();\n                        if (csUtils.isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {\n                            slabThicknessValue -= mod;\n                        }\n                        else {\n                            slabThicknessValue += mod;\n                        }\n                        slabThicknessValue = Math.abs(slabThicknessValue);\n                        slabThicknessValue = Math.max(RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);\n                        const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);\n                        if (near) {\n                            slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n                        }\n                        const toolGroup = getToolGroupForViewport(otherViewport.id, renderingEngine.id);\n                        const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());\n                        crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);\n                        viewportsIds.push(otherViewport.id);\n                    }\n                });\n                renderingEngine.renderViewports(viewportsIds);\n            }\n        };\n        this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {\n            const { data } = annotation;\n            const { rotationPoints } = data.handles;\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                if (otherViewport.id !== lineViewport.id) {\n                    continue;\n                }\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                if (!viewportControllable) {\n                    continue;\n                }\n                const lineSegment1 = {\n                    start: {\n                        x: rotationPoints[i][2][0],\n                        y: rotationPoints[i][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i][3][0],\n                        y: rotationPoints[i][3][1],\n                    },\n                };\n                const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n                const lineSegment2 = {\n                    start: {\n                        x: rotationPoints[i + 1][2][0],\n                        y: rotationPoints[i + 1][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i + 1][3][0],\n                        y: rotationPoints[i + 1][3][1],\n                    },\n                };\n                const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n                if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                    return true;\n                }\n                i++;\n            }\n            return false;\n        };\n        this._getReferenceLineColor =\n            toolProps.configuration?.getReferenceLineColor ||\n                defaultReferenceLineColor;\n        this._getReferenceLineControllable =\n            toolProps.configuration?.getReferenceLineControllable ||\n                defaultReferenceLineControllable;\n        this._getReferenceLineDraggableRotatable =\n            toolProps.configuration?.getReferenceLineDraggableRotatable ||\n                defaultReferenceLineDraggableRotatable;\n        this._getReferenceLineSlabThicknessControlsOn =\n            toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n                defaultReferenceLineSlabThicknessControlsOn;\n    }\n    onSetToolActive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        this._subscribeToViewportNewVolumeSet(viewportsInfo);\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolPassive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolEnabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolDisabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations?.length) {\n                annotations.forEach((annotation) => {\n                    removeAnnotation(annotation.annotationUID);\n                });\n            }\n        });\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n        point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _autoPanViewportIfNecessary(viewportId, renderingEngine) {\n        const viewport = renderingEngine.getViewport(viewportId);\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n        const pan = this.configuration.autoPan.panSize;\n        const visiblePointCanvas = [\n            toolCenterCanvas[0],\n            toolCenterCanvas[1],\n        ];\n        if (toolCenterCanvas[0] < 0) {\n            visiblePointCanvas[0] = pan;\n        }\n        else if (toolCenterCanvas[0] > clientWidth) {\n            visiblePointCanvas[0] = clientWidth - pan;\n        }\n        if (toolCenterCanvas[1] < 0) {\n            visiblePointCanvas[1] = pan;\n        }\n        else if (toolCenterCanvas[1] > clientHeight) {\n            visiblePointCanvas[1] = clientHeight - pan;\n        }\n        if (visiblePointCanvas[0] === toolCenterCanvas[0] &&\n            visiblePointCanvas[1] === toolCenterCanvas[1]) {\n            return;\n        }\n        const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n        const deltaPointsWorld = [\n            visiblePointWorld[0] - this.toolCenter[0],\n            visiblePointWorld[1] - this.toolCenter[1],\n            visiblePointWorld[2] - this.toolCenter[2],\n        ];\n        const camera = viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        viewport.render();\n    }\n    setSlabThickness(viewport, slabThickness) {\n        let actorUIDs;\n        const { filterActorUIDsToSetSlabThickness } = this.configuration;\n        if (filterActorUIDsToSetSlabThickness &&\n            filterActorUIDsToSetSlabThickness.length > 0) {\n            actorUIDs = filterActorUIDsToSetSlabThickness;\n        }\n        let blendModeToUse = this.configuration.slabThicknessBlendMode;\n        if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n            blendModeToUse = Enums.BlendModes.COMPOSITE;\n        }\n        const immediate = false;\n        viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n        viewport.setSlabThickness(slabThickness, actorUIDs);\n    }\n    _isClockWise(a, b, c) {\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n    }\n    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {\n        viewportsAnnotationsToUpdate.forEach((annotation) => {\n            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n        });\n    }\n    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {\n        const { data } = annotation;\n        const viewport = renderingEngine.getViewport(data.viewportId);\n        const camera = viewport.getCamera();\n        const normal = camera.viewPlaneNormal;\n        const dotProd = vtkMath.dot(delta, normal);\n        const projectedDelta = [...normal];\n        vtkMath.multiplyScalar(projectedDelta, dotProd);\n        if (Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3) {\n            const newFocalPoint = [0, 0, 0];\n            const newPosition = [0, 0, 0];\n            vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n            vtkMath.add(camera.position, projectedDelta, newPosition);\n            viewport.setCamera({\n                focalPoint: newFocalPoint,\n                position: newPosition,\n            });\n            viewport.render();\n        }\n    }\n    _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        for (let i = 0; i < rotationPoints.length; i++) {\n            const point = rotationPoints[i][0];\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.ROTATE;\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { slabThicknessPoints } = data.handles;\n        for (let i = 0; i < slabThicknessPoints.length; i++) {\n            const point = slabThicknessPoints[i][0];\n            const otherViewport = slabThicknessPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.SLAB;\n                data.activeViewportIds = [otherViewport.id];\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _pointNearTool(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        const { slabThicknessPoints } = data.handles;\n        const viewportIdArray = [];\n        for (let i = 0; i < rotationPoints.length - 1; ++i) {\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportControllable || !viewportDraggableRotatable) {\n                continue;\n            }\n            const lineSegment1 = {\n                start: {\n                    x: rotationPoints[i][2][0],\n                    y: rotationPoints[i][2][1],\n                },\n                end: {\n                    x: rotationPoints[i][3][0],\n                    y: rotationPoints[i][3][1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: rotationPoints[i + 1][2][0],\n                    y: rotationPoints[i + 1][2][1],\n                },\n                end: {\n                    x: rotationPoints[i + 1][3][0],\n                    y: rotationPoints[i + 1][3][1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = OPERATION.DRAG;\n            }\n            i++;\n        }\n        for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n            const otherViewport = slabThicknessPoints[i][1];\n            if (viewportIdArray.find((id) => id === otherViewport.id)) {\n                continue;\n            }\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const stPointLineCanvas1 = slabThicknessPoints[i][2];\n            const stPointLineCanvas2 = slabThicknessPoints[i][3];\n            const centerCanvas = vec2.create();\n            vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n            vec2.scale(centerCanvas, centerCanvas, 0.5);\n            const canvasUnitVectorFromCenter = vec2.create();\n            vec2.subtract(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);\n            vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n            const canvasVectorFromCenterStart = vec2.create();\n            vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);\n            const stPointLineCanvas1Start = vec2.create();\n            const stPointLineCanvas2Start = vec2.create();\n            vec2.add(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);\n            vec2.subtract(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);\n            const lineSegment1 = {\n                start: {\n                    x: stPointLineCanvas1Start[0],\n                    y: stPointLineCanvas1Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas1[0],\n                    y: stPointLineCanvas1[1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: stPointLineCanvas2Start[0],\n                    y: stPointLineCanvas2Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas2[0],\n                    y: stPointLineCanvas2[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = null;\n            }\n            i++;\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        this.editData = {\n            annotation,\n        };\n        return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n    }\n}\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n","import { BaseTool } from './base';\nimport { Events } from '../enums';\nimport { getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store/state';\nimport { Enums } from '@cornerstonejs/core';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\nclass MagnifyTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            magnifySize: 10,\n            magnifyWidth: 250,\n            magnifyHeight: 250,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._hasBeenRemoved = false;\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('MagnifyTool only works on StackViewports');\n            }\n            const referencedImageId = this._getReferencedImageId(viewport);\n            if (!referencedImageId) {\n                throw new Error('MagnifyTool: No referenced image id found, reconstructed planes not supported yet');\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                referencedImageId,\n                viewportIdsToRender,\n                enabledElement,\n                renderingEngine,\n                currentPoints,\n            };\n            this._createMagnificationViewport();\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this.preTouchStartCallback = (evt) => {\n            this.preMouseDownCallback(evt);\n        };\n        this._createMagnificationViewport = () => {\n            const { enabledElement, referencedImageId, viewportIdsToRender, renderingEngine, currentPoints, } = this.editData;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const viewportProperties = viewport.getProperties();\n            const { canvas: canvasPos, world: worldPos } = currentPoints;\n            let magnifyToolElement;\n            magnifyToolElement = element.querySelector('.magnifyTool');\n            if (magnifyToolElement === null) {\n                const magnifyElement = document.createElement('div');\n                magnifyElement.classList.add('magnifyTool');\n                magnifyElement.style.display = 'block';\n                magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n                magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n                magnifyElement.style.position = 'absolute';\n                magnifyToolElement = magnifyElement;\n                const viewportElement = element.querySelector('.viewport-element');\n                viewportElement.appendChild(magnifyElement);\n                const viewportInput = {\n                    viewportId: MAGNIFY_VIEWPORT_ID,\n                    type: Enums.ViewportType.STACK,\n                    element: magnifyToolElement,\n                };\n                renderingEngine.enableElement(viewportInput);\n            }\n            magnifyToolElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyToolElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            magnifyViewport.setStack([referencedImageId]).then(() => {\n                if (this._hasBeenRemoved) {\n                    return;\n                }\n                magnifyViewport.setProperties(viewportProperties);\n                const { parallelScale } = viewport.getCamera();\n                const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n                const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n                    Math.pow(focalPoint[1] - position[1], 2) +\n                    Math.pow(focalPoint[2] - position[2], 2));\n                const updatedFocalPoint = [\n                    worldPos[0],\n                    worldPos[1],\n                    worldPos[2],\n                ];\n                const updatedPosition = [\n                    updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n                    updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n                    updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n                ];\n                magnifyViewport.setCamera({\n                    parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n                    focalPoint: updatedFocalPoint,\n                    position: updatedPosition,\n                });\n                magnifyViewport.render();\n            });\n            magnifyToolElement.style.display = 'block';\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { deltaPoints, element, currentPoints } = eventDetail;\n            const deltaPointsWorld = deltaPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            const magnifyElement = element.querySelector('.magnifyTool');\n            if (!magnifyElement) {\n                return;\n            }\n            magnifyElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const { focalPoint, position } = magnifyViewport.getCamera();\n            const updatedPosition = [\n                position[0] + deltaPointsWorld[0],\n                position[1] + deltaPointsWorld[1],\n                position[2] + deltaPointsWorld[2],\n            ];\n            const updatedFocalPoint = [\n                focalPoint[0] + deltaPointsWorld[0],\n                focalPoint[1] + deltaPointsWorld[1],\n                focalPoint[2] + deltaPointsWorld[2],\n            ];\n            magnifyViewport.setCamera({\n                focalPoint: updatedFocalPoint,\n                position: updatedPosition,\n            });\n            magnifyViewport.render();\n        };\n        this._dragEndCallback = (evt) => {\n            const { element } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n            const viewportElement = element.querySelector('.viewport-element');\n            const magnifyToolElement = viewportElement.querySelector('.magnifyTool');\n            viewportElement.removeChild(magnifyToolElement);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this._hasBeenRemoved = true;\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            this._hasBeenRemoved = false;\n            element.addEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.addEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.removeEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n    }\n    _getReferencedImageId(viewport) {\n        const targetId = this.getTargetId(viewport);\n        let referencedImageId;\n        if (viewport instanceof StackViewport) {\n            referencedImageId = targetId.split('imageId:')[1];\n        }\n        return referencedImageId;\n    }\n}\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n","import { AnnotationTool } from './base';\nimport { getEnabledElement, utilities as csUtils, eventTarget, Enums, getRenderingEngine, CONSTANTS, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { addAnnotation, getAllAnnotations, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events, MouseBindings, KeyboardBindings, Events as cstEvents, SegmentationRepresentations, ToolModes, } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nimport debounce from '../utilities/debounce';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { addSegmentationRepresentations } from '../stateManagement/segmentation';\nconst MAGNIFY_CLASSNAME = 'advancedMagnifyTool';\nconst MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;\nconst { Events: csEvents } = Enums;\nconst isSegmentation = (actor) => actor.uid !== actor.referencedId;\nvar AdvancedMagnifyToolActions;\n(function (AdvancedMagnifyToolActions) {\n    AdvancedMagnifyToolActions[\"ShowZoomFactorsList\"] = \"showZoomFactorsList\";\n})(AdvancedMagnifyToolActions || (AdvancedMagnifyToolActions = {}));\nconst ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';\nconst PARALLEL_THRESHOLD = 1 - CONSTANTS.EPSILON;\nclass AdvancedMagnifyTool extends AnnotationTool {\n    static { this.Actions = AdvancedMagnifyToolActions; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            magnifyingGlass: {\n                radius: 125,\n                zoomFactor: 3,\n                zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],\n                autoPan: {\n                    enabled: true,\n                    padding: 10,\n                },\n            },\n            actions: {\n                showZoomFactorsList: {\n                    method: 'showZoomFactorsList',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Secondary,\n                            modifierKey: KeyboardBindings.Shift,\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const { magnifyingGlass: config } = this.configuration;\n            const { radius, zoomFactor, autoPan } = config;\n            const canvasHandlePoints = this._getCanvasHandlePoints(canvasPos, radius);\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotationUID = csUtils.uuidv4();\n            const magnifyViewportId = csUtils.uuidv4();\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                annotationUID,\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    sourceViewportId: viewport.id,\n                    magnifyViewportId,\n                    zoomFactor,\n                    isCanvasAnnotation: true,\n                    handles: {\n                        points: canvasHandlePoints,\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            this.magnifyViewportManager.createViewport(annotation, {\n                magnifyViewportId,\n                sourceEnabledElement: enabledElement,\n                position: canvasPos,\n                radius,\n                zoomFactor,\n                autoPan: {\n                    enabled: autoPan.enabled,\n                    padding: autoPan.padding,\n                    callback: (data) => {\n                        const annotationPoints = annotation.data.handles.points;\n                        const { canvas: canvasDelta } = data.delta;\n                        for (let i = 0, len = annotationPoints.length; i < len; i++) {\n                            const point = annotationPoints[i];\n                            point[0] += canvasDelta[0];\n                            point[1] += canvasDelta[1];\n                            annotation.invalidated = true;\n                        }\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.onSetToolDisabled = () => {\n            this.magnifyViewportManager.dispose();\n            const annotations = getAllAnnotations();\n            annotations.forEach((annotation) => {\n                if (annotation.metadata.toolName === this.getToolName()) {\n                    removeAnnotation(annotation.annotationUID);\n                }\n            });\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points;\n            const canvasTop = canvasCoordinates[0];\n            const canvasBottom = canvasCoordinates[2];\n            const canvasLeft = canvasCoordinates[3];\n            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n            const center = [\n                canvasLeft[0] + radius,\n                canvasTop[1] + radius,\n            ];\n            const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\n            if (Math.abs(radiusPoint - radius) < proximity * 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            const { points } = data.handles;\n            const handleIndex = points.findIndex((p) => p === handle);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { deltaPoints } = eventDetail;\n            const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { points } = annotation.data.handles;\n            points.forEach((point) => {\n                point[0] += canvasDelta[0];\n                point[1] += canvasDelta[1];\n            });\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const canvasDelta = deltaPoints.canvas;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += canvasDelta[0];\n                    point[1] += canvasDelta[1];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points;\n            const canvasTop = canvasCoordinates[0];\n            const canvasBottom = canvasCoordinates[2];\n            const canvasLeft = canvasCoordinates[3];\n            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n            const canvasCenter = [\n                canvasLeft[0] + radius,\n                canvasTop[1] + radius,\n            ];\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const newRadius = getCanvasCircleRadius([\n                canvasCenter,\n                currentCanvasPoints,\n            ]);\n            const newCanvasHandlePoints = this._getCanvasHandlePoints(canvasCenter, newRadius);\n            points[0] = newCanvasHandlePoints[0];\n            points[1] = newCanvasHandlePoints[1];\n            points[2] = newCanvasHandlePoints[2];\n            points[3] = newCanvasHandlePoints[3];\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = annotations?.filter((annotation) => annotation.data.sourceViewportId ===\n                viewport.id);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!filteredAnnotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < filteredAnnotations.length; i++) {\n                const annotation = filteredAnnotations[i];\n                const { annotationUID, data } = annotation;\n                const { magnifyViewportId, zoomFactor, handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points;\n                const canvasTop = canvasCoordinates[0];\n                const canvasBottom = canvasCoordinates[2];\n                const canvasLeft = canvasCoordinates[3];\n                const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n                const center = [\n                    canvasLeft[0] + radius,\n                    canvasTop[1] + radius,\n                ];\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-advancedMagnify`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineWidth: 5,\n                }, dataId);\n                const magnifyViewport = this.magnifyViewportManager.getViewport(magnifyViewportId);\n                magnifyViewport.position = center;\n                magnifyViewport.radius = radius;\n                magnifyViewport.zoomFactor = zoomFactor;\n                magnifyViewport.update();\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {\n            return [\n                [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0],\n                [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0],\n                [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0],\n                [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0],\n            ];\n        };\n        this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\n    }\n    showZoomFactorsList(evt, annotation) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvas: canvasPoint } = currentPoints;\n        const viewportElement = element.querySelector(':scope .viewport-element');\n        const currentZoomFactor = annotation.data.zoomFactor;\n        const remove = () => dropdown.parentElement.removeChild(dropdown);\n        const dropdown = this._getZoomFactorsListDropdown(currentZoomFactor, (newZoomFactor) => {\n            if (newZoomFactor !== undefined) {\n                annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\n                annotation.invalidated = true;\n            }\n            remove();\n            viewport.render();\n        });\n        Object.assign(dropdown.style, {\n            left: `${canvasPoint[0]}px`,\n            top: `${canvasPoint[1]}px`,\n        });\n        viewportElement.appendChild(dropdown);\n        dropdown.focus();\n    }\n    _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\n        const { zoomFactorList } = this.configuration.magnifyingGlass;\n        const dropdown = document.createElement('select');\n        dropdown.size = 5;\n        Object.assign(dropdown.style, {\n            width: '50px',\n            position: 'absolute',\n        });\n        ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\n            dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\n        });\n        dropdown.addEventListener('change', (evt) => {\n            evt.stopPropagation();\n            onChangeCallback(dropdown.value);\n        });\n        dropdown.addEventListener('keydown', (evt) => {\n            const shouldCancel = (evt.keyCode ?? evt.which === 27) ||\n                evt.key?.toLowerCase() === 'escape';\n            if (shouldCancel) {\n                evt.stopPropagation();\n                onChangeCallback();\n            }\n        });\n        zoomFactorList.forEach((zoomFactor) => {\n            const option = document.createElement('option');\n            option.label = zoomFactor;\n            option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\n            option.value = zoomFactor;\n            option.defaultSelected = zoomFactor === currentZoomFactor;\n            dropdown.add(option);\n        });\n        return dropdown;\n    }\n}\nclass AdvancedMagnifyViewportManager {\n    constructor() {\n        this.createViewport = (annotation, viewportInfo) => {\n            const { magnifyViewportId, sourceEnabledElement, position, radius, zoomFactor, autoPan, } = viewportInfo;\n            const { viewport: sourceViewport } = sourceEnabledElement;\n            const { element: sourceElement } = sourceViewport;\n            const magnifyViewport = new AdvancedMagnifyViewport({\n                magnifyViewportId,\n                sourceEnabledElement,\n                radius,\n                position,\n                zoomFactor,\n                autoPan,\n            });\n            this._addSourceElementEventListener(sourceElement);\n            this._magnifyViewportsMap.set(magnifyViewport.viewportId, {\n                annotation,\n                magnifyViewport,\n                magnifyViewportInfo: viewportInfo,\n            });\n            return magnifyViewport;\n        };\n        this._annotationRemovedCallback = (evt) => {\n            const { annotation } = evt.detail;\n            if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {\n                return;\n            }\n            this.destroyViewport(annotation.data.magnifyViewportId);\n        };\n        this._newStackImageCallback = (evt) => {\n            const { viewportId: sourceViewportId, imageId } = evt.detail;\n            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n            const { viewport } = getEnabledElementByViewportId(sourceViewportId);\n            if (viewport.stackActorReInitialized) {\n                this._reset(sourceViewportId);\n            }\n            magnifyViewportsMapEntries.forEach(({ annotation }) => {\n                annotation.metadata.referencedImageId = imageId;\n                annotation.invalidated = true;\n            });\n        };\n        this._newVolumeImageCallback = (evt) => {\n            const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            const sourceViewport = renderingEngine.getViewport(sourceViewportId);\n            const { viewPlaneNormal: currentViewPlaneNormal } = sourceViewport.getCamera();\n            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n            magnifyViewportsMapEntries.forEach(({ annotation }) => {\n                const { viewPlaneNormal } = annotation.metadata;\n                const isParallel = Math.abs(vec3.dot(viewPlaneNormal, currentViewPlaneNormal)) >\n                    PARALLEL_THRESHOLD;\n                if (!isParallel) {\n                    return;\n                }\n                const { handles } = annotation.data;\n                const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);\n                const vecHandleToImagePlane = vec3.sub(vec3.create(), worldImagePlanePoint, handles.points[0]);\n                const worldDist = vec3.dot(vecHandleToImagePlane, currentViewPlaneNormal);\n                const worldDelta = vec3.scale(vec3.create(), currentViewPlaneNormal, worldDist);\n                for (let i = 0, len = handles.points.length; i < len; i++) {\n                    const point = handles.points[i];\n                    point[0] += worldDelta[0];\n                    point[1] += worldDelta[1];\n                    point[2] += worldDelta[2];\n                }\n                annotation.invalidated = true;\n            });\n        };\n        this._magnifyViewportsMap = new Map();\n        this._initialize();\n    }\n    static getInstance() {\n        AdvancedMagnifyViewportManager._singleton =\n            AdvancedMagnifyViewportManager._singleton ??\n                new AdvancedMagnifyViewportManager();\n        return AdvancedMagnifyViewportManager._singleton;\n    }\n    getViewport(magnifyViewportId) {\n        return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;\n    }\n    dispose() {\n        this._removeEventListeners();\n        this._destroyViewports();\n    }\n    destroyViewport(magnifyViewportId) {\n        const magnifyViewportMapEntry = this._magnifyViewportsMap.get(magnifyViewportId);\n        if (magnifyViewportMapEntry) {\n            const { magnifyViewport } = magnifyViewportMapEntry;\n            const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;\n            const { element: sourceElement } = sourceViewport;\n            this._removeSourceElementEventListener(sourceElement);\n            magnifyViewport.dispose();\n            this._magnifyViewportsMap.delete(magnifyViewportId);\n        }\n    }\n    _destroyViewports() {\n        const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());\n        magnifyViewportIds.forEach((magnifyViewportId) => this.destroyViewport(magnifyViewportId));\n    }\n    _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {\n        const magnifyViewportsMapEntries = Array.from(this._magnifyViewportsMap.values());\n        return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {\n            const { viewport } = magnifyViewport.sourceEnabledElement;\n            return viewport.id === sourceViewportId;\n        });\n    }\n    _reset(sourceViewportId) {\n        const magnifyViewports = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n        magnifyViewports.forEach(({ magnifyViewport, annotation, magnifyViewportInfo }) => {\n            this.destroyViewport(magnifyViewport.viewportId);\n            const newEnabledElement = getEnabledElementByViewportId(sourceViewportId);\n            this.createViewport(annotation, {\n                ...magnifyViewportInfo,\n                sourceEnabledElement: {\n                    ...newEnabledElement,\n                },\n            });\n        });\n    }\n    _addEventListeners() {\n        eventTarget.addEventListener(cstEvents.ANNOTATION_REMOVED, this._annotationRemovedCallback);\n    }\n    _removeEventListeners() {\n        eventTarget.removeEventListener(cstEvents.ANNOTATION_REMOVED, this._annotationRemovedCallback);\n    }\n    _addSourceElementEventListener(element) {\n        element.addEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);\n        const newStackHandler = (evt) => {\n            const { viewportId: sourceViewportId } = evt.detail;\n            this._reset(sourceViewportId);\n        };\n        element.addEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, newStackHandler);\n        const newVolumeHandler = (evt) => {\n            const { viewportId: sourceViewportId } = evt.detail;\n            this._reset(sourceViewportId);\n        };\n        element.addEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, newVolumeHandler);\n        element.addEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);\n        element.newStackHandler = newStackHandler;\n        element.newVolumeHandler = newVolumeHandler;\n    }\n    _removeSourceElementEventListener(element) {\n        element.removeEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);\n        element.removeEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);\n        element.removeEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, element.newStackHandler);\n        element.removeEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, element.newVolumeHandler);\n        delete element.newStackHandler;\n        delete element.newVolumeHandler;\n    }\n    _initialize() {\n        this._addEventListeners();\n    }\n}\nclass AdvancedMagnifyViewport {\n    constructor({ magnifyViewportId, sourceEnabledElement, radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS, position = [0, 0], zoomFactor, autoPan, }) {\n        this._enabledElement = null;\n        this._sourceToolGroup = null;\n        this._magnifyToolGroup = null;\n        this._isViewportReady = false;\n        this._radius = 0;\n        this._resized = false;\n        this._canAutoPan = false;\n        this._viewportId = magnifyViewportId ?? csUtils.uuidv4();\n        this._sourceEnabledElement = sourceEnabledElement;\n        this._autoPan = autoPan;\n        this.radius = radius;\n        this.position = position;\n        this.zoomFactor = zoomFactor;\n        this.visible = true;\n        this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);\n        this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);\n        this._handleToolModeChanged = this._handleToolModeChanged.bind(this);\n        this._mouseDragCallback = this._mouseDragCallback.bind(this);\n        this._resizeViewportAsync = (debounce(this._resizeViewport.bind(this), 1));\n        this._initialize();\n    }\n    get sourceEnabledElement() {\n        return this._sourceEnabledElement;\n    }\n    get viewportId() {\n        return this._viewportId;\n    }\n    get radius() {\n        return this._radius;\n    }\n    set radius(radius) {\n        if (Math.abs(this._radius - radius) > 0.00001) {\n            this._radius = radius;\n            this._resized = true;\n        }\n    }\n    update() {\n        const { radius, position, visible } = this;\n        const { viewport } = this._enabledElement;\n        const { element } = viewport;\n        const size = 2 * radius;\n        const [x, y] = position;\n        if (this._resized) {\n            this._resizeViewportAsync();\n            this._resized = false;\n        }\n        Object.assign(element.style, {\n            display: visible ? 'block' : 'hidden',\n            width: `${size}px`,\n            height: `${size}px`,\n            left: `${-radius}px`,\n            top: `${-radius}px`,\n            transform: `translate(${x}px, ${y}px)`,\n        });\n        if (this._isViewportReady) {\n            this._syncViewports();\n            viewport.render();\n        }\n    }\n    dispose() {\n        const { viewport } = this._enabledElement;\n        const { element } = viewport;\n        const renderingEngine = viewport.getRenderingEngine();\n        this._removeEventListeners(element);\n        renderingEngine.disableElement(viewport.id);\n        if (element.parentNode) {\n            element.parentNode.removeChild(element);\n        }\n    }\n    _handleToolModeChanged(evt) {\n        const { _magnifyToolGroup: magnifyToolGroup } = this;\n        const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;\n        if (this._sourceToolGroup?.id !== toolGroupId) {\n            return;\n        }\n        switch (mode) {\n            case ToolModes.Active:\n                magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);\n                break;\n            case ToolModes.Passive:\n                magnifyToolGroup.setToolPassive(toolName);\n                break;\n            case ToolModes.Enabled:\n                magnifyToolGroup.setToolEnabled(toolName);\n                break;\n            case ToolModes.Disabled:\n                magnifyToolGroup.setToolDisabled(toolName);\n                break;\n            default:\n                throw new Error(`Unknow tool mode (${mode})`);\n        }\n    }\n    _inheritBorderRadius(magnifyElement) {\n        const viewport = magnifyElement.querySelector('.viewport-element');\n        const canvas = magnifyElement.querySelector('.cornerstone-canvas');\n        viewport.style.borderRadius = 'inherit';\n        canvas.style.borderRadius = 'inherit';\n    }\n    _createViewportNode() {\n        const magnifyElement = document.createElement('div');\n        const { radius } = this;\n        const size = radius * 2;\n        magnifyElement.classList.add(MAGNIFY_CLASSNAME);\n        Object.assign(magnifyElement.style, {\n            display: 'block',\n            width: `${size}px`,\n            height: `${size}px`,\n            position: 'absolute',\n            overflow: 'hidden',\n            borderRadius: '50%',\n            boxSizing: 'border-box',\n            left: `${-radius}px`,\n            top: `${-radius}px`,\n            transform: `translate(-1000px, -1000px)`,\n        });\n        return magnifyElement;\n    }\n    _convertZoomFactorToParallelScale(viewport, magnifyViewport, zoomFactor) {\n        const { parallelScale } = viewport.getCamera();\n        const canvasRatio = magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;\n        return parallelScale * (1 / zoomFactor) * canvasRatio;\n    }\n    _isStackViewport(viewport) {\n        return 'setStack' in viewport;\n    }\n    _isVolumeViewport(viewport) {\n        return 'addVolumes' in viewport;\n    }\n    _cloneToolGroups(sourceViewport, magnifyViewport) {\n        const sourceActors = sourceViewport.getActors();\n        const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;\n        const sourceToolGroup = getToolGroupForViewport(sourceViewport.id, sourceViewport.renderingEngineId);\n        const magnifyToolGroup = sourceToolGroup.clone(magnifyToolGroupId, (toolName) => {\n            const toolInstance = sourceToolGroup.getToolInstance(toolName);\n            const isAnnotationTool = toolInstance instanceof AnnotationTool &&\n                !(toolInstance instanceof AdvancedMagnifyTool);\n            return isAnnotationTool;\n        });\n        magnifyToolGroup.addViewport(magnifyViewport.id, magnifyViewport.renderingEngineId);\n        sourceActors.filter(isSegmentation).forEach((actor) => {\n            addSegmentationRepresentations(this.viewportId, [\n                {\n                    segmentationId: actor.referencedId,\n                    type: SegmentationRepresentations.Labelmap,\n                },\n            ]);\n        });\n        return { sourceToolGroup, magnifyToolGroup };\n    }\n    _cloneStack(sourceViewport, magnifyViewport) {\n        const imageIds = sourceViewport.getImageIds();\n        magnifyViewport.setStack(imageIds).then(() => {\n            this._isViewportReady = true;\n            this.update();\n        });\n    }\n    _cloneVolumes(sourceViewport, magnifyViewport) {\n        const actors = sourceViewport.getActors();\n        const volumeInputArray = actors\n            .filter((actor) => !isSegmentation(actor))\n            .map((actor) => ({ volumeId: actor.uid }));\n        magnifyViewport.setVolumes(volumeInputArray).then(() => {\n            this._isViewportReady = true;\n            this.update();\n        });\n        return magnifyViewport;\n    }\n    _cloneViewport(sourceViewport, magnifyElement) {\n        const { viewportId: magnifyViewportId } = this;\n        const renderingEngine = sourceViewport.getRenderingEngine();\n        const { options: sourceViewportOptions } = sourceViewport;\n        const viewportInput = {\n            element: magnifyElement,\n            viewportId: magnifyViewportId,\n            type: sourceViewport.type,\n            defaultOptions: { ...sourceViewportOptions },\n        };\n        renderingEngine.enableElement(viewportInput);\n        const magnifyViewport = (renderingEngine.getViewport(magnifyViewportId));\n        if (this._isStackViewport(sourceViewport)) {\n            this._cloneStack(sourceViewport, magnifyViewport);\n        }\n        else if (this._isVolumeViewport(sourceViewport)) {\n            this._cloneVolumes(sourceViewport, magnifyViewport);\n        }\n        this._inheritBorderRadius(magnifyElement);\n        const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);\n        this._sourceToolGroup = toolGroups.sourceToolGroup;\n        this._magnifyToolGroup = toolGroups.magnifyToolGroup;\n    }\n    _cancelMouseEventCallback(evt) {\n        evt.stopPropagation();\n        evt.preventDefault();\n    }\n    _browserMouseUpCallback(evt) {\n        const { element } = this._enabledElement.viewport;\n        document.removeEventListener('mouseup', this._browserMouseUpCallback);\n        element.addEventListener('mouseup', this._cancelMouseEventCallback);\n        element.addEventListener('mousemove', this._cancelMouseEventCallback);\n    }\n    _browserMouseDownCallback(evt) {\n        const { element } = this._enabledElement.viewport;\n        this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');\n        document.addEventListener('mouseup', this._browserMouseUpCallback);\n        element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n        element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n    }\n    _mouseDragCallback(evt) {\n        if (!state.isInteractingWithTool) {\n            return;\n        }\n        const { _autoPan: autoPan } = this;\n        if (!autoPan.enabled || !this._canAutoPan) {\n            return;\n        }\n        const { currentPoints } = evt.detail;\n        const { viewport } = this._enabledElement;\n        const { canvasToWorld } = viewport;\n        const { canvas: canvasCurrent } = currentPoints;\n        const { radius: magnifyRadius } = this;\n        const canvasCenter = [magnifyRadius, magnifyRadius];\n        const dist = distanceToPoint(canvasCenter, canvasCurrent);\n        const maxDist = magnifyRadius - autoPan.padding;\n        if (dist <= maxDist) {\n            return;\n        }\n        const panDist = dist - maxDist;\n        const canvasDeltaPos = vec2.sub(vec2.create(), canvasCurrent, canvasCenter);\n        vec2.normalize(canvasDeltaPos, canvasDeltaPos);\n        vec2.scale(canvasDeltaPos, canvasDeltaPos, panDist);\n        const newCanvasPosition = vec2.add(vec2.create(), this.position, canvasDeltaPos);\n        const currentWorldPos = canvasToWorld(this.position);\n        const newWorldPos = canvasToWorld(newCanvasPosition);\n        const worldDeltaPos = vec3.sub(vec3.create(), newWorldPos, currentWorldPos);\n        const autoPanCallbackData = {\n            points: {\n                currentPosition: {\n                    canvas: this.position,\n                    world: currentWorldPos,\n                },\n                newPosition: {\n                    canvas: newCanvasPosition,\n                    world: newWorldPos,\n                },\n            },\n            delta: {\n                canvas: canvasDeltaPos,\n                world: worldDeltaPos,\n            },\n        };\n        autoPan.callback(autoPanCallbackData);\n    }\n    _addBrowserEventListeners(element) {\n        document.addEventListener('mousedown', this._browserMouseDownCallback, true);\n        element.addEventListener('mousedown', this._cancelMouseEventCallback);\n        element.addEventListener('mouseup', this._cancelMouseEventCallback);\n        element.addEventListener('mousemove', this._cancelMouseEventCallback);\n        element.addEventListener('dblclick', this._cancelMouseEventCallback);\n    }\n    _removeBrowserEventListeners(element) {\n        document.removeEventListener('mousedown', this._browserMouseDownCallback, true);\n        document.removeEventListener('mouseup', this._browserMouseUpCallback);\n        element.removeEventListener('mousedown', this._cancelMouseEventCallback);\n        element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n        element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n        element.removeEventListener('dblclick', this._cancelMouseEventCallback);\n    }\n    _addEventListeners(element) {\n        eventTarget.addEventListener(cstEvents.TOOL_MODE_CHANGED, this._handleToolModeChanged);\n        element.addEventListener(cstEvents.MOUSE_MOVE, this._mouseDragCallback);\n        element.addEventListener(cstEvents.MOUSE_DRAG, this._mouseDragCallback);\n        this._addBrowserEventListeners(element);\n    }\n    _removeEventListeners(element) {\n        eventTarget.removeEventListener(cstEvents.TOOL_MODE_CHANGED, this._handleToolModeChanged);\n        element.addEventListener(cstEvents.MOUSE_MOVE, this._mouseDragCallback);\n        element.addEventListener(cstEvents.MOUSE_DRAG, this._mouseDragCallback);\n        this._removeBrowserEventListeners(element);\n    }\n    _initialize() {\n        const { _sourceEnabledElement: sourceEnabledElement } = this;\n        const { viewport: sourceViewport } = sourceEnabledElement;\n        const { canvas: sourceCanvas } = sourceViewport;\n        const magnifyElement = this._createViewportNode();\n        sourceCanvas.parentNode.appendChild(magnifyElement);\n        this._addEventListeners(magnifyElement);\n        this._cloneViewport(sourceViewport, magnifyElement);\n        this._enabledElement = getEnabledElement(magnifyElement);\n    }\n    _syncViewportsCameras(sourceViewport, magnifyViewport) {\n        const worldPos = sourceViewport.canvasToWorld(this.position);\n        const parallelScale = this._convertZoomFactorToParallelScale(sourceViewport, magnifyViewport, this.zoomFactor);\n        const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n        const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n            Math.pow(focalPoint[1] - position[1], 2) +\n            Math.pow(focalPoint[2] - position[2], 2));\n        const updatedFocalPoint = [\n            worldPos[0],\n            worldPos[1],\n            worldPos[2],\n        ];\n        const updatedPosition = [\n            updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n            updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n            updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n        ];\n        magnifyViewport.setCamera({\n            parallelScale,\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n    }\n    _syncStackViewports(sourceViewport, magnifyViewport) {\n        magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());\n    }\n    _syncViewports() {\n        const { viewport: sourceViewport } = this._sourceEnabledElement;\n        const { viewport: magnifyViewport } = this._enabledElement;\n        const sourceProperties = sourceViewport.getProperties();\n        const imageData = magnifyViewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        magnifyViewport.setProperties(sourceProperties);\n        this._syncViewportsCameras(sourceViewport, magnifyViewport);\n        if (this._isStackViewport(sourceViewport)) {\n            this._syncStackViewports(sourceViewport, magnifyViewport);\n        }\n        this._syncViewportsCameras(sourceViewport, magnifyViewport);\n        magnifyViewport.render();\n    }\n    _resizeViewport() {\n        const { viewport } = this._enabledElement;\n        const renderingEngine = viewport.getRenderingEngine();\n        renderingEngine.resize();\n    }\n}\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\nexport { AdvancedMagnifyTool as default };\n","import { vec3 } from 'gl-matrix';\nimport { getRenderingEngines, CONSTANTS, utilities as csUtils, } from '@cornerstonejs/core';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass ReferenceLines extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceViewportId: '',\n            enforceSameFrameOfReference: true,\n            showFullDimension: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = null;\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            let viewports = renderingEngine.getViewports();\n            viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n            const sourceViewport = renderingEngine.getViewport(this.configuration.sourceViewportId);\n            if (!sourceViewport?.getImageData()) {\n                return;\n            }\n            const { element } = sourceViewport;\n            const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n            const sourceViewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(sourceViewport);\n            let annotation = this.editData?.annotation;\n            const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n            if (!annotation) {\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        viewPlaneNormal: [...viewPlaneNormal],\n                        viewUp: [...viewUp],\n                        FrameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        handles: {\n                            points: sourceViewportCanvasCornersInWorld,\n                        },\n                    },\n                };\n                addAnnotation(newAnnotation, element);\n                annotation = newAnnotation;\n            }\n            else {\n                this.editData.annotation.data.handles.points =\n                    sourceViewportCanvasCornersInWorld;\n            }\n            this.editData = {\n                sourceViewportId: sourceViewport.id,\n                renderingEngine,\n                annotation,\n            };\n            triggerAnnotationRenderForViewportIds(viewports\n                .filter((viewport) => viewport.id !== sourceViewport.id)\n                .map((viewport) => viewport.id));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onSetToolConfiguration = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport: targetViewport } = enabledElement;\n            if (!this.editData) {\n                return false;\n            }\n            const { annotation, sourceViewportId } = this.editData;\n            let renderStatus = false;\n            const { viewport: sourceViewport } = getEnabledElementByViewportId(sourceViewportId) || {};\n            if (!sourceViewport) {\n                return renderStatus;\n            }\n            if (sourceViewport.id === targetViewport.id) {\n                return renderStatus;\n            }\n            if (!annotation || !annotation?.data?.handles?.points) {\n                return renderStatus;\n            }\n            if (this.configuration.enforceSameFrameOfReference &&\n                sourceViewport.getFrameOfReferenceUID() !==\n                    targetViewport.getFrameOfReferenceUID()) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const topLeft = annotation.data.handles.points[0];\n            const topRight = annotation.data.handles.points[1];\n            const bottomLeft = annotation.data.handles.points[2];\n            const bottomRight = annotation.data.handles.points[3];\n            const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\n            const { viewPlaneNormal: sourceViewPlaneNormal } = sourceViewport.getCamera();\n            if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            let pointSetToUse = pointSet1;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const newNormal = vec3.cross(vec3.create(), topBottomVec, topRightVec);\n            if (this.isParallel(newNormal, viewPlaneNormal)) {\n                return renderStatus;\n            }\n            if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                pointSetToUse = pointSet2;\n            }\n            const lineStartWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n            const lineEndWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n            const { annotationUID } = annotation;\n            styleSpecifier.annotationUID = annotationUID;\n            const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n            const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n            const color = this.getStyle('color', styleSpecifier, annotation);\n            const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n            let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n            if (this.configuration.showFullDimension) {\n                canvasCoordinates = this.handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates);\n            }\n            if (canvasCoordinates.length < 2) {\n                return renderStatus;\n            }\n            const dataId = `${annotationUID}-line`;\n            const lineUID = '1';\n            drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, dataId);\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates) {\n        const renderingEngine = targetViewport.getRenderingEngine();\n        const targetId = this.getTargetId(targetViewport);\n        const targetImage = this.getTargetImageData(targetId);\n        const referencedImageId = this.getReferencedImageId(targetViewport, lineStartWorld, viewPlaneNormal, viewUp);\n        if (referencedImageId && targetImage) {\n            try {\n                const { imageData, dimensions } = targetImage;\n                const [topLeftImageCoord, topRightImageCoord, bottomRightImageCoord, bottomLeftImageCoord,] = [\n                    imageData.indexToWorld([0, 0, 0]),\n                    imageData.indexToWorld([dimensions[0] - 1, 0, 0]),\n                    imageData.indexToWorld([\n                        dimensions[0] - 1,\n                        dimensions[1] - 1,\n                        0,\n                    ]),\n                    imageData.indexToWorld([0, dimensions[1] - 1, 0]),\n                ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n                const [lineStartImageCoord, lineEndImageCoord] = [\n                    lineStartWorld,\n                    lineEndWorld,\n                ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n                canvasCoordinates = [\n                    [topLeftImageCoord, topRightImageCoord],\n                    [topRightImageCoord, bottomRightImageCoord],\n                    [bottomLeftImageCoord, bottomRightImageCoord],\n                    [topLeftImageCoord, bottomLeftImageCoord],\n                ]\n                    .map(([start, end]) => this.intersectInfiniteLines(start, end, lineStartImageCoord, lineEndImageCoord))\n                    .filter((point) => point && this.isInBound(point, dimensions))\n                    .map((point) => {\n                    const world = csUtils.imageToWorldCoords(referencedImageId, point);\n                    return targetViewport.worldToCanvas(world);\n                });\n            }\n            catch (err) {\n                console.log(err);\n            }\n        }\n        return canvasCoordinates;\n    }\n    intersectInfiniteLines(line1Start, line1End, line2Start, line2End) {\n        const [x1, y1] = line1Start;\n        const [x2, y2] = line1End;\n        const [x3, y3] = line2Start;\n        const [x4, y4] = line2End;\n        const a1 = y2 - y1;\n        const b1 = x1 - x2;\n        const c1 = x2 * y1 - x1 * y2;\n        const a2 = y4 - y3;\n        const b2 = x3 - x4;\n        const c2 = x4 * y3 - x3 * y4;\n        if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\n            return;\n        }\n        const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n        const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n        return [x, y];\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n    isInBound(point, dimensions) {\n        return (point[0] >= 0 &&\n            point[0] <= dimensions[0] &&\n            point[1] >= 0 &&\n            point[1] <= dimensions[1]);\n    }\n}\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n","import { vec3 } from 'gl-matrix';\nimport { metaData, CONSTANTS, getRenderingEngine, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass OverlayGridTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceImageIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onSetToolActive = () => {\n            this._init();\n        };\n        this._init = () => {\n            const sourceImageIds = this.configuration.sourceImageIds;\n            if (!sourceImageIds?.length) {\n                console.warn('OverlayGridTool: No sourceImageIds provided in configuration');\n                return;\n            }\n            const imagePlaneModule = metaData.get('imagePlaneModule', sourceImageIds[0]);\n            if (!imagePlaneModule) {\n                console.warn('OverlayGridTool: No imagePlaneModule found for sourceImageIds');\n                return;\n            }\n            const { frameOfReferenceUID } = imagePlaneModule;\n            const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportsInfo?.length) {\n                console.warn('OverlayGridTool: No viewports found');\n                return;\n            }\n            const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n            if (!annotations?.length) {\n                const pointSets = sourceImageIds.map((id) => {\n                    return this.calculateImageIdPointSets(id);\n                });\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        FrameOfReferenceUID: frameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        viewportData: new Map(),\n                        pointSets,\n                    },\n                };\n                addAnnotation(newAnnotation, frameOfReferenceUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.calculateImageIdPointSets = (imageId) => {\n            const { imagePositionPatient, rows, columns, rowCosines, columnCosines, rowPixelSpacing, columnPixelSpacing, } = metaData.get('imagePlaneModule', imageId);\n            const topLeft = [...imagePositionPatient];\n            const topRight = [...imagePositionPatient];\n            const bottomLeft = [...imagePositionPatient];\n            const bottomRight = [...imagePositionPatient];\n            vec3.scaleAndAdd(topRight, imagePositionPatient, columnCosines, columns * columnPixelSpacing);\n            vec3.scaleAndAdd(bottomLeft, imagePositionPatient, rowCosines, rows * rowPixelSpacing);\n            vec3.scaleAndAdd(bottomRight, bottomLeft, columnCosines, columns * columnPixelSpacing);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            return { pointSet1, pointSet2 };\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const sourceImageIds = this.configuration.sourceImageIds;\n            let renderStatus = false;\n            if (!sourceImageIds?.length) {\n                return renderStatus;\n            }\n            const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\n            const targetImageIds = targetViewport.getImageIds();\n            if (targetImageIds.length < 2) {\n                return renderStatus;\n            }\n            const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const annotation = annotations[0];\n            const { annotationUID } = annotation;\n            const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const imageIdNormal = (this.getImageIdNormal(sourceImageIds[0]));\n            if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSets = annotation.data.pointSets;\n            const viewportData = annotation.data.viewportData;\n            for (let i = 0; i < sourceImageIds.length; i++) {\n                const { pointSet1, pointSet2 } = pointSets[i];\n                const targetData = viewportData.get(targetViewport.id) ||\n                    this.initializeViewportData(viewportData, targetViewport.id);\n                if (!targetData.pointSetsToUse[i]) {\n                    let pointSetToUse = pointSet1;\n                    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n                    topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n                    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                        pointSetToUse = pointSet2;\n                    }\n                    targetData.pointSetsToUse[i] = pointSetToUse;\n                    targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n                    targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n                }\n                const lineStartWorld = targetData.lineStartsWorld[i];\n                const lineEndWorld = targetData.lineEndsWorld[i];\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n                const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n                const dataId = `${annotationUID}-line`;\n                const lineUID = `${i}`;\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n            }\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.initializeViewportData = (viewportData, id) => {\n            viewportData.set(id, {\n                pointSetsToUse: [],\n                lineStartsWorld: [],\n                lineEndsWorld: [],\n            });\n            return viewportData.get(id);\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n    getImageIdNormal(imageId) {\n        const { imageOrientationPatient } = metaData.get('imagePlaneModule', imageId);\n        const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n        const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n        return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\n    }\n}\nOverlayGridTool.toolName = 'OverlayGrid';\nexport default OverlayGridTool;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawPath } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { pointToString } from '../utilities/pointToString';\nimport { polyDataUtils } from '../utilities';\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            opacity: 0.5,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._init = () => {\n            const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportsInfo?.length) {\n                console.warn(this.getToolName() + 'Tool: No viewports found');\n                return;\n            }\n            const firstViewport = getRenderingEngine(viewportsInfo[0].renderingEngineId)?.getViewport(viewportsInfo[0].viewportId);\n            if (!firstViewport) {\n                return;\n            }\n            const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\n            const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n            if (!annotations?.length) {\n                const actorsWorldPointsMap = new Map();\n                calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo);\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        FrameOfReferenceUID: frameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        actorsWorldPointsMap,\n                    },\n                };\n                addAnnotation(newAnnotation, frameOfReferenceUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            let renderStatus = false;\n            const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const annotation = annotations[0];\n            const { annotationUID } = annotation;\n            const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;\n            calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);\n            const actorEntries = viewport.getActors();\n            const cacheId = getCacheId(viewport);\n            actorEntries.forEach((actorEntry) => {\n                if (!actorEntry?.clippingFilter) {\n                    return;\n                }\n                const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\n                if (!actorWorldPointMap) {\n                    return;\n                }\n                if (!actorWorldPointMap.get(cacheId)) {\n                    return;\n                }\n                let polyLineIdx = 1;\n                const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\n                for (let i = 0; i < worldPointsSet.length; i++) {\n                    const worldPoints = worldPointsSet[i];\n                    const canvasPoints = worldPoints.map((point) => viewport.worldToCanvas(point));\n                    const options = {\n                        color: color,\n                        fillColor: color,\n                        fillOpacity: this.configuration.opacity,\n                        closePath: true,\n                        lineWidth: 2,\n                    };\n                    const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\n                    drawPath(svgDrawingHelper, annotationUID, polyLineUID, canvasPoints, options);\n                    polyLineIdx++;\n                }\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nfunction calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const viewport = getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n        calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);\n    });\n}\nfunction calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport) {\n    const actorEntries = viewport.getActors();\n    const cacheId = getCacheId(viewport);\n    actorEntries.forEach((actorEntry) => {\n        if (!actorEntry?.clippingFilter) {\n            return;\n        }\n        let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\n        if (!actorWorldPointsMap) {\n            actorWorldPointsMap = new Map();\n            actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\n        }\n        if (!actorWorldPointsMap.get(cacheId)) {\n            const polyData = actorEntry.clippingFilter.getOutputData();\n            const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\n            if (!worldPointsSet) {\n                return;\n            }\n            const colorArray = actorEntry.actor.getProperty().getColor();\n            const color = colorToString(colorArray);\n            actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\n        }\n    });\n}\nfunction getCacheId(viewport) {\n    const { viewPlaneNormal } = viewport.getCamera();\n    const imageIndex = viewport.getCurrentImageIdIndex();\n    return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\n}\nfunction colorToString(colorArray) {\n    function colorComponentToString(component) {\n        let componentString = Math.floor(component * 255).toString(16);\n        if (componentString.length === 1) {\n            componentString = '0' + componentString;\n        }\n        return componentString;\n    }\n    return ('#' +\n        colorComponentToString(colorArray[0]) +\n        colorComponentToString(colorArray[1]) +\n        colorComponentToString(colorArray[2]));\n}\nfunction removeExtraPoints(viewport, worldPointsSet) {\n    return worldPointsSet.map((worldPoints) => {\n        const canvasPoints = worldPoints.map((point) => {\n            const canvasPoint = viewport.worldToCanvas(point);\n            return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\n        });\n        let lastPoint;\n        const newWorldPoints = [];\n        let newCanvasPoints = [];\n        for (let i = 0; i < worldPoints.length; i++) {\n            if (lastPoint) {\n                if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\n                    newWorldPoints.push(worldPoints[i]);\n                    newCanvasPoints.push(canvasPoints[i]);\n                }\n            }\n            lastPoint = canvasPoints[i];\n        }\n        const firstPoint = newCanvasPoints[0];\n        for (let j = Math.min(30, newCanvasPoints.length); j < newCanvasPoints.length; j++) {\n            if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\n                newCanvasPoints = newCanvasPoints.slice(0, j);\n                return newWorldPoints.slice(0, j);\n            }\n        }\n        return newWorldPoints;\n    });\n}\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\nexport default SegmentationIntersectionTool;\n","import { getEnabledElement, StackViewport, VolumeViewport, utilities, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass ReferenceCursors extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            displayThreshold: 5,\n            positionSync: true,\n            disableCursor: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isHandleOutsideImage = false;\n        this._elementWithCursor = null;\n        this._currentCursorWorldPosition = null;\n        this._currentCanvasPosition = null;\n        this._disableCursorEnabled = false;\n        this.mouseMoveCallback = (evt) => {\n            const { detail } = evt;\n            const { element, currentPoints } = detail;\n            this._currentCursorWorldPosition = currentPoints.world;\n            this._currentCanvasPosition = currentPoints.canvas;\n            this._elementWithCursor = element;\n            const annotation = this.getActiveAnnotation(element);\n            if (annotation === null) {\n                this.createInitialAnnotation(currentPoints.world, element);\n                return false;\n            }\n            this.updateAnnotationPosition(element, annotation);\n            return false;\n        };\n        this.createInitialAnnotation = (worldPos, element) => {\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                throw new Error('No enabled element found');\n            }\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            if (!viewPlaneNormal || !viewUp) {\n                throw new Error('Camera not found');\n            }\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                },\n            };\n            const annotations = getAnnotations(this.getToolName(), element);\n            if (annotations.length > 0) {\n                return null;\n            }\n            const annotationId = addAnnotation(annotation, element);\n            if (annotationId === null) {\n                return;\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, previousCamera, camera } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const viewport = enabledElement.viewport;\n            if (element !== this._elementWithCursor) {\n                return;\n            }\n            const oldFocalPoint = previousCamera.focalPoint;\n            const cameraNormal = camera.viewPlaneNormal;\n            const newFocalPoint = camera.focalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n            if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\n                return;\n            }\n            const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n            if (Math.abs(dotProduct) < 1e-2) {\n                return;\n            }\n            if (!this._currentCanvasPosition) {\n                return;\n            }\n            const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n            this._currentCursorWorldPosition = newWorldPos;\n            this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            const isElementWithCursor = this._elementWithCursor === viewport.element;\n            if (this.configuration.positionSync && !isElementWithCursor) {\n                this.updateViewportImage(viewport);\n            }\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                if (!annotationUID) {\n                    return renderStatus;\n                }\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidthBase = parseFloat(this.getStyle('lineWidth', styleSpecifier, annotation));\n                const lineWidth = typeof lineWidthBase === 'number' && isElementWithCursor\n                    ? lineWidthBase\n                    : lineWidthBase;\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (points[0].some((e) => isNaN(e))) {\n                    return renderStatus;\n                }\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const crosshairUIDs = {\n                    upper: 'upper',\n                    right: 'right',\n                    lower: 'lower',\n                    left: 'left',\n                };\n                const [x, y] = canvasCoordinates[0];\n                const centerSpace = isElementWithCursor ? 20 : 7;\n                const lineLength = isElementWithCursor ? 5 : 7;\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.upper, [x, y - (centerSpace / 2 + lineLength)], [x, y - centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.lower, [x, y + (centerSpace / 2 + lineLength)], [x, y + centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.right, [x + (centerSpace / 2 + lineLength), y], [x + centerSpace / 2, y], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.left, [x - (centerSpace / 2 + lineLength), y], [x - centerSpace / 2, y], { color, lineDash, lineWidth });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._disableCursorEnabled = this.configuration.disableCursor;\n    }\n    onSetToolActive() {\n        this._disableCursorEnabled = this.configuration.disableCursor;\n        if (!this._disableCursorEnabled) {\n            return;\n        }\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds) {\n            return;\n        }\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element) {\n                hideElementCursor(element.viewport.element);\n            }\n        });\n    }\n    onSetToolDisabled() {\n        if (!this._disableCursorEnabled) {\n            return;\n        }\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds) {\n            return;\n        }\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element) {\n                resetElementCursor(element.viewport.element);\n            }\n        });\n    }\n    getActiveAnnotation(element) {\n        const annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations.length) {\n            return null;\n        }\n        const targetAnnotation = annotations[0];\n        return targetAnnotation;\n    }\n    updateAnnotationPosition(element, annotation) {\n        const worldPos = this._currentCursorWorldPosition;\n        if (!worldPos) {\n            return;\n        }\n        if (!annotation.data?.handles?.points) {\n            return;\n        }\n        annotation.data.handles.points = [[...worldPos]];\n        annotation.invalidated = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!(annotations instanceof Array) || annotations.length === 0) {\n            return [];\n        }\n        const annotation = annotations[0];\n        const viewport = getEnabledElement(element)?.viewport;\n        if (!viewport) {\n            return [];\n        }\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, focalPoint } = camera;\n        if (!viewPlaneNormal || !focalPoint) {\n            return [];\n        }\n        const points = annotation.data?.handles?.points;\n        if (!(points instanceof Array) || points.length !== 1) {\n            return [];\n        }\n        const worldPos = points[0];\n        const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n        const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n        return distance < this.configuration.displayThreshold ? [annotation] : [];\n    }\n    updateViewportImage(viewport) {\n        const currentMousePosition = this._currentCursorWorldPosition;\n        if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\n            return;\n        }\n        if (viewport instanceof StackViewport) {\n            const closestIndex = utilities.getClosestStackImageIndexForPoint(currentMousePosition, viewport);\n            if (closestIndex === null) {\n                return;\n            }\n            if (closestIndex !== viewport.getCurrentImageIdIndex()) {\n                viewport.setImageIdIndex(closestIndex);\n            }\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n            if (!focalPoint || !viewPlaneNormal) {\n                return;\n            }\n            const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const currentDistance = utilities.planar.planeDistanceToPoint(plane, currentMousePosition, true);\n            if (Math.abs(currentDistance) < 0.5) {\n                return;\n            }\n            const normalizedViewPlane = vec3.normalize(vec3.create(), vec3.fromValues(...viewPlaneNormal));\n            const scaledPlaneNormal = vec3.scale(vec3.create(), normalizedViewPlane, currentDistance);\n            const newFocalPoint = vec3.add(vec3.create(), vec3.fromValues(...focalPoint), scaledPlaneNormal);\n            const isInBounds = true;\n            if (isInBounds) {\n                viewport.setCamera({ focalPoint: newFocalPoint });\n                const renderingEngine = viewport.getRenderingEngine();\n                if (renderingEngine) {\n                    renderingEngine.renderViewport(viewport.id);\n                }\n            }\n        }\n    }\n}\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport { getEnabledElementByIds, getRenderingEngines, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg, drawTextBox as drawTextBoxSvg, } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nconst viewportsWithAnnotations = [];\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            viewportId: '',\n            scaleLocation: 'bottom',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = null;\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportIds) {\n                return;\n            }\n            const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n            let { viewport } = enabledElements[0];\n            const { FrameOfReferenceUID } = enabledElements[0];\n            if (this.configuration.viewportId) {\n                enabledElements.forEach((element) => {\n                    if (element.viewport.id == this.configuration.viewportId) {\n                        viewport = element.viewport;\n                    }\n                });\n            }\n            if (!viewport) {\n                return;\n            }\n            const { viewUp, viewPlaneNormal } = viewport.getCamera();\n            const viewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(viewport);\n            let annotation = this.editData?.annotation;\n            const annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (annotations.length) {\n                annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n            }\n            enabledElements.forEach((element) => {\n                const { viewport } = element;\n                if (!viewportsWithAnnotations.includes(viewport.id)) {\n                    const newAnnotation = {\n                        metadata: {\n                            toolName: this.getToolName(),\n                            viewPlaneNormal: [...viewPlaneNormal],\n                            viewUp: [...viewUp],\n                            FrameOfReferenceUID,\n                            referencedImageId: null,\n                        },\n                        data: {\n                            handles: {\n                                points: csUtils.getViewportImageCornersInWorld(viewport),\n                            },\n                            viewportId: viewport.id,\n                        },\n                    };\n                    viewportsWithAnnotations.push(viewport.id);\n                    addAnnotation(newAnnotation, viewport.element);\n                    annotation = newAnnotation;\n                }\n            });\n            if (this.editData?.annotation &&\n                this.editData.annotation.data.viewportId == viewport.id) {\n                this.editData.annotation.data.handles.points =\n                    viewportCanvasCornersInWorld;\n                this.editData.annotation.data.viewportId = viewport.id;\n            }\n            this.editData = {\n                viewport,\n                renderingEngine,\n                annotation,\n            };\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this.configuration.viewportId = evt.detail.viewportId;\n            this._init();\n        };\n        this.computeScaleSize = (worldWidthViewport, worldHeightViewport, location) => {\n            const scaleSizes = [\n                16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n            ];\n            let currentScaleSize;\n            if (location == 'top' || location == 'bottom') {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldWidthViewport * 0.6 &&\n                    scaleSize > worldWidthViewport * 0.2);\n            }\n            else {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldHeightViewport * 0.6 &&\n                    scaleSize > worldHeightViewport * 0.2);\n            }\n            return currentScaleSize[0];\n        };\n        this.computeEndScaleTicks = (canvasCoordinates, location) => {\n            const locationTickOffset = {\n                bottom: [\n                    [0, -10],\n                    [0, -10],\n                ],\n                top: [\n                    [0, 10],\n                    [0, 10],\n                ],\n                left: [\n                    [0, 0],\n                    [10, 0],\n                ],\n                right: [\n                    [0, 0],\n                    [-10, 0],\n                ],\n            };\n            const endTick1 = [\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            const endTick2 = [\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            return {\n                endTick1: endTick1,\n                endTick2: endTick2,\n            };\n        };\n        this.computeInnerScaleTicks = (scaleSize, location, annotationUID, leftTick, rightTick) => {\n            let canvasScaleSize;\n            if (location == 'bottom' || location == 'top') {\n                canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n            }\n            else if (location == 'left' || location == 'right') {\n                canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n            }\n            const tickIds = [];\n            const tickUIDs = [];\n            const tickCoordinates = [];\n            let numberSmallTicks = scaleSize;\n            if (scaleSize >= 50) {\n                numberSmallTicks = scaleSize / 10;\n            }\n            const tickSpacing = canvasScaleSize / numberSmallTicks;\n            for (let i = 0; i < numberSmallTicks - 1; i++) {\n                const locationOffset = {\n                    bottom: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), 5],\n                    ],\n                    top: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), -5],\n                    ],\n                    left: [\n                        [0, tickSpacing * (i + 1)],\n                        [-5, tickSpacing * (i + 1)],\n                    ],\n                    right: [\n                        [0, tickSpacing * (i + 1)],\n                        [5, tickSpacing * (i + 1)],\n                    ],\n                };\n                tickIds.push(`${annotationUID}-tick${i}`);\n                tickUIDs.push(`tick${i}`);\n                if ((i + 1) % 5 == 0) {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][0][0],\n                            leftTick[1][1] + locationOffset[location][0][1],\n                        ],\n                    ]);\n                }\n                else {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][1][0],\n                            leftTick[1][1] + locationOffset[location][1][1],\n                        ],\n                    ]);\n                }\n            }\n            return { tickIds, tickUIDs, tickCoordinates };\n        };\n        this.computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n            let worldCoordinates;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const midpointLocation = {\n                bottom: [pointSet[1], pointSet[2]],\n                top: [pointSet[0], pointSet[3]],\n                right: [pointSet[2], pointSet[3]],\n                left: [pointSet[0], pointSet[1]],\n            };\n            const midpoint = vec3\n                .add(vec3.create(), midpointLocation[location][0], midpointLocation[location][0])\n                .map((i) => i / 2);\n            const offset = scaleSize /\n                2 /\n                Math.sqrt(Math.pow(topBottomVec[0], 2) +\n                    Math.pow(topBottomVec[1], 2) +\n                    Math.pow(topBottomVec[2], 2));\n            if (location == 'top' || location == 'bottom') {\n                worldCoordinates = [\n                    vec3.subtract(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                    vec3.add(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                worldCoordinates = [\n                    vec3.add(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                    vec3.subtract(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                ];\n            }\n            return worldCoordinates;\n        };\n        this.computeCanvasScaleCoordinates = (canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location) => {\n            let scaleCanvasCoordinates;\n            if (location == 'top' || location == 'bottom') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][0] - canvasCoordinates[1][0];\n                scaleCanvasCoordinates = [\n                    [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n                    [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][1] - canvasCoordinates[1][1];\n                scaleCanvasCoordinates = [\n                    [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n                    [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n                ];\n            }\n            return scaleCanvasCoordinates;\n        };\n        this.computeScaleBounds = (canvasSize, horizontalReduction, verticalReduction, location) => {\n            const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n            const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n            const locationBounds = {\n                bottom: [-vReduction, -hReduction],\n                top: [vReduction, hReduction],\n                left: [vReduction, hReduction],\n                right: [-vReduction, -hReduction],\n            };\n            const canvasBounds = {\n                bottom: [canvasSize.height, canvasSize.width],\n                top: [0, canvasSize.width],\n                left: [canvasSize.height, 0],\n                right: [canvasSize.height, canvasSize.width],\n            };\n            return {\n                height: canvasBounds[location][0] + locationBounds[location][0],\n                width: canvasBounds[location][1] + locationBounds[location][1],\n            };\n        };\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.editData || !this.editData.viewport) {\n            return;\n        }\n        const location = this.configuration.scaleLocation;\n        const { viewport } = enabledElement;\n        const annotations = getAnnotations(this.getToolName(), viewport.element);\n        const annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n        const canvas = enabledElement.viewport.canvas;\n        const renderStatus = false;\n        if (!viewport) {\n            return renderStatus;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        const canvasSize = {\n            width: canvas.width / window.devicePixelRatio || 1,\n            height: canvas.height / window.devicePixelRatio || 1,\n        };\n        const topLeft = annotation.data.handles.points[0];\n        const topRight = annotation.data.handles.points[1];\n        const bottomLeft = annotation.data.handles.points[2];\n        const bottomRight = annotation.data.handles.points[3];\n        const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n        const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n        const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n        const hscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const vscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const scaleSize = this.computeScaleSize(worldWidthViewport, worldHeightViewport, location);\n        const canvasCoordinates = this.computeWorldScaleCoordinates(scaleSize, location, pointSet1).map((world) => viewport.worldToCanvas(world));\n        const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location);\n        const scaleTicks = this.computeEndScaleTicks(scaleCanvasCoordinates, location);\n        const { annotationUID } = annotation;\n        styleSpecifier.annotationUID = annotationUID;\n        const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n        const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n        const color = this.getStyle('color', styleSpecifier, annotation);\n        const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n        const scaleId = `${annotationUID}-scaleline`;\n        const scaleLineUID = '1';\n        drawLineSvg(svgDrawingHelper, annotationUID, scaleLineUID, scaleCanvasCoordinates[0], scaleCanvasCoordinates[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, scaleId);\n        const leftTickId = `${annotationUID}-left`;\n        const leftTickUID = '2';\n        drawLineSvg(svgDrawingHelper, annotationUID, leftTickUID, scaleTicks.endTick1[0], scaleTicks.endTick1[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, leftTickId);\n        const rightTickId = `${annotationUID}-right`;\n        const rightTickUID = '3';\n        drawLineSvg(svgDrawingHelper, annotationUID, rightTickUID, scaleTicks.endTick2[0], scaleTicks.endTick2[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, rightTickId);\n        const locationTextOffest = {\n            bottom: [-10, -42],\n            top: [-12, -35],\n            left: [-40, -20],\n            right: [-50, -20],\n        };\n        const textCanvasCoordinates = [\n            scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n            scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n        ];\n        const textBoxLines = this._getTextLines(scaleSize);\n        const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(scaleSize, location, annotationUID, scaleTicks.endTick1, scaleTicks.endTick2);\n        for (let i = 0; i < tickUIDs.length; i++) {\n            drawLineSvg(svgDrawingHelper, annotationUID, tickUIDs[i], tickCoordinates[i][0], tickCoordinates[i][1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, tickIds[i]);\n        }\n        const textUID = 'text0';\n        drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textBoxLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], {\n            fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n            fontSize: '14px',\n            lineDash: '2,3',\n            lineWidth: '1',\n            shadow: true,\n            color: color,\n        });\n        return renderStatus;\n    }\n    _getTextLines(scaleSize) {\n        let scaleSizeDisplayValue;\n        let scaleSizeUnits;\n        if (scaleSize >= 50) {\n            scaleSizeDisplayValue = scaleSize / 10;\n            scaleSizeUnits = ' cm';\n        }\n        else {\n            scaleSizeDisplayValue = scaleSize;\n            scaleSizeUnits = ' mm';\n        }\n        const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n        return textLines;\n    }\n}\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { getAnnotations } from '../stateManagement';\nimport { point } from '../utilities/math';\nimport { Events, ToolModes, AnnotationStyleStates } from '../enums';\nimport { triggerAnnotationRenderForViewportIds } from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\nimport { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\nimport CircleSculptCursor from './SculptorTool/CircleSculptCursor';\nimport { distancePointToContour } from './distancePointToContour';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass SculptorTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            minSpacing: 1,\n            referencedToolNames: [\n                'PlanarFreehandROI',\n                'PlanarFreehandContourSegmentationTool',\n            ],\n            toolShape: 'circle',\n            referencedToolName: 'PlanarFreehandROI',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.registeredShapes = new Map();\n        this.isActive = false;\n        this.commonData = {\n            activeAnnotationUID: null,\n            viewportIdsToRender: [],\n            isEditingOpenContour: false,\n            canvasLocation: undefined,\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const element = eventData.element;\n            this.configureToolSize(evt);\n            this.selectFreehandTool(eventData);\n            if (this.commonData.activeAnnotationUID === null) {\n                return;\n            }\n            this.isActive = true;\n            hideElementCursor(element);\n            this.activateModify(element);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.configureToolSize(evt);\n                this.updateCursor(evt);\n            }\n            else {\n                this.commonData.canvasLocation = undefined;\n            }\n        };\n        this.endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const config = this.configuration;\n            const enabledElement = getEnabledElement(element);\n            this.isActive = false;\n            this.deactivateModify(element);\n            resetElementCursor(element);\n            const { renderingEngineId, viewportId } = enabledElement;\n            const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n            const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n            const annotations = this.filterSculptableAnnotationsForElement(element);\n            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n            if (toolInstance.configuration.calculateStats) {\n                activeAnnotation.invalidated = true;\n            }\n            triggerAnnotationModified(activeAnnotation, element);\n        };\n        this.dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const element = eventData.element;\n            this.updateCursor(evt);\n            const annotations = this.filterSculptableAnnotationsForElement(element);\n            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n            if (!annotations?.length || !this.isActive) {\n                return;\n            }\n            const points = activeAnnotation.data.contour.polyline;\n            this.sculpt(eventData, points);\n        };\n        this.registerShapes(CircleSculptCursor.shapeName, CircleSculptCursor);\n        this.setToolShape(this.configuration.toolShape);\n    }\n    registerShapes(shapeName, shapeClass) {\n        const shape = new shapeClass();\n        this.registeredShapes.set(shapeName, shape);\n    }\n    sculpt(eventData, points) {\n        const config = this.configuration;\n        const element = eventData.element;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        this.sculptData = {\n            mousePoint: eventData.currentPoints.world,\n            mouseCanvasPoint: eventData.currentPoints.canvas,\n            points,\n            maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),\n            element: element,\n        };\n        const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);\n        if (pushedHandles.first !== undefined) {\n            this.insertNewHandles(pushedHandles);\n        }\n    }\n    interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing) {\n        const { element } = this.sculptData;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const nextHandleIndex = contourIndex(i + 1, points.length);\n        const currentCanvasPoint = viewport.worldToCanvas(points[i]);\n        const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);\n        const distanceToNextHandle = point.distanceToPoint(currentCanvasPoint, nextCanvasPoint);\n        if (distanceToNextHandle > maxSpacing) {\n            indicesToInsertAfter.push(i);\n        }\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const element = eventData.element;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine, viewport } = enabledElement;\n        this.commonData.viewportIdsToRender = [viewport.id];\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n        this.commonData.canvasLocation = eventData.currentPoints.canvas;\n        if (this.isActive) {\n            activeAnnotation.highlighted = true;\n        }\n        else {\n            const cursorShape = this.registeredShapes.get(this.selectedShape);\n            const canvasCoords = eventData.currentPoints.canvas;\n            cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);\n        }\n        triggerAnnotationRenderForViewportIds(this.commonData.viewportIdsToRender);\n    }\n    filterSculptableAnnotationsForElement(element) {\n        const config = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngineId, viewportId } = enabledElement;\n        const sculptableAnnotations = [];\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n        config.referencedToolNames.forEach((referencedToolName) => {\n            const annotations = getAnnotations(referencedToolName, element);\n            if (annotations) {\n                sculptableAnnotations.push(...annotations);\n            }\n        });\n        return toolInstance.filterInteractableAnnotationsForElement(element, sculptableAnnotations);\n    }\n    configureToolSize(evt) {\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        cursorShape.configureToolSize(evt);\n    }\n    insertNewHandles(pushedHandles) {\n        const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);\n        let newIndexModifier = 0;\n        for (let i = 0; i < indicesToInsertAfter?.length; i++) {\n            const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;\n            this.insertHandleRadially(insertIndex);\n            newIndexModifier++;\n        }\n    }\n    findNewHandleIndices(pushedHandles) {\n        const { points, maxSpacing } = this.sculptData;\n        const indicesToInsertAfter = [];\n        for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {\n            this.interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing);\n        }\n        return indicesToInsertAfter;\n    }\n    insertHandleRadially(insertIndex) {\n        const { points } = this.sculptData;\n        if (insertIndex > points.length - 1 &&\n            this.commonData.isEditingOpenContour) {\n            return;\n        }\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        const previousIndex = insertIndex - 1;\n        const nextIndex = contourIndex(insertIndex, points.length);\n        const insertPosition = cursorShape.getInsertPosition(previousIndex, nextIndex, this.sculptData);\n        const handleData = insertPosition;\n        points.splice(insertIndex, 0, handleData);\n    }\n    selectFreehandTool(eventData) {\n        const closestAnnotationUID = this.getClosestFreehandToolOnElement(eventData);\n        if (closestAnnotationUID === undefined) {\n            return;\n        }\n        this.commonData.activeAnnotationUID = closestAnnotationUID;\n    }\n    getClosestFreehandToolOnElement(eventData) {\n        const { element } = eventData;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const config = this.configuration;\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const canvasPoints = eventData.currentPoints.canvas;\n        const closest = {\n            distance: Infinity,\n            toolIndex: undefined,\n            annotationUID: undefined,\n        };\n        for (let i = 0; i < annotations?.length; i++) {\n            if (annotations[i].isLocked || !annotations[i].isVisible) {\n                continue;\n            }\n            const distanceFromTool = distancePointToContour(viewport, annotations[i], canvasPoints);\n            if (distanceFromTool === -1) {\n                continue;\n            }\n            if (distanceFromTool < closest.distance) {\n                closest.distance = distanceFromTool;\n                closest.toolIndex = i;\n                closest.annotationUID = annotations[i].annotationUID;\n            }\n        }\n        this.commonData.isEditingOpenContour =\n            !annotations[closest.toolIndex].data.contour.closed;\n        config.referencedToolName =\n            annotations[closest.toolIndex].metadata.toolName;\n        return closest.annotationUID;\n    }\n    activateModify(element) {\n        element.addEventListener(Events.MOUSE_UP, this.endCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this.endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this.dragCallback);\n        element.addEventListener(Events.TOUCH_TAP, this.endCallback);\n        element.addEventListener(Events.TOUCH_END, this.endCallback);\n        element.addEventListener(Events.TOUCH_DRAG, this.dragCallback);\n    }\n    deactivateModify(element) {\n        element.removeEventListener(Events.MOUSE_UP, this.endCallback);\n        element.removeEventListener(Events.MOUSE_CLICK, this.endCallback);\n        element.removeEventListener(Events.MOUSE_DRAG, this.dragCallback);\n        element.removeEventListener(Events.TOUCH_TAP, this.endCallback);\n        element.removeEventListener(Events.TOUCH_END, this.endCallback);\n        element.removeEventListener(Events.TOUCH_DRAG, this.dragCallback);\n    }\n    setToolShape(toolShape) {\n        this.selectedShape =\n            this.registeredShapes.get(toolShape) ?? CircleSculptCursor.shapeName;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const viewportIdsToRender = this.commonData.viewportIdsToRender;\n        if (!this.commonData.canvasLocation ||\n            this.mode !== ToolModes.Active ||\n            !viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        let color = getStyleProperty('color', styleSpecifier, AnnotationStyleStates.Default, this.mode);\n        if (this.isActive) {\n            color = getStyleProperty('color', styleSpecifier, AnnotationStyleStates.Highlighted, this.mode);\n        }\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {\n            color,\n        });\n    }\n}\nexport const contourIndex = (i, length) => {\n    return (i + length) % length;\n};\nSculptorTool.toolName = 'SculptorTool';\nexport default SculptorTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nconst DIRECTIONS = {\n    X: [1, 0, 0],\n    Y: [0, 1, 0],\n    Z: [0, 0, 1],\n    CUSTOM: [],\n};\nclass VolumeRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            direction: DIRECTIONS.Z,\n            rotateIncrementDegrees: 30,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseWheelCallback(evt) {\n        const { element, wheel } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { direction, rotateIncrementDegrees } = this.configuration;\n        const camera = viewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n        const { direction: deltaY } = wheel;\n        const [cx, cy, cz] = focalPoint;\n        const [ax, ay, az] = direction;\n        const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;\n        const newPosition = [0, 0, 0];\n        const newFocalPoint = [0, 0, 0];\n        const newViewUp = [0, 0, 0];\n        const transform = mat4.identity(new Float32Array(16));\n        mat4.translate(transform, transform, [cx, cy, cz]);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        mat4.translate(transform, transform, [-cx, -cy, -cz]);\n        vec3.transformMat4(newPosition, position, transform);\n        vec3.transformMat4(newFocalPoint, focalPoint, transform);\n        mat4.identity(transform);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        vec3.transformMat4(newViewUp, viewUp, transform);\n        viewport.setCamera({\n            position: newPosition,\n            viewUp: newViewUp,\n            focalPoint: newFocalPoint,\n        });\n        viewport.render();\n    }\n}\nVolumeRotateTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, utilities, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nconst { transformWorldToIndex } = csUtils;\nclass LengthTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                    toolName: this.getToolName(),\n                    referencedImageId,\n                    viewUp,\n                    cameraPosition,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const dataId = `${annotationUID}-line`;\n                const lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const instance = new this();\n        const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions } = image;\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            const handles = [index1, index2];\n            const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);\n            const length = this._calculateLength(worldPos1, worldPos2) / scale;\n            this._isInsideVolume(index1, index2, dimensions)\n                ? (this.isHandleOutsideImage = false)\n                : (this.isHandleOutsideImage = true);\n            cachedStats[targetId] = {\n                length,\n                unit,\n            };\n        }\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, element);\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { length, unit } = cachedVolumeStats;\n    if (length === undefined || length === null || isNaN(length)) {\n        return;\n    }\n    const textLines = [`${csUtils.roundNumber(length)} ${unit}`];\n    return textLines;\n}\nLengthTool.toolName = 'Length';\nexport default LengthTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawHeight as drawHeightSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nconst { transformWorldToIndex } = csUtils;\nclass HeightTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                    toolName: this.getToolName(),\n                    referencedImageId,\n                    viewUp,\n                    cameraPosition,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const heightUID = '0';\n                drawHeightSvg(svgDrawingHelper, annotationUID, heightUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash: lineDash,\n                });\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateHeight(pos1, pos2) {\n        const dx = pos2[0] - pos1[0];\n        const dy = pos2[1] - pos1[1];\n        const dz = pos2[2] - pos1[2];\n        if (dx == 0) {\n            if (dy != 0) {\n                return Math.abs(dz);\n            }\n            else {\n                return 0;\n            }\n        }\n        else if (dy == 0) {\n            return Math.abs(dz);\n        }\n        else if (dz == 0) {\n            return Math.abs(dy);\n        }\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions } = image;\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            const handles = [index1, index2];\n            const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);\n            const height = this._calculateHeight(worldPos1, worldPos2) / scale;\n            const outside = this._isInsideVolume(index1, index2, dimensions);\n            this.isHandleOutsideImage = outside;\n            cachedStats[targetId] = {\n                height,\n                unit,\n            };\n        }\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, element);\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { height, unit } = cachedVolumeStats;\n    if (height === undefined || height === null || isNaN(height)) {\n        return;\n    }\n    const textLines = [`${csUtils.roundNumber(height)} ${unit}`];\n    return textLines;\n}\nHeightTool.toolName = 'Height';\nexport default HeightTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nconst { transformWorldToIndex } = csUtils;\nclass ProbeTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: { points: [[...worldPos]] },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { viewportId, renderingEngine } = getEnabledElement(element);\n            this.eventDispatchDetail = {\n                viewportId,\n                renderingEngineId: renderingEngine.id,\n            };\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            data.handles.points[0] = [...worldPos];\n            annotation.invalidated = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const annotationUID = annotation.annotationUID;\n                const data = annotation.data;\n                const point = data.handles.points[0];\n                const canvasCoordinates = viewport.worldToCanvas(point);\n                styleSpecifier.annotationUID = annotationUID;\n                const { color } = this.getAnnotationStyle({ annotation, styleSpecifier });\n                if (!data.cachedStats) {\n                    data.cachedStats = {};\n                }\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].value == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        index: null,\n                        value: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const handleGroupUID = '0';\n                drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (textLines) {\n                    const textCanvasCoordinates = [\n                        canvasCoordinates[0] + 6,\n                        canvasCoordinates[1] - 6,\n                    ];\n                    const textUID = '0';\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], options);\n                }\n            }\n            return renderStatus;\n        };\n    }\n    isPointNearTool() {\n        return false;\n    }\n    toolSelectedCallback() { }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const instance = new this();\n        const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const point = data.handles.points[0];\n        const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n        const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n        if (near === true) {\n            return point;\n        }\n    }\n    handleSelectedCallback(evt, annotation) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { renderingEngineId, viewport } = enabledElement;\n        const { element } = viewport;\n        const worldPos = data.handles.points[0];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const pixelUnitsOptions = {\n                isPreScaled: isViewportPreScaled(viewport, targetId),\n                isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n            };\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { dimensions, imageData, metadata, voxelManager } = image;\n            const modality = metadata.Modality;\n            let ijk = transformWorldToIndex(imageData, worldPos);\n            ijk = vec3.round(ijk, ijk);\n            if (csUtils.indexWithinDimensions(ijk, dimensions)) {\n                this.isHandleOutsideImage = false;\n                let value = voxelManager.getAtIJKPoint(ijk);\n                if (targetId.startsWith('imageId:')) {\n                    const imageId = targetId.split('imageId:')[1];\n                    const imageURI = csUtils.imageIdToURI(imageId);\n                    const viewports = csUtils.getViewportsWithImageURI(imageURI);\n                    const viewport = viewports[0];\n                    ijk[2] = viewport.getCurrentImageIdIndex();\n                }\n                let modalityUnit;\n                if (modality === 'US') {\n                    const calibratedResults = getCalibratedProbeUnitsAndValue(image, [\n                        ijk,\n                    ]);\n                    const hasEnhancedRegionValues = calibratedResults.values.every((value) => value !== null);\n                    value = (hasEnhancedRegionValues ? calibratedResults.values : value);\n                    modalityUnit = hasEnhancedRegionValues\n                        ? calibratedResults.units\n                        : 'raw';\n                }\n                else {\n                    modalityUnit = getPixelValueUnits(modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                }\n                cachedStats[targetId] = {\n                    index: ijk,\n                    value,\n                    Modality: modality,\n                    modalityUnit,\n                };\n            }\n            else {\n                this.isHandleOutsideImage = true;\n                cachedStats[targetId] = {\n                    index: ijk,\n                    Modality: modality,\n                };\n            }\n            annotation.invalidated = false;\n            triggerAnnotationModified(annotation, element);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, value, modalityUnit } = cachedVolumeStats;\n    if (value === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n    if (value instanceof Array && modalityUnit instanceof Array) {\n        for (let i = 0; i < value.length; i++) {\n            textLines.push(`${csUtils.roundNumber(value[i])} ${modalityUnit[i]}`);\n        }\n    }\n    else {\n        textLines.push(`${csUtils.roundNumber(value)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nProbeTool.toolName = 'Probe';\nexport default ProbeTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nclass DragProbeTool extends ProbeTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.postMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                isVisible: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: { points: [[...worldPos]] },\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.postTouchStartCallback = (evt) => {\n            return this.postMouseDownCallback(evt);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const annotations = this.filterInteractableAnnotationsForElement(viewport.element, [this.editData.annotation]);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const annotation = this.editData.annotation;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const point = data.handles.points[0];\n            const canvasCoordinates = viewport.worldToCanvas(point);\n            styleSpecifier.annotationUID = annotationUID;\n            const { color } = this.getAnnotationStyle({\n                annotation,\n                styleSpecifier,\n            });\n            if (!data.cachedStats[targetId] ||\n                data.cachedStats[targetId].value == null) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    index: null,\n                    value: null,\n                };\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });\n            renderStatus = true;\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (textLines) {\n                const textCanvasCoordinates = [\n                    canvasCoordinates[0] + 6,\n                    canvasCoordinates[1] - 6,\n                ];\n                const textUID = '0';\n                drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n            }\n            return renderStatus;\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, value, modalityUnit } = cachedVolumeStats;\n    if (value === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n    textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n    return textLines;\n}\nDragProbeTool.toolName = 'DragProbe';\nexport default DragProbeTool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawEllipseByCoordinates as drawEllipseSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { pointInEllipse, getCanvasEllipseCorners, } from '../../utilities/math/ellipse';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nconst { transformWorldToIndex } = csUtils;\nclass EllipticalROITool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            storePointData: false,\n            centerPointRadius: 0,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    initialRotation: viewport.getRotation(),\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                centerWorld: worldPos,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);\n            const [canvasPoint1, canvasPoint2] = canvasCorners;\n            const minorEllipse = {\n                left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,\n                top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,\n                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,\n                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,\n            };\n            const majorEllipse = {\n                left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,\n                top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,\n                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,\n                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,\n            };\n            const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);\n            const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);\n            if (pointInMajorEllipse && !pointInMinorEllipse) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            let centerCanvas;\n            let centerWorld;\n            let canvasWidth;\n            let canvasHeight;\n            let originalHandleCanvas;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                const { viewport } = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = viewport;\n                handleIndex = points.findIndex((p) => p === handle);\n                const pointsCanvas = points.map(worldToCanvas);\n                originalHandleCanvas = pointsCanvas[handleIndex];\n                canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n                canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n                centerCanvas = [\n                    (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n                    (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n                ];\n                centerWorld = canvasToWorld(centerCanvas);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                canvasWidth,\n                canvasHeight,\n                centerWorld,\n                originalHandleCanvas,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerWorld } = this.editData;\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];\n            const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];\n            const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { viewport } = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = viewport;\n            const { annotation, canvasWidth, canvasHeight, handleIndex, centerWorld, originalHandleCanvas, } = this.editData;\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            const { data } = annotation;\n            const { points } = data.handles;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0 || handleIndex === 1) {\n                const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - dYCanvas,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n                const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n                const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n                const canvasLeft = [\n                    centerCanvas[0] - newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n            }\n            else {\n                const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n                const canvasLeft = [\n                    centerCanvas[0] - dXCanvas,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + dXCanvas,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n                const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n                const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - newHalfCanvasHeight,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + newHalfCanvasHeight,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasCorners = (getCanvasEllipseCorners(canvasCoordinates));\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-ellipse`;\n                const ellipseUID = '0';\n                drawEllipseSvg(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);\n                    if (minRadius > 3 * centerPointRadius) {\n                        const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine) => {\n            const data = annotation.data;\n            const { element } = viewport;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasEllipseCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const post2Index = transformWorldToIndex(imageData, worldPos2);\n                post2Index[0] = Math.floor(post2Index[0]);\n                post2Index[1] = Math.floor(post2Index[1]);\n                post2Index[2] = Math.floor(post2Index[2]);\n                this.isHandleOutsideImage = !this._isInsideVolume(pos1Index, post2Index, dimensions);\n                const iMin = Math.min(pos1Index[0], post2Index[0]);\n                const iMax = Math.max(pos1Index[0], post2Index[0]);\n                const jMin = Math.min(pos1Index[1], post2Index[1]);\n                const jMax = Math.max(pos1Index[1], post2Index[1]);\n                const kMin = Math.min(pos1Index[2], post2Index[2]);\n                const kMax = Math.max(pos1Index[2], post2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const center = [\n                    (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                    (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                    (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                ];\n                const ellipseObj = {\n                    center,\n                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                };\n                const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                const handles = [pos1Index, post2Index];\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /\n                    scale /\n                    scale;\n                const pixelUnitsOptions = {\n                    isPreScaled: isViewportPreScaled(viewport, targetId),\n                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                };\n                const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                    boundsIJK,\n                    imageData,\n                    isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n                    returnPoints: this.configuration.storePointData,\n                });\n                const stats = this.configuration.statsCalculator.getStatistics();\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    mean: stats.mean?.value,\n                    max: stats.max?.value,\n                    stdDev: stats.stdDev?.value,\n                    statsArray: stats.array,\n                    pointsInShape,\n                    isEmptyArea,\n                    areaUnit,\n                    modalityUnit,\n                };\n            }\n            annotation.invalidated = false;\n            triggerAnnotationModified(annotation, element);\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    _pointInEllipseCanvas(ellipse, location) {\n        const xRadius = ellipse.width / 2;\n        const yRadius = ellipse.height / 2;\n        if (xRadius <= 0.0 || yRadius <= 0.0) {\n            return false;\n        }\n        const center = [ellipse.left + xRadius, ellipse.top + yRadius];\n        const normalized = [location[0] - center[0], location[1] - center[1]];\n        const inEllipse = (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n            (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n            1.0;\n        return inEllipse;\n    }\n    _getCanvasEllipseCenter(ellipseCanvasPoints) {\n        const [bottom, top, left, right] = ellipseCanvasPoints;\n        const topLeft = [left[0], top[1]];\n        const bottomRight = [right[0], bottom[1]];\n        return [\n            (topLeft[0] + bottomRight[0]) / 2,\n            (topLeft[1] + bottomRight[1]) / 2,\n        ];\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (mean) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (max) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (stdDev) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nEllipticalROITool.toolName = 'EllipticalROI';\nexport default EllipticalROITool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedAspect, getCalibratedLengthUnitsAndScale, } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROITool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            storePointData: false,\n            centerPointRadius: 0,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const radius = getCanvasCircleRadius(canvasCoordinates);\n            const radiusPoint = getCanvasCircleRadius([\n                canvasCoordinates[0],\n                canvasCoords,\n            ]);\n            if (Math.abs(radiusPoint - radius) < proximity / 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            data.handles.points = [\n                data.handles.points[0],\n                canvasToWorld(currentCanvasPoints),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => worldToCanvas(p));\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0) {\n                const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n                const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n                const canvasCenter = currentCanvasPoints;\n                const canvasEnd = [\n                    canvasCoordinates[1][0] + dXCanvas,\n                    canvasCoordinates[1][1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasCenter);\n                points[1] = canvasToWorld(canvasEnd);\n            }\n            else {\n                points[1] = canvasToWorld(currentCanvasPoints);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius(canvasCoordinates);\n                const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                        radius: null,\n                        radiusUnit: null,\n                        perimeter: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-circle`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const data = annotation.data;\n            const { element } = viewport;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = [\n                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                    ];\n                    const ellipseObj = {\n                        center,\n                        xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                        yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                        zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, unit, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const aspect = getCalibratedAspect(image);\n                    const area = Math.abs(Math.PI *\n                        (worldWidth / scale / 2) *\n                        (worldHeight / aspect / scale / 2));\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                        isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n                        boundsIJK,\n                        imageData,\n                        returnPoints: this.configuration.storePointData,\n                    });\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        max: stats.max?.value,\n                        stdDev: stats.stdDev?.value,\n                        statsArray: stats.array,\n                        pointsInShape: pointsInShape,\n                        isEmptyArea,\n                        areaUnit,\n                        radius: worldWidth / 2 / scale,\n                        radiusUnit: unit,\n                        perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            annotation.invalidated = false;\n            triggerAnnotationModified(annotation, element);\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const instance = new this();\n        const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { radius, radiusUnit, area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit, } = cachedVolumeStats;\n    const textLines = [];\n    if (radius) {\n        const radiusLine = isEmptyArea\n            ? `Radius: Oblique not supported`\n            : `Radius: ${csUtils.roundNumber(radius)} ${radiusUnit}`;\n        textLines.push(radiusLine);\n    }\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (mean) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (max) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (stdDev) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nCircleROITool.toolName = 'CircleROI';\nexport default CircleROITool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawLine } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCanvasCircleRadius } from '../../utilities/math/circle';\nimport { vec3 } from 'gl-matrix';\nconst CROSSHAIR_SIZE = 5;\nclass ETDRSGridTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            degrees: [45, 135, 225, 315],\n            diameters: [10, 30, 60],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                    },\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const center = viewport.worldToCanvas(points[0]);\n            const radius = getCanvasCircleRadius([center, canvasCoords]);\n            if (Math.abs(radius) < proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            data.handles.points = [\n                canvasToWorld(currentCanvasPoints),\n                canvasToWorld(currentCanvasPoints),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            const { deltaPoints } = eventDetail;\n            const worldPosDelta = deltaPoints.world;\n            const points = data.handles.points;\n            points.forEach((point) => {\n                point[0] += worldPosDelta[0];\n                point[1] += worldPosDelta[1];\n                point[2] += worldPosDelta[2];\n            });\n            annotation.invalidated = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => worldToCanvas(p));\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n            const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n            const canvasCenter = currentCanvasPoints;\n            const canvasEnd = [\n                canvasCoordinates[1][0] + dXCanvas,\n                canvasCoordinates[1][1] + dYCanvas,\n            ];\n            points[0] = canvasToWorld(canvasCenter);\n            points[1] = canvasToWorld(canvasEnd);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const { renderingEngine } = getEnabledElement(element);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                let lineUID = `${annotationUID}-crosshair-vertical`;\n                let start = [center[0], center[1] + CROSSHAIR_SIZE];\n                let end = [center[0], center[1] - CROSSHAIR_SIZE];\n                drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                lineUID = `${annotationUID}-crosshair-horizontal`;\n                start = [center[0] + CROSSHAIR_SIZE, center[1]];\n                end = [center[0] - CROSSHAIR_SIZE, center[1]];\n                drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                const diametersCanvas = this.configuration.diameters.map((diameter) => this.worldMeasureToCanvas(diameter, viewport));\n                for (let i = 0; i < diametersCanvas.length; i++) {\n                    const dataId = `${annotationUID}-circle-${i}`;\n                    const circleUID = `${annotationUID}-circle-${i}`;\n                    drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, diametersCanvas[i] / 2, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    }, dataId);\n                }\n                const degreesRad = (x) => (x * Math.PI) / 180;\n                const angleRadians = this.configuration.degrees.map((degree) => degreesRad(degree));\n                for (let i = 0; i < angleRadians.length; i++) {\n                    const lineUID = `${annotationUID}-line-${i}`;\n                    const start = [\n                        (Math.cos(angleRadians[i]) * diametersCanvas[0]) / 2 + center[0],\n                        (Math.sin(angleRadians[i]) * diametersCanvas[0]) / 2 + center[1],\n                    ];\n                    const end = [\n                        (Math.cos(angleRadians[i]) * diametersCanvas[2]) / 2 + center[0],\n                        (Math.sin(angleRadians[i]) * diametersCanvas[2]) / 2 + center[1],\n                    ];\n                    drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n    }\n    worldMeasureToCanvas(measurement, viewport) {\n        const p1 = viewport.canvasToWorld([\n            viewport.canvas.width / 2,\n            viewport.canvas.height / 2,\n        ]);\n        const { viewUp } = viewport.getCamera();\n        const p2 = vec3.scaleAndAdd(vec3.create(), p1, viewUp, measurement);\n        const p1Canvas = viewport.worldToCanvas(p1);\n        const p2Canvas = viewport.worldToCanvas(p2);\n        const distance = Math.sqrt(Math.pow(p2Canvas[0] - p1Canvas[0], 2) +\n            Math.pow(p2Canvas[1] - p1Canvas[1], 2));\n        return distance;\n    }\n}\nETDRSGridTool.toolName = 'ETDRSGrid';\nexport default ETDRSGridTool;\n","import { getEnabledElement, eventTarget, triggerEvent, utilities, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, getChildAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events, MouseBindings, KeyboardBindings, ChangeTypes, } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport * as math from '../../utilities/math';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport { CardinalSpline } from './splines/CardinalSpline';\nimport { LinearSpline } from './splines/LinearSpline';\nimport { CatmullRomSpline } from './splines/CatmullRomSpline';\nimport { BSpline } from './splines/BSpline';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\nconst SPLINE_MIN_POINTS = 3;\nconst SPLINE_CLICK_CLOSE_CURVE_DIST = 10;\nconst DEFAULT_SPLINE_CONFIG = {\n    resolution: 20,\n    controlPointAdditionDistance: 6,\n    controlPointDeletionDistance: 6,\n    showControlPointsConnectors: false,\n    controlPointAdditionEnabled: true,\n    controlPointDeletionEnabled: true,\n};\nvar SplineTypesEnum;\n(function (SplineTypesEnum) {\n    SplineTypesEnum[\"Cardinal\"] = \"CARDINAL\";\n    SplineTypesEnum[\"Linear\"] = \"LINEAR\";\n    SplineTypesEnum[\"CatmullRom\"] = \"CATMULLROM\";\n    SplineTypesEnum[\"BSpline\"] = \"BSPLINE\";\n})(SplineTypesEnum || (SplineTypesEnum = {}));\nvar SplineToolActions;\n(function (SplineToolActions) {\n    SplineToolActions[\"AddControlPoint\"] = \"addControlPoint\";\n    SplineToolActions[\"DeleteControlPoint\"] = \"deleteControlPoint\";\n})(SplineToolActions || (SplineToolActions = {}));\nclass SplineROITool extends ContourSegmentationBaseTool {\n    static { this.SplineTypes = SplineTypesEnum; }\n    static { this.Actions = SplineToolActions; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            spline: {\n                configuration: {\n                    [SplineTypesEnum.Cardinal]: {\n                        Class: CardinalSpline,\n                        scale: 0.5,\n                    },\n                    [SplineTypesEnum.CatmullRom]: {\n                        Class: CatmullRomSpline,\n                    },\n                    [SplineTypesEnum.Linear]: {\n                        Class: LinearSpline,\n                    },\n                    [SplineTypesEnum.BSpline]: {\n                        Class: BSpline,\n                        controlPointAdditionEnabled: false,\n                        controlPointDeletionEnabled: false,\n                        showControlPointsConnectors: true,\n                    },\n                },\n                type: SplineTypesEnum.CatmullRom,\n                drawPreviewEnabled: true,\n                lastControlPointDeletionKeys: ['Backspace', 'Delete'],\n            },\n            actions: {\n                [SplineToolActions.AddControlPoint]: {\n                    method: 'addControlPointCallback',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Primary,\n                            modifierKey: KeyboardBindings.Shift,\n                        },\n                    ],\n                },\n                [SplineToolActions.DeleteControlPoint]: {\n                    method: 'deleteControlPointCallback',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Primary,\n                            modifierKey: KeyboardBindings.Ctrl,\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.fireChangeOnUpdate = null;\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const { instance: spline } = annotation.data.spline;\n            return spline.isPointNearCurve(canvasCoords, proximity);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;\n            const { data } = annotation;\n            annotation.autoGenerated = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const image = this.getTargetImageData(this.getTargetId(enabledElement.viewport));\n            const { imageData, dimensions } = image;\n            this.isHandleOutsideImage = data.handles.points\n                .map((p) => utilities.transformWorldToIndex(imageData, p))\n                .some((index) => !utilities.indexWithinDimensions(index, dimensions));\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const changeType = newAnnotation\n                ? ChangeTypes.Completed\n                : ChangeTypes.HandlesUpdated;\n            if (!this.fireChangeOnUpdate) {\n                this.fireChangeOnUpdate = {\n                    annotationUID: annotation.annotationUID,\n                    changeType,\n                    contourHoleProcessingEnabled,\n                };\n            }\n            else {\n                this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;\n                this.fireChangeOnUpdate.changeType = changeType;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._keyDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const key = eventDetail.key ?? '';\n            const { lastControlPointDeletionKeys } = this.configuration.spline;\n            const deleteLastPoint = lastControlPointDeletionKeys.includes(key);\n            if (!deleteLastPoint) {\n                return;\n            }\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            if (data.handles.points.length === SPLINE_MIN_POINTS) {\n                this.cancel(element);\n                return;\n            }\n            else {\n                const controlPointIndex = data.handles.points.length - 1;\n                this._deleteControlPointByIndex(element, annotation, controlPointIndex);\n            }\n            evt.preventDefault();\n        };\n        this._mouseMoveCallback = (evt) => {\n            const { drawPreviewEnabled } = this.configuration.spline;\n            if (!drawPreviewEnabled) {\n                return;\n            }\n            const { element } = evt.detail;\n            const { renderingEngine } = getEnabledElement(element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._mouseDownCallback = (evt) => {\n            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            if (data.contour.closed) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const { canvas: canvasPoint, world: worldPoint } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            let closeContour = data.handles.points.length >= 2 && doubleClick;\n            let addNewPoint = true;\n            if (data.handles.points.length >= 3) {\n                const { instance: spline } = data.spline;\n                const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);\n                if (closestControlPoint?.index === 0) {\n                    addNewPoint = false;\n                    closeContour = true;\n                }\n            }\n            if (addNewPoint) {\n                data.handles.points.push(worldPoint);\n            }\n            data.contour.closed = data.contour.closed || closeContour;\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (data.contour.closed) {\n                this._endCallback(evt);\n            }\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                this.moveAnnotation(annotation, worldPosDelta);\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.triggerAnnotationCompleted = (annotation, contourHoleProcessingEnabled) => {\n            const eventType = Events.ANNOTATION_COMPLETED;\n            const eventDetail = {\n                annotation,\n                changeType: ChangeTypes.Completed,\n                contourHoleProcessingEnabled,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n                changeType,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled) => {\n            if (changeType === ChangeTypes.Completed) {\n                this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n            }\n            else {\n                this.triggerAnnotationModified(annotation, enabledElement, changeType);\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.KEY_DOWN, this._keyDownCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.KEY_DOWN, this._keyDownCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            if (!data.spline.instance.closed || !textboxStyle.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = 'textBox';\n            const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this.addControlPointCallback = (evt, annotation) => {\n            const { data } = annotation;\n            const splineType = data.spline.type;\n            const splineConfig = this._getSplineConfig(splineType);\n            const maxDist = splineConfig.controlPointAdditionDistance;\n            if (splineConfig.controlPointAdditionEnabled === false) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { instance: spline } = data.spline;\n            const canvasPos = evt.detail.currentPoints.canvas;\n            const closestPointInfo = spline.getClosestPoint(canvasPos);\n            if (closestPointInfo.distance > maxDist) {\n                return;\n            }\n            const { index, point: canvasPoint } = spline.addControlPointAtU(closestPointInfo.uValue);\n            data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));\n            annotation.invalidated = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.deleteControlPointCallback = (evt, annotation) => {\n            const splineType = annotation.data.spline.type;\n            const splineConfig = this._getSplineConfig(splineType);\n            const maxDist = splineConfig.controlPointDeletionDistance;\n            if (splineConfig.controlPointDeletionEnabled === false) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const { canvas: canvasPos } = currentPoints;\n            const { instance: spline } = annotation.data.spline;\n            const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPos, maxDist);\n            if (!closestControlPoint) {\n                return;\n            }\n            this._deleteControlPointByIndex(element, annotation, closestControlPoint.index);\n        };\n        this._calculateCachedStats = (annotation, element) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            if (!data.contour.closed) {\n                return;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { cachedStats } = data;\n            const { polyline: points } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                const { imageData } = image;\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);\n                    const topLeftBBWorld = viewport.canvasToWorld([\n                        canvasMinX,\n                        canvasMinY,\n                    ]);\n                    const topLeftBBIndex = utilities.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = utilities.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n                area *= deltaInX * deltaInY;\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    areaUnit,\n                };\n            }\n            this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes.StatsUpdated);\n            return cachedStats;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { canvas: canvasPos } = currentPoints;\n        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n            this.configuration.contourHoleAdditionModifierKey;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        const annotation = this.createAnnotation(evt);\n        this.isDrawing = true;\n        this.addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n            lastCanvasPoint: canvasPos,\n            contourHoleProcessingEnabled,\n        };\n        this._activateDraw(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    cancel(element) {\n        if (!this.isDrawing) {\n            return;\n        }\n        this.isDrawing = false;\n        this._deactivateDraw(element);\n        this._deactivateModify(element);\n        resetElementCursor(element);\n        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n        if (newAnnotation) {\n            removeAnnotation(annotation.annotationUID);\n        }\n        super.cancelAnnotation(annotation);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        this.editData = null;\n        return annotation.annotationUID;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper, annotationStyle } = renderContext;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { element } = viewport;\n        const annotation = renderContext.annotation;\n        const { annotationUID, data, highlighted } = annotation;\n        const { handles } = data;\n        const { points: controlPoints, activeHandleIndex } = handles;\n        const newAnnotation = this.editData?.newAnnotation;\n        const { lineWidth, lineDash, color, locked: annotationLocked, } = annotationStyle;\n        const canvasCoordinates = controlPoints.map((p) => worldToCanvas(p));\n        const { drawPreviewEnabled } = this.configuration.spline;\n        const splineType = annotation.data.spline.type;\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = annotation.data.spline.instance;\n        const childAnnotations = getChildAnnotations(annotation);\n        const missingAnnotation = childAnnotations.findIndex((it) => !it);\n        if (missingAnnotation !== -1) {\n            throw new Error(`Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`);\n        }\n        const splineAnnotationsGroup = [annotation, ...childAnnotations].filter((annotation) => this._isSplineROIAnnotation(annotation));\n        splineAnnotationsGroup.forEach((annotation) => {\n            const spline = this._updateSplineInstance(element, annotation);\n            const splinePolylineCanvas = spline.getPolylinePoints();\n            this.updateContourPolyline(annotation, {\n                points: splinePolylineCanvas,\n                closed: data.contour.closed,\n                targetWindingDirection: ContourWindingDirection.Clockwise,\n            }, viewport, { updateWindingDirection: data.contour.closed });\n        });\n        super.renderAnnotationInstance(renderContext);\n        if (!data.cachedStats[targetId] ||\n            data.cachedStats[targetId].areaUnit == null) {\n            data.cachedStats[targetId] = {\n                Modality: null,\n                area: null,\n                areaUnit: null,\n            };\n            this._calculateCachedStats(annotation, element);\n        }\n        else if (annotation.invalidated) {\n            this._throttledCalculateCachedStats(annotation, element);\n        }\n        let activeHandleCanvasCoords;\n        if (!annotationLocked && !this.editData && activeHandleIndex !== null) {\n            activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n        }\n        if (activeHandleCanvasCoords || newAnnotation || highlighted) {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                color,\n                lineWidth,\n                handleRadius: '3',\n            });\n        }\n        if (drawPreviewEnabled &&\n            spline.numControlPoints > 1 &&\n            this.editData?.lastCanvasPoint &&\n            !spline.closed) {\n            const { lastCanvasPoint } = this.editData;\n            const previewPolylinePoints = spline.getPreviewPolylinePoints(lastCanvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {\n                color: '#9EA0CA',\n                lineDash: lineDash,\n                lineWidth: 1,\n            });\n        }\n        if (splineConfig.showControlPointsConnectors) {\n            const controlPointsConnectors = [...canvasCoordinates];\n            if (spline.closed) {\n                controlPointsConnectors.push(canvasCoordinates[0]);\n            }\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'controlPointsConnectors', controlPointsConnectors, {\n                color: 'rgba(255, 255, 255, 0.5)',\n                lineWidth: 1,\n            });\n        }\n        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);\n        if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {\n            this.triggerChangeEvent(annotation, enabledElement, this.fireChangeOnUpdate.changeType, this.fireChangeOnUpdate.contourHoleProcessingEnabled);\n            this.fireChangeOnUpdate = null;\n        }\n        annotation.invalidated = false;\n        return true;\n    }\n    createInterpolatedSplineControl(annotation) {\n        if (annotation.data.handles.points?.length) {\n            return;\n        }\n        const { polyline } = annotation.data.contour;\n        if (!polyline || !polyline.length) {\n            return;\n        }\n        annotation.data.handles.points = [];\n        const { points } = annotation.data.handles;\n        const increment = Math.max(10, Math.floor(polyline.length / 20));\n        for (let i = 0; i < polyline.length - increment; i += increment) {\n            points.push(polyline[i]);\n        }\n        points.push(polyline[polyline.length - 1]);\n    }\n    createAnnotation(evt) {\n        const contourAnnotation = super.createAnnotation(evt);\n        const { world: worldPos } = evt.detail.currentPoints;\n        const { type: splineType } = this.configuration.spline;\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = new splineConfig.Class();\n        const createSpline = () => ({\n            type: splineConfig.type,\n            instance: spline,\n            resolution: splineConfig.resolution,\n        });\n        let onInterpolationComplete;\n        if (this.configuration.interpolation?.enabled) {\n            onInterpolationComplete = (annotation) => {\n                annotation.data.spline ||= createSpline();\n                this.createInterpolatedSplineControl(annotation);\n            };\n        }\n        return utilities.deepMerge(contourAnnotation, {\n            data: {\n                handles: {\n                    points: [[...worldPos]],\n                },\n                spline: createSpline(),\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n    }\n    _deleteControlPointByIndex(element, annotation, controlPointIndex) {\n        const enabledElement = getEnabledElement(element);\n        const { points: controlPoints } = annotation.data.handles;\n        if (controlPoints.length === 3) {\n            removeAnnotation(annotation.annotationUID);\n        }\n        else {\n            controlPoints.splice(controlPointIndex, 1);\n        }\n        const { renderingEngine } = enabledElement;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        annotation.invalidated = true;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    _isSplineROIAnnotation(annotation) {\n        return !!annotation.data?.spline;\n    }\n    _getSplineConfig(type) {\n        const { configuration: config } = this;\n        const splineConfigs = config.spline.configuration;\n        return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);\n    }\n    _updateSplineInstance(element, annotation) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { data } = annotation;\n        const { type: splineType, instance: spline } = annotation.data.spline;\n        const splineConfig = this._getSplineConfig(splineType);\n        const worldPoints = data.handles.points;\n        const canvasPoints = worldPoints.map(worldToCanvas);\n        const resolution = splineConfig.resolution !== undefined\n            ? parseInt(splineConfig.resolution)\n            : undefined;\n        const scale = splineConfig.scale !== undefined\n            ? parseFloat(splineConfig.scale)\n            : undefined;\n        spline.setControlPoints(canvasPoints);\n        spline.closed = !!data.contour.closed;\n        if (!spline.fixedResolution &&\n            resolution !== undefined &&\n            spline.resolution !== resolution) {\n            spline.resolution = resolution;\n            annotation.invalidated = true;\n        }\n        if (spline instanceof CardinalSpline &&\n            !spline.fixedScale &&\n            scale !== undefined &&\n            spline.scale !== scale) {\n            spline.scale = scale;\n            annotation.invalidated = true;\n        }\n        return spline;\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (points.length < SPLINE_MIN_POINTS) {\n            console.warn('Spline requires at least 3 control points');\n            return;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const instance = new this();\n        const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);\n        const splineType = options?.splineType || SplineTypesEnum.CatmullRom;\n        const splineConfig = instance._getSplineConfig(splineType);\n        const SplineClass = splineConfig.Class;\n        const splineInstance = new SplineClass();\n        const canvasPoints = points.map((point) => viewport.worldToCanvas(point));\n        splineInstance.setControlPoints(canvasPoints);\n        const splinePolylineCanvas = splineInstance.getPolylinePoints();\n        const splinePolylineWorld = splinePolylineCanvas.map((point) => viewport.canvasToWorld(point));\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n                label: '',\n                cachedStats: {},\n                spline: {\n                    type: splineType,\n                    instance: splineInstance,\n                },\n                contour: {\n                    closed: true,\n                    polyline: splinePolylineWorld,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: true,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, isEmptyArea, areaUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${utilities.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    return textLines;\n}\nSplineROITool.toolName = 'SplineROI';\nexport default SplineROITool;\n","import { utilities } from '@cornerstonejs/core';\nimport SplineROITool from './SplineROITool';\nclass SplineContourSegmentationTool extends SplineROITool {\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n            },\n        }, toolProps);\n        super(initialProps);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n}\nSplineContourSegmentationTool.toolName = 'SplineContourSegmentationTool';\nexport default SplineContourSegmentationTool;\n","import { vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, VolumeViewport, utilities, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { removeAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events, KeyboardBindings, ChangeTypes } from '../../enums';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport * as math from '../../utilities/math';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport findHandlePolylineIndex from '../../utilities/contours/findHandlePolylineIndex';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../stateManagement/annotation/helpers/state';\nimport { LivewireScissors } from '../../utilities/livewire/LivewireScissors';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getCalibratedLengthUnitsAndScale, throttle } from '../../utilities';\nconst CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2;\nclass LivewireContourTool extends ContourSegmentationBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            getTextLines: defaultGetTextLines,\n            calculateStats: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            snapHandleNearby: 2,\n            interpolation: {\n                enabled: false,\n                nearestEdge: 2,\n                showInterpolationPolyline: false,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            actions: {\n                undo: {\n                    method: 'undo',\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const proximitySquared = proximity * proximity;\n            const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            let startPoint = canvasPoints[canvasPoints.length - 1];\n            for (let i = 0; i < canvasPoints.length; i++) {\n                const endPoint = canvasPoints[i];\n                const distanceToPointSquared = math.lineSegment.distanceToPointSquared(startPoint, endPoint, canvasCoords);\n                if (distanceToPointSquared <= proximitySquared) {\n                    return true;\n                }\n                startPoint = endPoint;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt, clearAnnotation = false) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;\n            const { data } = annotation;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            if ((this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) ||\n                clearAnnotation) {\n                removeAnnotation(annotation.annotationUID);\n                this.clearEditData();\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                return;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            const changeType = newAnnotation\n                ? ChangeTypes.Completed\n                : ChangeTypes.HandlesUpdated;\n            this.triggerChangeEvent(annotation, enabledElement, changeType, contourHoleProcessingEnabled);\n            this.clearEditData();\n        };\n        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled = false) => {\n            if (changeType === ChangeTypes.Completed) {\n                triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n            }\n            else {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, changeType);\n            }\n        };\n        this._mouseDownCallback = (evt) => {\n            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n            const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld } = this.editData;\n            if (this.editData.closed) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;\n            let worldPos = worldPosOriginal;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const controlPoints = this.editData.currentPath.getControlPoints();\n            let closePath = controlPoints.length >= 2 && doubleClick;\n            if (controlPoints.length >= 2) {\n                const closestHandlePoint = {\n                    index: -1,\n                    distSquared: Infinity,\n                };\n                for (let i = 0, len = controlPoints.length; i < len; i++) {\n                    const controlPoint = controlPoints[i];\n                    const worldControlPoint = sliceToWorld(controlPoint);\n                    const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);\n                    const distSquared = math.point.distanceToPointSquared(canvasPos, canvasControlPoint);\n                    if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&\n                        distSquared < closestHandlePoint.distSquared) {\n                        closestHandlePoint.distSquared = distSquared;\n                        closestHandlePoint.index = i;\n                    }\n                }\n                if (closestHandlePoint.index === 0) {\n                    closePath = true;\n                }\n            }\n            const { snapHandleNearby } = this.configuration;\n            if (snapHandleNearby && !this.editData.closed) {\n                const currentPath = new LivewirePath();\n                const snapPoint = this.scissors.findMinNearby(worldToSlice(worldPosOriginal), 1);\n                const pathPoints = this.scissors.findPathToPoint(snapPoint);\n                currentPath.addPoints(pathPoints);\n                currentPath.prependPath(this.editData.confirmedPath);\n                worldPos = sliceToWorld(snapPoint);\n                this.editData.currentPath = currentPath;\n            }\n            this.editData.closed = this.editData.closed || closePath;\n            this.editData.confirmedPath = this.editData.currentPath;\n            const lastPoint = this.editData.currentPath.getLastPoint();\n            this.editData.confirmedPath.addControlPoint(lastPoint);\n            annotation.data.handles.points.push(sliceToWorld(lastPoint));\n            this.scissors.startSearch(worldToSlice(worldPos));\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (this.editData.closed) {\n                this.updateAnnotation(this.editData.confirmedPath);\n                this._endCallback(evt);\n            }\n            evt.preventDefault();\n        };\n        this._mouseMoveCallback = (evt) => {\n            const { element, currentPoints } = evt.detail;\n            const { world: worldPos, canvas: canvasPos } = currentPoints;\n            const { renderingEngine } = getEnabledElement(element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData.lastCanvasPoint = canvasPos;\n            const { width: imgWidth, height: imgHeight } = this.scissors;\n            const { worldToSlice } = this.editData;\n            const slicePoint = worldToSlice(worldPos);\n            if (slicePoint[0] < 0 ||\n                slicePoint[1] < 0 ||\n                slicePoint[0] >= imgWidth ||\n                slicePoint[1] >= imgHeight) {\n                return;\n            }\n            const pathPoints = this.scissors.findPathToPoint(slicePoint);\n            const currentPath = new LivewirePath();\n            currentPath.addPoints(pathPoints);\n            currentPath.prependPath(this.editData.confirmedPath);\n            this.editData.currentPath = currentPath;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                console.warn('Drag annotation not implemented');\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                this.editHandle(worldPos, element, annotation, handleIndex);\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            if (newAnnotation) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.editData = null;\n            this.scissors = null;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._calculateCachedStats = (annotation, element) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            if (!data.contour.closed) {\n                return;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const { cachedStats } = data;\n            const { polyline: points } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                const { imageData } = image;\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);\n                    const topLeftBBWorld = viewport.canvasToWorld([\n                        canvasMinX,\n                        canvasMinY,\n                    ]);\n                    const topLeftBBIndex = utilities.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = utilities.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n                area *= deltaInX * deltaInY;\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    areaUnit: areaUnit,\n                };\n            }\n            this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes.StatsUpdated);\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            if (!data.contour.closed || !textboxStyle.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = 'textBox';\n            const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n                changeType,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    setupBaseEditData(worldPos, element, annotation, nextPos, contourHoleProcessingEnabled) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        this.isDrawing = true;\n        const viewportImageData = viewport.getImageData();\n        const { imageData: vtkImageData } = viewportImageData;\n        let worldToSlice;\n        let sliceToWorld;\n        let width;\n        let height;\n        let scalarData;\n        if (!(viewport instanceof VolumeViewport)) {\n            width = viewportImageData.dimensions[0];\n            height = viewportImageData.dimensions[1];\n            worldToSlice = (point) => {\n                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n                return [ijkPoint[0], ijkPoint[1]];\n            };\n            sliceToWorld = (point) => csUtils.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);\n            scalarData = viewportImageData.scalarData;\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const sliceImageData = csUtils.getCurrentVolumeViewportSlice(viewport);\n            const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;\n            worldToSlice = (point) => {\n                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n                const slicePoint = vec3.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);\n                return [slicePoint[0], slicePoint[1]];\n            };\n            sliceToWorld = (point) => {\n                const ijkPoint = vec3.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);\n                return csUtils.transformIndexToWorld(vtkImageData, ijkPoint);\n            };\n            scalarData = sliceImageData.scalarData;\n            width = sliceImageData.width;\n            height = sliceImageData.height;\n        }\n        else {\n            throw new Error('Viewport not supported');\n        }\n        scalarData = csUtils.convertToGrayscale(scalarData, width, height);\n        const { voiRange } = viewport.getProperties();\n        const startPos = worldToSlice(worldPos);\n        this.scissors = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);\n        if (nextPos) {\n            this.scissorsNext = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);\n            this.scissorsNext.startSearch(worldToSlice(nextPos));\n        }\n        this.scissors.startSearch(startPos);\n        const newAnnotation = !nextPos;\n        const confirmedPath = new LivewirePath();\n        const currentPath = new LivewirePath();\n        const currentPathNext = newAnnotation ? undefined : new LivewirePath();\n        confirmedPath.addPoint(startPos);\n        confirmedPath.addControlPoint(startPos);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        const lastCanvasPoint = viewport.worldToCanvas(worldPos);\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            newAnnotation,\n            hasMoved: false,\n            lastCanvasPoint,\n            confirmedPath,\n            currentPath,\n            confirmedPathNext: currentPathNext,\n            closed: false,\n            handleIndex: this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,\n            worldToSlice,\n            sliceToWorld,\n            contourHoleProcessingEnabled,\n        };\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { world: worldPos } = currentPoints;\n        const annotation = this.createAnnotation(evt);\n        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n            this.configuration.contourHoleAdditionModifierKey;\n        this.setupBaseEditData(worldPos, element, annotation, undefined, contourHoleProcessingEnabled);\n        this.addAnnotation(annotation, element);\n        this._activateDraw(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(this.editData.viewportIdsToRender);\n        return annotation;\n    }\n    clearEditData() {\n        this.editData = null;\n        this.scissors = null;\n        this.scissorsNext = null;\n        this.isDrawing = false;\n    }\n    editHandle(worldPos, element, annotation, handleIndex) {\n        const { data } = annotation;\n        const { points: handlePoints } = data.handles;\n        const { length: numHandles } = handlePoints;\n        const previousHandle = handlePoints[(handleIndex - 1 + numHandles) % numHandles];\n        const nextHandle = handlePoints[(handleIndex + 1) % numHandles];\n        if (!this.editData?.confirmedPathNext) {\n            this.setupBaseEditData(previousHandle, element, annotation, nextHandle);\n            const { polyline } = data.contour;\n            const confirmedPath = new LivewirePath();\n            const confirmedPathNext = new LivewirePath();\n            const { worldToSlice } = this.editData;\n            const previousIndex = findHandlePolylineIndex(annotation, handleIndex - 1);\n            const nextIndex = findHandlePolylineIndex(annotation, handleIndex + 1);\n            if (nextIndex === -1 || previousIndex === -1) {\n                throw new Error(`Can't find handle index ${nextIndex === -1 && nextHandle} ${previousIndex === -1 && previousHandle}`);\n            }\n            if (handleIndex === 0) {\n                confirmedPathNext.addPoints(polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice));\n            }\n            else {\n                confirmedPath.addPoints(polyline.slice(0, previousIndex + 1).map(worldToSlice));\n                confirmedPathNext.addPoints(polyline.slice(nextIndex, polyline.length).map(worldToSlice));\n            }\n            this.editData.confirmedPath = confirmedPath;\n            this.editData.confirmedPathNext = confirmedPathNext;\n        }\n        const { editData, scissors } = this;\n        const { worldToSlice, sliceToWorld } = editData;\n        const { activeHandleIndex } = data.handles;\n        if (activeHandleIndex === null || activeHandleIndex === undefined) {\n            data.handles.activeHandleIndex = handleIndex;\n        }\n        else if (activeHandleIndex !== handleIndex) {\n            throw new Error(`Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`);\n        }\n        const slicePos = worldToSlice(worldPos);\n        if (slicePos[0] < 0 ||\n            slicePos[0] >= scissors.width ||\n            slicePos[1] < 0 ||\n            slicePos[1] >= scissors.height) {\n            return;\n        }\n        handlePoints[handleIndex] = sliceToWorld(slicePos);\n        const pathPointsLeft = scissors.findPathToPoint(slicePos);\n        const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);\n        const currentPath = new LivewirePath();\n        currentPath.prependPath(editData.confirmedPath);\n        if (handleIndex !== 0) {\n            currentPath.addPoints(pathPointsLeft);\n        }\n        currentPath.addPoints(pathPointsRight.reverse());\n        currentPath.appendPath(editData.confirmedPathNext);\n        if (handleIndex === 0) {\n            currentPath.addPoints(pathPointsLeft);\n        }\n        editData.currentPath = currentPath;\n        annotation.invalidated = true;\n        editData.hasMoved = true;\n        editData.closed = true;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        this.updateAnnotation(this.editData?.currentPath);\n        return super.renderAnnotation(enabledElement, svgDrawingHelper);\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const contourSegmentationAnnotation = super.createAnnotation(evt);\n        const { world: worldPos } = evt.detail.currentPoints;\n        const annotation = csUtils.deepMerge(contourSegmentationAnnotation, {\n            data: {\n                handles: {\n                    points: [[...worldPos]],\n                },\n            },\n        });\n        return annotation;\n    }\n    undo(element, config, evt) {\n        if (!this.editData) {\n            return;\n        }\n        this._endCallback(evt, true);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { annotation, enabledElement, svgDrawingHelper, annotationStyle, targetId, } = renderContext;\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const { worldToCanvas } = viewport;\n        const { annotationUID, data, highlighted } = annotation;\n        const { handles } = data;\n        const newAnnotation = this.editData?.newAnnotation;\n        const { lineWidth, lineDash, color } = annotationStyle;\n        if (highlighted ||\n            (newAnnotation &&\n                annotation.annotationUID === this.editData?.annotation?.annotationUID)) {\n            const handleGroupUID = '0';\n            const canvasHandles = handles.points.map(worldToCanvas);\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasHandles, {\n                color,\n                lineDash,\n                lineWidth,\n            });\n        }\n        super.renderAnnotationInstance(renderContext);\n        if (!data.cachedStats[targetId] ||\n            data.cachedStats[targetId].areaUnit == null) {\n            data.cachedStats[targetId] = {\n                Modality: null,\n                area: null,\n                areaUnit: null,\n            };\n            this._calculateCachedStats(annotation, element);\n        }\n        else if (annotation.invalidated) {\n            this._throttledCalculateCachedStats(annotation, element);\n        }\n        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);\n        return true;\n    }\n    updateAnnotation(livewirePath) {\n        if (!this.editData || !livewirePath) {\n            return;\n        }\n        const { annotation, sliceToWorld, worldToSlice, closed, newAnnotation } = this.editData;\n        let { pointArray: imagePoints } = livewirePath;\n        if (imagePoints.length > 1) {\n            imagePoints = [...imagePoints, imagePoints[0]];\n        }\n        const targetWindingDirection = newAnnotation && closed ? ContourWindingDirection.Clockwise : undefined;\n        this.updateContourPolyline(annotation, {\n            points: imagePoints,\n            closed,\n            targetWindingDirection,\n        }, {\n            canvasToWorld: sliceToWorld,\n            worldToCanvas: worldToSlice,\n        });\n    }\n}\nLivewireContourTool.toolName = 'LivewireContour';\nexport default LivewireContourTool;\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, areaUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    return textLines;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport LivewireContourTool from './LivewireContourTool';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../../enums';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\nclass LivewireContourSegmentationTool extends LivewireContourTool {\n    updateInterpolatedAnnotation(annotation, enabledElement) {\n        if (this.editData ||\n            !annotation.invalidated ||\n            !annotation.data.handles.interpolationSources) {\n            return;\n        }\n        annotation.data.contour.originalPolyline = annotation.data.contour.polyline;\n        queueMicrotask(() => {\n            if (!annotation.data.handles.interpolationSources) {\n                return;\n            }\n            const { points } = annotation.data.handles;\n            const { element } = enabledElement.viewport;\n            this.setupBaseEditData(points[0], element, annotation);\n            const { length: count } = points;\n            const { scissors } = this;\n            const { nearestEdge, repeatInterpolation } = this.configuration.interpolation;\n            annotation.data.handles.originalPoints = points;\n            const { worldToSlice, sliceToWorld } = this.editData;\n            const handleSmoothing = [];\n            if (nearestEdge) {\n                let lastPoint = worldToSlice(points[points.length - 1]);\n                points.forEach((point, hIndex) => {\n                    const testPoint = worldToSlice(point);\n                    lastPoint = testPoint;\n                    handleSmoothing.push(testPoint);\n                    scissors.startSearch(lastPoint);\n                    scissors.findPathToPoint(testPoint);\n                    scissors.findPathToPoint(worldToSlice(points[(hIndex + 3) % points.length]));\n                    const minPoint = scissors.findMinNearby(testPoint, nearestEdge);\n                    if (!csUtils.isEqual(testPoint, minPoint)) {\n                        handleSmoothing[hIndex] = minPoint;\n                        lastPoint = minPoint;\n                        points[hIndex] = sliceToWorld(minPoint);\n                    }\n                });\n            }\n            const acceptedPath = new LivewirePath();\n            for (let i = 0; i < count; i++) {\n                scissors.startSearch(worldToSlice(points[i]));\n                const path = scissors.findPathToPoint(worldToSlice(points[(i + 1) % count]));\n                acceptedPath.addPoints(path);\n            }\n            this.updateAnnotation(acceptedPath);\n            this.scissors = null;\n            this.scissorsNext = null;\n            this.editData = null;\n            annotation.data.handles.interpolationSources = null;\n            if (repeatInterpolation) {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.InterpolationUpdated);\n            }\n        });\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        const { annotationUID } = annotation;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { showInterpolationPolyline } = this.configuration.interpolation || {};\n        this.updateInterpolatedAnnotation?.(annotation, enabledElement);\n        const { originalPolyline } = annotation.data.contour;\n        const rendered = super.renderAnnotationInstance(renderContext);\n        if (showInterpolationPolyline &&\n            originalPolyline &&\n            annotation.autoGenerated) {\n            const polylineCanvasPoints = originalPolyline.map(worldToCanvas);\n            polylineCanvasPoints.push(polylineCanvasPoints[0]);\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'interpolationContour-0', polylineCanvasPoints, {\n                color: '#70ffff',\n                lineWidth: 1,\n                fillOpacity: 0,\n            });\n        }\n        return rendered;\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n}\nLivewireContourSegmentationTool.toolName = 'LivewireContourSegmentationTool';\nexport default LivewireContourSegmentationTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawArrow as drawArrowSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass ArrowAnnotateTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n            arrowFirst: true,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const { arrowFirst } = this.configuration;\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    text: '',\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        arrowFirst,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            if (newAnnotation) {\n                this.configuration.getTextCallback((text) => {\n                    if (!text) {\n                        removeAnnotation(annotation.annotationUID);\n                        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                        this.editData = null;\n                        this.isDrawing = false;\n                        return;\n                    }\n                    annotation.data.text = text;\n                    triggerAnnotationCompleted(annotation);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                });\n            }\n            else {\n                triggerAnnotationModified(annotation, element);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.touchTapCallback = (evt) => {\n            if (evt.detail.taps == 2) {\n                this.doubleClickCallback(evt);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.editData = null;\n            this.isDrawing = false;\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles, text } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineWidth,\n                    });\n                }\n                const arrowUID = '1';\n                if (this.configuration.arrowFirst) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                    });\n                }\n                else {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                    });\n                }\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!text) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [text], textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.text = updatedText;\n        const enabledElement = getEnabledElement(element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nArrowAnnotateTool.toolName = 'ArrowAnnotate';\nexport default ArrowAnnotateTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass AngleTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2, point3] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            if (!point3) {\n                return false;\n            }\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const line2 = {\n                start: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n                end: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n                this.editData.handleIndex = 2;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                this.angleStartedNotYetCompleted = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].angle == null) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotation.annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                let lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length !== 3) {\n                    return renderStatus;\n                }\n                lineUID = '2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        if (data.handles.points.length !== 3) {\n            return;\n        }\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const worldPos3 = data.handles.points[2];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const angle = angleBetweenLines([worldPos1, worldPos2], [worldPos2, worldPos3]);\n            const { dimensions, imageData } = this.getTargetImageData(targetId);\n            this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]\n                .map((worldPos) => csUtils.transformWorldToIndex(imageData, worldPos))\n                .some((index) => !csUtils.indexWithinDimensions(index, dimensions));\n            cachedStats[targetId] = {\n                angle: isNaN(angle) ? 'Incomplete Angle' : angle,\n            };\n        }\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, element);\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n    if (angle === undefined) {\n        return;\n    }\n    if (isNaN(angle)) {\n        return [`${angle}`];\n    }\n    const textLines = [\n        `${csUtils.roundNumber(angle)} ${String.fromCharCode(176)}`,\n    ];\n    return textLines;\n}\nAngleTool.toolName = 'Angle';\nexport default AngleTool;\n","import { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass CobbAngleTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            showArcLines: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\n                viewport,\n                points: data.handles.points,\n                canvasCoords,\n                proximity,\n            });\n            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType, canvasCoords, proximity = 6) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\n                viewport,\n                points: annotation.data.handles.points,\n                canvasCoords,\n                proximity,\n            });\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n                isNearFirstLine,\n                isNearSecondLine,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._mouseUpCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n                resetElementCursor(element);\n                this.editData.handleIndex = data.handles.points.length;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._mouseDownCallback = (evt) => {\n            const { annotation, handleIndex } = this.editData;\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { data } = annotation;\n            if (handleIndex === 1) {\n                data.handles.points[1] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[1][0] !== data.handles.points[0][0] ||\n                        data.handles.points[1][1] !== data.handles.points[0][0];\n                return;\n            }\n            if (handleIndex === 3) {\n                data.handles.points[3] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[3][0] !== data.handles.points[2][0] ||\n                        data.handles.points[3][1] !== data.handles.points[2][0];\n                this.angleStartedNotYetCompleted = false;\n                return;\n            }\n            this.editData.hasMoved = false;\n            hideElementCursor(element);\n            data.handles.points[2] = data.handles.points[3] = worldPos;\n            this.editData.handleIndex = data.handles.points.length - 1;\n        };\n        this._mouseDragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, isNearFirstLine, isNearSecondLine, } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined &&\n                (isNearFirstLine || isNearSecondLine)) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                if (isNearFirstLine) {\n                    const firstLinePoints = [points[0], points[1]];\n                    firstLinePoints.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                }\n                else if (isNearSecondLine) {\n                    const secondLinePoints = [points[2], points[3]];\n                    secondLinePoints.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                }\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            if (data.handles.points.length < 4) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.angleStartedNotYetCompleted = false;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].angle == null) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                        arc1Angle: null,\n                        arc2Angle: null,\n                        points: {\n                            world: {\n                                arc1Start: null,\n                                arc1End: null,\n                                arc2Start: null,\n                                arc2End: null,\n                                arc1Angle: null,\n                                arc2Angle: null,\n                            },\n                            canvas: {\n                                arc1Start: null,\n                                arc1End: null,\n                                arc2Start: null,\n                                arc2End: null,\n                                arc1Angle: null,\n                                arc2Angle: null,\n                            },\n                        },\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const firstLine = [canvasCoordinates[0], canvasCoordinates[1]];\n                const secondLine = [canvasCoordinates[2], canvasCoordinates[3]];\n                let lineUID = 'line1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, firstLine[0], firstLine[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length < 4) {\n                    return renderStatus;\n                }\n                lineUID = 'line2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, secondLine[0], secondLine[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                lineUID = 'linkLine';\n                const mid1 = midPoint2(firstLine[0], firstLine[1]);\n                const mid2 = midPoint2(secondLine[0], secondLine[1]);\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n                    color,\n                    lineWidth: '1',\n                    lineDash: '1,4',\n                });\n                const { arc1Start, arc1End, arc2End, arc2Start } = data.cachedStats[targetId].points.canvas;\n                const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\n                if (this.configuration.showArcLines) {\n                    lineUID = 'arc1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, arc1Start, arc1End, {\n                        color,\n                        lineWidth: '1',\n                    });\n                    lineUID = 'arc2';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, arc2Start, arc2End, {\n                        color,\n                        lineWidth: '1',\n                    });\n                }\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = 'cobbAngleText';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n                if (this.configuration.showArcLines) {\n                    const arc1TextBoxUID = 'arcAngle1';\n                    const arc1TextLine = [\n                        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n                    ];\n                    const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, arc1TextBoxUID, arc1TextLine, arch1TextPosCanvas, {\n                        ...options,\n                        padding: 3,\n                    });\n                    const arc2TextBoxUID = 'arcAngle2';\n                    const arc2TextLine = [\n                        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n                    ];\n                    const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, arc2TextBoxUID, arc2TextLine, arch2TextPosCanvas, {\n                        ...options,\n                        padding: 3,\n                    });\n                }\n            }\n            return renderStatus;\n        };\n        this.distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\n            const [point1, point2, point3, point4] = points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const canvasPoint4 = viewport.worldToCanvas(point4);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const line2 = {\n                start: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n                end: {\n                    x: canvasPoint4[0],\n                    y: canvasPoint4[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            let isNearFirstLine = false;\n            let isNearSecondLine = false;\n            if (distanceToPoint <= proximity) {\n                isNearFirstLine = true;\n            }\n            else if (distanceToPoint2 <= proximity) {\n                isNearSecondLine = true;\n            }\n            return {\n                distanceToPoint,\n                distanceToPoint2,\n                isNearFirstLine,\n                isNearSecondLine,\n            };\n        };\n        this.getArcsStartEndPoints = ({ firstLine, secondLine, mid1, mid2, }) => {\n            const linkLine = [mid1, mid2];\n            const arc1Angle = angleBetweenLines(firstLine, linkLine);\n            const arc2Angle = angleBetweenLines(secondLine, linkLine);\n            const arc1Side = arc1Angle > 90 ? 1 : 0;\n            const arc2Side = arc2Angle > 90 ? 0 : 1;\n            const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\n            const linkLineLength = Math.sqrt((linkLine[1][0] - linkLine[0][0]) ** 2 +\n                (linkLine[1][1] - linkLine[0][1]) ** 2);\n            const ratio = 0.1;\n            const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\n            const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\n            const directionVectorStartArc1 = [\n                firstLine[arc1Side][0] - midFirstLine[0],\n                firstLine[arc1Side][1] - midFirstLine[1],\n            ];\n            const magnitudeStartArc1 = Math.sqrt(directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2);\n            const normalizedDirectionStartArc1 = [\n                directionVectorStartArc1[0] / magnitudeStartArc1,\n                directionVectorStartArc1[1] / magnitudeStartArc1,\n            ];\n            const arc1Start = [\n                midFirstLine[0] +\n                    normalizedDirectionStartArc1[0] * linkLineLength * ratio,\n                midFirstLine[1] +\n                    normalizedDirectionStartArc1[1] * linkLineLength * ratio,\n            ];\n            const directionVectorEndArc1 = [\n                midLinkLine[0] - mid1[0],\n                midLinkLine[1] - mid1[1],\n            ];\n            const magnitudeEndArc1 = Math.sqrt(directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2);\n            const normalizedDirectionEndArc1 = [\n                directionVectorEndArc1[0] / magnitudeEndArc1,\n                directionVectorEndArc1[1] / magnitudeEndArc1,\n            ];\n            const arc1End = [\n                mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\n                mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\n            ];\n            const directionVectorStartArc2 = [\n                secondLine[arc2Side][0] - midSecondLine[0],\n                secondLine[arc2Side][1] - midSecondLine[1],\n            ];\n            const magnitudeStartArc2 = Math.sqrt(directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2);\n            const normalizedDirectionStartArc2 = [\n                directionVectorStartArc2[0] / magnitudeStartArc2,\n                directionVectorStartArc2[1] / magnitudeStartArc2,\n            ];\n            const arc2Start = [\n                midSecondLine[0] +\n                    normalizedDirectionStartArc2[0] * linkLineLength * ratio,\n                midSecondLine[1] +\n                    normalizedDirectionStartArc2[1] * linkLineLength * ratio,\n            ];\n            const directionVectorEndArc2 = [\n                midLinkLine[0] - mid2[0],\n                midLinkLine[1] - mid2[1],\n            ];\n            const magnitudeEndArc2 = Math.sqrt(directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2);\n            const normalizedDirectionEndArc2 = [\n                directionVectorEndArc2[0] / magnitudeEndArc2,\n                directionVectorEndArc2[1] / magnitudeEndArc2,\n            ];\n            const arc2End = [\n                mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\n                mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\n            ];\n            return {\n                arc1Start,\n                arc1End,\n                arc2Start,\n                arc2End,\n                arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\n                arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\n            };\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 25, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle, interactionType = 'mouse') {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        if (data.handles.points.length !== 4) {\n            return;\n        }\n        const seg1 = [null, null];\n        const seg2 = [null, null];\n        let minDist = Number.MAX_VALUE;\n        for (let i = 0; i < 2; i += 1) {\n            for (let j = 2; j < 4; j += 1) {\n                const dist = vec3.distance(data.handles.points[i], data.handles.points[j]);\n                if (dist < minDist) {\n                    minDist = dist;\n                    seg1[1] = data.handles.points[i];\n                    seg1[0] = data.handles.points[(i + 1) % 2];\n                    seg2[0] = data.handles.points[j];\n                    seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n                }\n            }\n        }\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const canvasPoints = data.handles.points.map((p) => viewport.worldToCanvas(p));\n        const firstLine = [canvasPoints[0], canvasPoints[1]];\n        const secondLine = [canvasPoints[2], canvasPoints[3]];\n        const mid1 = midPoint2(firstLine[0], firstLine[1]);\n        const mid2 = midPoint2(secondLine[0], secondLine[1]);\n        const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } = this.getArcsStartEndPoints({\n            firstLine,\n            secondLine,\n            mid1,\n            mid2,\n        });\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            cachedStats[targetId] = {\n                angle: angleBetweenLines(seg1, seg2),\n                arc1Angle,\n                arc2Angle,\n                points: {\n                    canvas: {\n                        arc1Start,\n                        arc1End,\n                        arc2End,\n                        arc2Start,\n                    },\n                    world: {\n                        arc1Start: viewport.canvasToWorld(arc1Start),\n                        arc1End: viewport.canvasToWorld(arc1End),\n                        arc2End: viewport.canvasToWorld(arc2End),\n                        arc2Start: viewport.canvasToWorld(arc2Start),\n                    },\n                },\n            };\n        }\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, element);\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n    if (angle === undefined) {\n        return;\n    }\n    const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n    return textLines;\n}\nCobbAngleTool.toolName = 'CobbAngle';\nexport default CobbAngleTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, StackViewport, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandle as drawHandleSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { distanceToPoint } from '../../utilities/math/point';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nconst { transformWorldToIndex } = csUtils;\nclass UltrasoundDirectionalTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            displayBothAxesDistances: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.startedDrawing) {\n                return;\n            }\n            this.startedDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('UltrasoundDirectionalTool can only be used on a StackViewport');\n            }\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            return false;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.startedDrawing && data.handles.points.length === 1) {\n                this.editData.handleIndex = 1;\n                return;\n            }\n            this.startedDrawing = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                this.startedDrawing = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].xValues == null) {\n                    data.cachedStats[targetId] = {\n                        xValues: [0, 0],\n                        yValues: [0, 0],\n                        isHorizontal: false,\n                        units: [''],\n                        isUnitless: false,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let handleGroupUID = '0';\n                drawHandleSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[0], {\n                    color,\n                }, 0);\n                renderStatus = true;\n                if (canvasCoordinates.length !== 2) {\n                    return renderStatus;\n                }\n                handleGroupUID = '1';\n                drawHandleSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[1], {\n                    color,\n                }, 1);\n                const isUnitless = data.cachedStats[targetId].isUnitless;\n                if (!isUnitless) {\n                    const canvasPoint1 = canvasCoordinates[0];\n                    const canvasPoint2 = canvasCoordinates[1];\n                    const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n                    const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n                    const isHorizontal = data.cachedStats[targetId].isHorizontal;\n                    let projectedPointCanvas = [0, 0];\n                    if (isHorizontal) {\n                        projectedPointCanvas = [\n                            canvasPoint1[0] + canvasDeltaX,\n                            canvasPoint1[1],\n                        ];\n                    }\n                    else {\n                        projectedPointCanvas = [\n                            canvasPoint1[0],\n                            canvasPoint1[1] + canvasDeltaY,\n                        ];\n                    }\n                    let dataId = `${annotationUID}-line-1`;\n                    let lineUID = '1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], projectedPointCanvas, {\n                        color,\n                        width: 1,\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                    dataId = `${annotationUID}-line-2`;\n                    lineUID = '2';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], projectedPointCanvas, {\n                        color,\n                        width: 1,\n                        lineDash: [1, 1],\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                }\n                else {\n                    const dataId = `${annotationUID}-line-1`;\n                    const lineUID = '1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: 1,\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId, this.configuration);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    toolSelectedCallback(evt, annotation, interactionType, canvasCoords) {\n        return;\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        this.editData = {\n            handleIndex,\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        if (data.handles.points.length !== 2) {\n            return;\n        }\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData } = image;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const imageIndex1 = transformWorldToIndex(imageData, worldPos1);\n            const imageIndex2 = transformWorldToIndex(imageData, worldPos2);\n            const { values: values1, units: units1 } = getCalibratedProbeUnitsAndValue(image, [imageIndex1]);\n            const { values: values2, units: units2 } = getCalibratedProbeUnitsAndValue(image, [imageIndex2]);\n            let xValues, yValues, units, isHorizontal;\n            let isUnitless = false;\n            if (units1[0] !== units2[0] ||\n                units1[1] !== units2[1] ||\n                (units1[0] === 'raw' && units2[0] === 'raw')) {\n                const value = distanceToPoint(worldPos1, worldPos2);\n                xValues = [value, 0];\n                yValues = [value, 0];\n                units = ['px'];\n                isUnitless = true;\n            }\n            else {\n                const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);\n                const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);\n                const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n                const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n                isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);\n                xValues = [values1[0], values2[0]];\n                yValues = [values1[1], values2[1]];\n                units = [units1[0], units1[1]];\n            }\n            cachedStats[targetId] = {\n                xValues,\n                yValues,\n                isHorizontal,\n                units,\n                isUnitless,\n            };\n        }\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, element);\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId, configuration) {\n    const cachedStats = data.cachedStats[targetId];\n    const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;\n    if (isUnitless) {\n        return [`${csUtils.roundNumber(xValues[0])} px`];\n    }\n    if (configuration.displayBothAxesDistances) {\n        const dist1 = Math.abs(xValues[1] - xValues[0]);\n        const dist2 = Math.abs(yValues[1] - yValues[0]);\n        return [\n            `${csUtils.roundNumber(dist1)} ${units[0]}`,\n            `${csUtils.roundNumber(dist2)} ${units[1]}`,\n        ];\n    }\n    if (isHorizontal) {\n        const dist = Math.abs(xValues[1] - xValues[0]);\n        return [`${csUtils.roundNumber(dist)} ${units[0]}`];\n    }\n    else {\n        const dist = Math.abs(yValues[1] - yValues[0]);\n        return [`${csUtils.roundNumber(dist)} ${units[1]}`];\n    }\n}\nUltrasoundDirectionalTool.toolName = 'UltrasoundDirectionalTool';\nexport default UltrasoundDirectionalTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawArrow as drawArrowSvg } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor } from '../../cursors/elementCursor';\nclass KeyImageTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            getTextCallback,\n            changeTextCallback,\n            canvasPosition: [10, 10],\n            canvasSize: 10,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = KeyImageTool.createAnnotation({\n                metadata: { ...viewport.getViewReference(), referencedImageId },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.configuration.getTextCallback((text) => {\n                if (!text) {\n                    removeAnnotation(annotation.annotationUID);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                    this.isDrawing = false;\n                    return;\n                }\n                annotation.data.text = text;\n                triggerAnnotationCompleted(annotation);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            });\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { canvasPosition, canvasSize } = this.configuration;\n            if (!canvasPosition?.length) {\n                return false;\n            }\n            if (Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=\n                canvasSize / 2 &&\n                Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=\n                    canvasSize / 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            annotation.highlighted = true;\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.isDrawing = false;\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID } = annotation;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { canvasPosition, canvasSize } = this.configuration;\n                if (canvasPosition?.length) {\n                    const arrowUID = '1';\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasPosition.map((it) => it + canvasSize), canvasPosition, {\n                        color,\n                        width: 1,\n                    });\n                }\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n            }\n            return renderStatus;\n        };\n    }\n    cancel() {\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n    }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.text = updatedText;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nKeyImageTool.toolName = 'KeyImage';\nexport default KeyImageTool;\n","import { BaseTool } from './base';\nimport { getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { setAnnotationSelected } from '../stateManagement/annotation/annotationSelection';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass AnnotationEraserTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            return this._deleteNearbyAnnotations(evt, 'mouse');\n        };\n        this.preTouchStartCallback = (evt) => {\n            return this._deleteNearbyAnnotations(evt, 'touch');\n        };\n    }\n    _deleteNearbyAnnotations(evt, interactionType) {\n        const { renderingEngineId, viewportId, element, currentPoints } = evt.detail;\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        if (!toolGroup) {\n            return false;\n        }\n        const tools = toolGroup._toolInstances;\n        const annotationsToRemove = [];\n        for (const toolName in tools) {\n            const toolInstance = tools[toolName];\n            if (typeof toolInstance.isPointNearTool !== 'function' ||\n                typeof toolInstance.filterInteractableAnnotationsForElement !==\n                    'function') {\n                continue;\n            }\n            const annotations = getAnnotations(toolName, element);\n            if (!annotations.length) {\n                continue;\n            }\n            const interactableAnnotations = toolInstance.filterInteractableAnnotationsForElement(element, annotations) || [];\n            for (const annotation of interactableAnnotations) {\n                if (toolInstance.isPointNearTool(element, annotation, currentPoints.canvas, 10, interactionType)) {\n                    annotationsToRemove.push(annotation.annotationUID);\n                }\n            }\n        }\n        for (const annotationUID of annotationsToRemove) {\n            setAnnotationSelected(annotationUID);\n            removeAnnotation(annotationUID);\n        }\n        evt.preventDefault();\n        return true;\n    }\n}\nAnnotationEraserTool.toolName = 'Eraser';\nexport default AnnotationEraserTool;\n","import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, getStackSegmentationImageIdsForViewport, } from '../../stateManagement/segmentation/segmentationState';\nclass RectangleScissorsTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideRectangle,\n                ERASE_INSIDE: eraseInsideRectangle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeLabelmapSegmentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeLabelmapSegmentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeLabelmapSegmentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData[SegmentationRepresentations.Labelmap];\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                this.editData = {\n                    ...this.editData,\n                    imageId: segmentationImageId,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            points[handleIndex] = [...worldPos];\n            let bottomLeftCanvas;\n            let bottomRightCanvas;\n            let topLeftCanvas;\n            let topRightCanvas;\n            let bottomLeftWorld;\n            let bottomRightWorld;\n            let topLeftWorld;\n            let topRightWorld;\n            switch (handleIndex) {\n                case 0:\n                case 3:\n                    bottomLeftCanvas = worldToCanvas(points[0]);\n                    topRightCanvas = worldToCanvas(points[3]);\n                    bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                    topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                    bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                    topLeftWorld = canvasToWorld(topLeftCanvas);\n                    points[1] = bottomRightWorld;\n                    points[2] = topLeftWorld;\n                    break;\n                case 1:\n                case 2:\n                    bottomRightCanvas = worldToCanvas(points[1]);\n                    topLeftCanvas = worldToCanvas(points[2]);\n                    bottomLeftCanvas = [\n                        topLeftCanvas[0],\n                        bottomRightCanvas[1],\n                    ];\n                    topRightCanvas = [bottomRightCanvas[0], topLeftCanvas[1]];\n                    bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                    topRightWorld = canvasToWorld(topRightCanvas);\n                    points[0] = bottomLeftWorld;\n                    points[3] = topRightWorld;\n                    break;\n            }\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const rectangleUID = '0';\n            drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n","import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, config as segmentationConfig, } from '../../stateManagement/segmentation';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nclass CircleScissorsTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideCircle,\n                ERASE_INSIDE: eraseInsideCircle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeLabelmapSegmentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeLabelmapSegmentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeLabelmapSegmentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData.Labelmap;\n            if (!labelmapData) {\n                throw new Error('No labelmap data found for the active segmentation, create one before using scissors tool');\n            }\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    isDrawing: true,\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                this.editData = {\n                    ...this.editData,\n                    imageId: segmentationImageId,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                viewPlaneNormal,\n                viewUp,\n                strategySpecificConfiguration: {},\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n","import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nclass SphereScissorsTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideSphere,\n                ERASE_INSIDE: eraseInsideSphere,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            this.isDrawing = true;\n            const annotation = {\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    invalidated: true,\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    highlighted: true,\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                toolGroupId: this.toolGroupId,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData[SegmentationRepresentations.Labelmap];\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                this.editData = {\n                    ...this.editData,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved, segmentIndex, segmentsLocked, } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                segmentIndex,\n                segmentsLocked,\n                viewPlaneNormal,\n                viewUp,\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n","import { StackViewport, cache, getEnabledElement, utilities as csUtils, utilities as coreUtils, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, removeAnnotation, getAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport throttle from '../../utilities/throttle';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor, resetElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport CircleROITool from '../annotation/CircleROITool';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { getCalibratedLengthUnitsAndScale, getCalibratedAspect, } from '../../utilities/getCalibratedUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROIStartEndThresholdTool extends CircleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            numSlicesToPropagate: 10,\n            calculatePointsInsideVolume: false,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            showTextBox: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            let referencedImageId, imageVolume, volumeId;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Stack Viewport Not implemented');\n            }\n            else {\n                const targetId = this.getTargetId(viewport);\n                volumeId = csUtils.getVolumeId(targetId);\n                imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const spacingInNormal = csUtils.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n            const startCoord = this._getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    volumeId,\n                    spacingInNormal,\n                    enabledElement,\n                },\n                data: {\n                    label: '',\n                    startCoordinate: startCoord,\n                    endCoordinate: endCoord,\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {\n                        pointsInVolume: [],\n                        projectionPoints: [],\n                        statistics: [],\n                    },\n                    labelmapUID: null,\n                },\n            };\n            this._computeProjectionPoints(annotation, imageVolume);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const targetId = this.getTargetId(enabledElement.viewport);\n            const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n            if (this.configuration.calculatePointsInsideVolume) {\n                this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            let annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = filterAnnotationsWithinSamePlane(annotations, viewport.getCamera());\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { startCoordinate, endCoordinate } = data;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius(canvasCoordinates);\n                const { centerPointRadius } = this.configuration;\n                const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n                const focalPoint = viewport.getCamera().focalPoint;\n                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n                let tempStartCoordinate = startCoordinate;\n                let tempEndCoordinate = endCoordinate;\n                if (Array.isArray(startCoordinate)) {\n                    tempStartCoordinate = this._getCoordinateForViewplaneNormal(tempStartCoordinate, viewplaneNormal);\n                    data.startCoordinate = tempStartCoordinate;\n                }\n                if (Array.isArray(endCoordinate)) {\n                    tempEndCoordinate = this._getCoordinateForViewplaneNormal(tempEndCoordinate, viewplaneNormal);\n                    data.endCoordinate = tempEndCoordinate;\n                }\n                const roundedStartCoordinate = coreUtils.roundToPrecision(data.startCoordinate);\n                const roundedEndCoordinate = coreUtils.roundToPrecision(data.endCoordinate);\n                const cameraCoordinate = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);\n                const roundedCameraCoordinate = coreUtils.roundToPrecision(cameraCoordinate);\n                if (roundedCameraCoordinate <\n                    Math.min(roundedStartCoordinate, roundedEndCoordinate) ||\n                    roundedCameraCoordinate >\n                        Math.max(roundedStartCoordinate, roundedEndCoordinate)) {\n                    continue;\n                }\n                const middleCoordinate = coreUtils.roundToPrecision((data.startCoordinate + data.endCoordinate) / 2);\n                let isMiddleSlice = false;\n                if (roundedCameraCoordinate === middleCoordinate) {\n                    isMiddleSlice = true;\n                }\n                data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = middleCoordinate;\n                if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    isMiddleSlice) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                let lineWidthToUse = lineWidth;\n                let lineDashToUse = lineDash;\n                if (isMiddleSlice) {\n                    lineWidthToUse = lineWidth;\n                    lineDashToUse = [];\n                }\n                else {\n                    lineDashToUse = [5, 5];\n                }\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash: lineDashToUse,\n                    lineWidth: lineWidthToUse,\n                });\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                if (this.configuration.showTextBox == true &&\n                    this.configuration.calculatePointsInsideVolume == true) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data);\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    let canvasTextBoxCoords;\n                    if (!data.handles.textBox.hasMoved) {\n                        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStatsTool, 100, { trailing: true });\n    }\n    _computeProjectionPoints(annotation, imageVolume) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, spacingInNormal } = metadata;\n        const { imageData } = imageVolume;\n        const { startCoordinate, endCoordinate } = data;\n        const { points } = data.handles;\n        const startIJK = transformWorldToIndex(imageData, points[0]);\n        const endIJK = transformWorldToIndex(imageData, points[0]);\n        const handlesToStart = csUtils.deepClone(points);\n        const startWorld = vec3.create();\n        imageData.indexToWorldVec3(startIJK, startWorld);\n        const endWorld = vec3.create();\n        imageData.indexToWorldVec3(endIJK, endWorld);\n        if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {\n            startWorld[2] = startCoordinate;\n            endWorld[2] = endCoordinate;\n            handlesToStart[0][2] = startCoordinate;\n            handlesToStart[1][2] = startCoordinate;\n        }\n        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0) {\n            startWorld[0] = startCoordinate;\n            endWorld[0] = endCoordinate;\n            handlesToStart[0][0] = startCoordinate;\n            handlesToStart[1][0] = startCoordinate;\n        }\n        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1) {\n            startWorld[1] = startCoordinate;\n            endWorld[1] = endCoordinate;\n            handlesToStart[0][1] = startCoordinate;\n            handlesToStart[1][1] = startCoordinate;\n        }\n        const distance = vec3.distance(startWorld, endWorld);\n        const newProjectionPoints = [];\n        for (let dist = 0; dist < distance; dist += spacingInNormal) {\n            newProjectionPoints.push(handlesToStart.map((point) => {\n                const newPoint = vec3.create();\n                vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n                return Array.from(newPoint);\n            }));\n        }\n        data.cachedStats.projectionPoints = newProjectionPoints;\n    }\n    _computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, viewUp } = metadata;\n        const { viewport } = enabledElement;\n        const projectionPoints = data.cachedStats.projectionPoints;\n        const pointsInsideVolume = [[]];\n        const image = this.getTargetImageData(targetId);\n        const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n        const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners(canvasCoordinates));\n        const pos1 = viewport.canvasToWorld(topLeftCanvas);\n        const pos2 = viewport.canvasToWorld(bottomRightCanvas);\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, pos1, pos2);\n        const measureInfo = getCalibratedLengthUnitsAndScale(image, data.handles);\n        const aspect = getCalibratedAspect(image);\n        const area = Math.abs(Math.PI *\n            (worldWidth / measureInfo.scale / 2) *\n            (worldHeight / aspect / measureInfo.scale / 2));\n        const modalityUnitOptions = {\n            isPreScaled: isViewportPreScaled(viewport, targetId),\n            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n        };\n        const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n        for (let i = 0; i < projectionPoints.length; i++) {\n            if (!imageVolume) {\n                continue;\n            }\n            const centerWorld = projectionPoints[i][0];\n            const canvasCoordinates = projectionPoints[i].map((p) => viewport.worldToCanvas(p));\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            const { dimensions, imageData, voxelManager } = imageVolume;\n            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n            const worldProjectionPointIndex = transformWorldToIndex(imageData, centerWorld);\n            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n            worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n            worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n            worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n            worldPos1Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n            worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n            worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n            worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n            worldPos2Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const center = centerWorld;\n                const ellipseObj = {\n                    center,\n                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                };\n                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                    isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS),\n                    boundsIJK,\n                    imageData,\n                    returnPoints: this.configuration.storePointData,\n                });\n                pointsInsideVolume.push(pointsInShape);\n            }\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        data.cachedStats.pointsInVolume = pointsInsideVolume;\n        data.cachedStats.statistics = {\n            Modality: metadata.Modality,\n            area,\n            mean: stats.mean?.value,\n            stdDev: stats.stdDev?.value,\n            max: stats.max?.value,\n            statsArray: stats.array,\n            areaUnit: measureInfo.areaUnit,\n            modalityUnit,\n        };\n    }\n    _calculateCachedStatsTool(annotation, enabledElement) {\n        const data = annotation.data;\n        const { viewport } = enabledElement;\n        const { cachedStats } = data;\n        const targetId = this.getTargetId(viewport);\n        const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n        this._computeProjectionPoints(annotation, imageVolume);\n        if (this.configuration.calculatePointsInsideVolume) {\n            this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);\n        }\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, viewport.element);\n        return cachedStats;\n    }\n    _getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\n        const startPos = vec3.create();\n        vec3.scaleAndAdd(startPos, worldPos, viewPlaneNormal, numSlicesToPropagateFromStart * -spacingInNormal);\n        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);\n        return startCoord;\n    }\n    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const numSlicesToPropagateToEnd = numSlicesToPropagate - Math.round(numSlicesToPropagate / 2);\n        const endPos = vec3.create();\n        vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagateToEnd * spacingInNormal);\n        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);\n        return endCoord;\n    }\n    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {\n        const viewplaneNormalAbs = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));\n        return indexOfDirection;\n    }\n    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {\n        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        return pos[indexOfDirection];\n    }\n}\nfunction defaultGetTextLines(data) {\n    const cachedVolumeStats = data.cachedStats.statistics;\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nCircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';\nexport default CircleROIStartEndThresholdTool;\n","import { cache, getEnabledElement, utilities as csUtils, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, } from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nconst { transformWorldToIndex, isEqual } = csUtils;\nclass PaintFillTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal } = camera;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const { representationData } = getSegmentation(segmentationId);\n            let dimensions;\n            let direction;\n            let scalarData;\n            let index;\n            let voxelManager;\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n                const segmentation = cache.getVolume(volumeId);\n                ({ dimensions, direction } = segmentation);\n                voxelManager = segmentation.voxelManager;\n                index = transformWorldToIndex(segmentation.imageData, worldPos);\n            }\n            else {\n                const currentSegmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                if (!currentSegmentationImageId) {\n                    throw new Error('No active segmentation imageId detected, create one before using scissors tool');\n                }\n                const { imageData } = viewport.getImageData();\n                dimensions = imageData.getDimensions();\n                direction = imageData.getDirection();\n                const image = cache.getImage(currentSegmentationImageId);\n                voxelManager = image.voxelManager;\n                index = transformWorldToIndex(imageData, worldPos);\n            }\n            const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);\n            if (fixedDimension === undefined) {\n                console.warn('Oblique paint fill not yet supported');\n                return;\n            }\n            const { floodFillGetter, getLabelValue, getScalarDataPositionFromPlane, inPlaneSeedPoint, fixedDimensionValue, } = this.generateHelpers(voxelManager, dimensions, index, fixedDimension);\n            if (index[0] < 0 ||\n                index[0] >= dimensions[0] ||\n                index[1] < 0 ||\n                index[1] >= dimensions[1] ||\n                index[2] < 0 ||\n                index[2] >= dimensions[2]) {\n                return;\n            }\n            const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n            if (segmentsLocked.includes(clickedLabelValue)) {\n                return;\n            }\n            const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n            const { flooded } = floodFillResult;\n            flooded.forEach((index) => {\n                const scalarDataIndex = getScalarDataPositionFromPlane(index[0], index[1]);\n                voxelManager.setAtIndex(scalarDataIndex, segmentIndex);\n            });\n            const framesModified = this.getFramesModified(fixedDimension, fixedDimensionValue, floodFillResult);\n            triggerSegmentationDataModified(segmentationId, framesModified);\n            return true;\n        };\n        this.getFramesModified = (fixedDimension, fixedDimensionValue, floodFillResult) => {\n            const { boundaries } = floodFillResult;\n            if (fixedDimension === 2) {\n                return [fixedDimensionValue];\n            }\n            let minJ = Infinity;\n            let maxJ = -Infinity;\n            for (let b = 0; b < boundaries.length; b++) {\n                const j = boundaries[b][1];\n                if (j < minJ) {\n                    minJ = j;\n                }\n                if (j > maxJ) {\n                    maxJ = j;\n                }\n            }\n            const framesModified = [];\n            for (let frame = minJ; frame <= maxJ; frame++) {\n                framesModified.push(frame);\n            }\n            return framesModified;\n        };\n        this.generateHelpers = (voxelManager, dimensions, seedIndex3D, fixedDimension = 2) => {\n            let fixedDimensionValue;\n            let inPlaneSeedPoint;\n            switch (fixedDimension) {\n                case 0:\n                    fixedDimensionValue = seedIndex3D[0];\n                    inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]];\n                    break;\n                case 1:\n                    fixedDimensionValue = seedIndex3D[1];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]];\n                    break;\n                case 2:\n                    fixedDimensionValue = seedIndex3D[2];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]];\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            const getScalarDataPosition = (x, y, z) => {\n                return voxelManager.toIndex([x, y, z]);\n            };\n            const getLabelValue = (x, y, z) => {\n                return voxelManager.getAtIJK(x, y, z);\n            };\n            const floodFillGetter = this.generateFloodFillGetter(dimensions, fixedDimension, fixedDimensionValue, getLabelValue);\n            const getScalarDataPositionFromPlane = this.generateGetScalarDataPositionFromPlane(getScalarDataPosition, fixedDimension, fixedDimensionValue);\n            return {\n                getScalarDataPositionFromPlane,\n                getLabelValue,\n                floodFillGetter,\n                inPlaneSeedPoint,\n                fixedDimensionValue,\n            };\n        };\n        this.generateFloodFillGetter = (dimensions, fixedDimension, fixedDimensionValue, getLabelValue) => {\n            let floodFillGetter;\n            switch (fixedDimension) {\n                case 0:\n                    floodFillGetter = (y, z) => {\n                        if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    floodFillGetter = (x, z) => {\n                        if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    floodFillGetter = (x, y) => {\n                        if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return floodFillGetter;\n        };\n        this.generateGetScalarDataPositionFromPlane = (getScalarDataPosition, fixedDimension, fixedDimensionValue) => {\n            let getScalarDataPositionFromPlane;\n            switch (fixedDimension) {\n                case 0:\n                    getScalarDataPositionFromPlane = (y, z) => {\n                        return getScalarDataPosition(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    getScalarDataPositionFromPlane = (x, z) => {\n                        return getScalarDataPosition(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    getScalarDataPositionFromPlane = (x, y) => {\n                        return getScalarDataPosition(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return getScalarDataPositionFromPlane;\n        };\n    }\n    getFixedDimension(viewPlaneNormal, direction) {\n        const xDirection = direction.slice(0, 3);\n        const yDirection = direction.slice(3, 6);\n        const zDirection = direction.slice(6, 9);\n        const absoluteOfViewPlaneNormal = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const absoluteOfXDirection = [\n            Math.abs(xDirection[0]),\n            Math.abs(xDirection[1]),\n            Math.abs(xDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n            return 0;\n        }\n        const absoluteOfYDirection = [\n            Math.abs(yDirection[0]),\n            Math.abs(yDirection[1]),\n            Math.abs(yDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n            return 1;\n        }\n        const absoluteOfZDirection = [\n            Math.abs(zDirection[0]),\n            Math.abs(zDirection[1]),\n            Math.abs(zDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n            return 2;\n        }\n    }\n}\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n","import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport { BaseTool } from './base';\nimport { Enums, eventTarget, getEnabledElementByIds, getRenderingEngines, } from '@cornerstonejs/core';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { Events } from '../enums';\nvar OverlayMarkerType;\n(function (OverlayMarkerType) {\n    OverlayMarkerType[OverlayMarkerType[\"ANNOTATED_CUBE\"] = 1] = \"ANNOTATED_CUBE\";\n    OverlayMarkerType[OverlayMarkerType[\"AXES\"] = 2] = \"AXES\";\n    OverlayMarkerType[OverlayMarkerType[\"CUSTOM\"] = 3] = \"CUSTOM\";\n})(OverlayMarkerType || (OverlayMarkerType = {}));\nclass OrientationMarkerTool extends BaseTool {\n    static { this.CUBE = 1; }\n    static { this.AXIS = 2; }\n    static { this.VTPFILE = 3; }\n    static { this.OVERLAY_MARKER_TYPES = OverlayMarkerType; }\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            orientationWidget: {\n                enabled: true,\n                viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\n                viewportSize: 0.15,\n                minPixelSize: 100,\n                maxPixelSize: 300,\n            },\n            overlayMarkerType: OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\n            overlayConfiguration: {\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\n                    faceProperties: {\n                        xPlus: { text: 'L', faceColor: '#ffff00', faceRotation: 90 },\n                        xMinus: { text: 'R', faceColor: '#ffff00', faceRotation: 270 },\n                        yPlus: {\n                            text: 'P',\n                            faceColor: '#00ffff',\n                            fontColor: 'white',\n                            faceRotation: 180,\n                        },\n                        yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\n                        zPlus: { text: 'S' },\n                        zMinus: { text: 'I' },\n                    },\n                    defaultStyle: {\n                        fontStyle: 'bold',\n                        fontFamily: 'Arial',\n                        fontColor: 'black',\n                        fontSizeScale: (res) => res / 2,\n                        faceColor: '#0000ff',\n                        edgeThickness: 0.1,\n                        edgeColor: 'black',\n                        resolution: 400,\n                    },\n                },\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\n                    polyDataURL: 'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this.onSetToolEnabled = () => {\n            this.initViewports();\n            this._subscribeToViewportEvents();\n        };\n        this.onSetToolActive = () => {\n            this.initViewports();\n            this._subscribeToViewportEvents();\n        };\n        this.onSetToolDisabled = () => {\n            this.cleanUpData();\n            this._unsubscribeToViewportNewVolumeSet();\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resize = (viewportId) => {\n            const orientationMarker = this.orientationMarkers[viewportId];\n            if (!orientationMarker) {\n                return;\n            }\n            const { orientationWidget } = orientationMarker;\n            orientationWidget.updateViewport();\n        };\n        this.orientationMarkers = {};\n        this.updatingOrientationMarker = {};\n    }\n    _unsubscribeToViewportNewVolumeSet() {\n        const unsubscribe = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n                const { element } = viewport;\n                element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));\n                const resizeObserver = this._resizeObservers.get(viewportId);\n                resizeObserver.unobserve(element);\n            });\n        };\n        eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n            if (evt.detail.toolGroupId !== this.toolGroupId) {\n                return;\n            }\n            unsubscribe();\n            this.initViewports();\n        });\n    }\n    _subscribeToViewportEvents() {\n        const subscribeToElementResize = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n                const { element } = viewport;\n                this.initViewports();\n                element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));\n                const resizeObserver = new ResizeObserver(() => {\n                    setTimeout(() => {\n                        const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                        if (!element) {\n                            return;\n                        }\n                        const { viewport } = element;\n                        this.resize(viewportId);\n                        viewport.render();\n                    }, 100);\n                });\n                resizeObserver.observe(element);\n                this._resizeObservers.set(viewportId, resizeObserver);\n            });\n        };\n        subscribeToElementResize();\n        eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n            if (evt.detail.toolGroupId !== this.toolGroupId) {\n                return;\n            }\n            subscribeToElementResize();\n            this.initViewports();\n        });\n    }\n    cleanUpData() {\n        const renderingEngines = getRenderingEngines();\n        const renderingEngine = renderingEngines[0];\n        const viewports = renderingEngine.getViewports();\n        viewports.forEach((viewport) => {\n            const orientationMarker = this.orientationMarkers[viewport.id];\n            if (!orientationMarker) {\n                return;\n            }\n            const { actor, orientationWidget } = orientationMarker;\n            orientationWidget?.setEnabled(false);\n            orientationWidget?.delete();\n            actor?.delete();\n            const renderWindow = viewport\n                .getRenderingEngine()\n                .offscreenMultiRenderWindow.getRenderWindow();\n            renderWindow.render();\n            viewport.getRenderingEngine().render();\n            delete this.orientationMarkers[viewport.id];\n        });\n    }\n    initViewports() {\n        const renderingEngines = getRenderingEngines();\n        const renderingEngine = renderingEngines[0];\n        if (!renderingEngine) {\n            return;\n        }\n        let viewports = renderingEngine.getViewports();\n        viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n        viewports.forEach((viewport) => {\n            const widget = viewport.getWidget(this.getToolName());\n            if (!widget || widget.isDeleted()) {\n                this.addAxisActorInViewport(viewport);\n            }\n        });\n    }\n    async addAxisActorInViewport(viewport) {\n        const viewportId = viewport.id;\n        if (!this.updatingOrientationMarker[viewportId]) {\n            this.updatingOrientationMarker[viewportId] = true;\n            const type = this.configuration.overlayMarkerType;\n            const overlayConfiguration = this.configuration.overlayConfiguration[type];\n            if (this.orientationMarkers[viewportId]) {\n                const { actor, orientationWidget } = this.orientationMarkers[viewportId];\n                viewport.getRenderer().removeActor(actor);\n                orientationWidget.setEnabled(false);\n            }\n            let actor;\n            if (type === 1) {\n                actor = this.createAnnotationCube(overlayConfiguration);\n            }\n            else if (type === 2) {\n                actor = vtkAxesActor.newInstance();\n            }\n            else if (type === 3) {\n                actor = await this.createCustomActor();\n            }\n            const renderer = viewport.getRenderer();\n            const renderWindow = viewport\n                .getRenderingEngine()\n                .offscreenMultiRenderWindow.getRenderWindow();\n            const { enabled, viewportCorner, viewportSize, minPixelSize, maxPixelSize, } = this.configuration.orientationWidget;\n            const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n                actor,\n                interactor: renderWindow.getInteractor(),\n                parentRenderer: renderer,\n            });\n            orientationWidget.setEnabled(enabled);\n            orientationWidget.setViewportCorner(viewportCorner);\n            orientationWidget.setViewportSize(viewportSize);\n            orientationWidget.setMinPixelSize(minPixelSize);\n            orientationWidget.setMaxPixelSize(maxPixelSize);\n            orientationWidget.updateMarkerOrientation();\n            this.orientationMarkers[viewportId] = {\n                orientationWidget,\n                actor,\n            };\n            viewport.addWidget(this.getToolName(), orientationWidget);\n            renderWindow.render();\n            viewport.getRenderingEngine().render();\n            this.updatingOrientationMarker[viewportId] = false;\n        }\n    }\n    async createCustomActor() {\n        const url = this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\n            .polyDataURL;\n        const response = await fetch(url);\n        const arrayBuffer = await response.arrayBuffer();\n        const vtpReader = vtkXMLPolyDataReader.newInstance();\n        vtpReader.parseAsArrayBuffer(arrayBuffer);\n        vtpReader.update();\n        const polyData = vtkPolyData.newInstance();\n        polyData.shallowCopy(vtpReader.getOutputData());\n        polyData.getPointData().setActiveScalars('Color');\n        const mapper = vtkMapper.newInstance();\n        mapper.setInputData(polyData);\n        mapper.setColorModeToDirectScalars();\n        const actor = vtkActor.newInstance();\n        actor.setMapper(mapper);\n        actor.rotateZ(180);\n        return actor;\n    }\n    createAnnotationCube(overlayConfiguration) {\n        const actor = vtkAnnotatedCubeActor.newInstance();\n        actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\n        actor.setXPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.xPlus,\n        });\n        actor.setXMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.xMinus,\n        });\n        actor.setYPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.yPlus,\n        });\n        actor.setYMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.yMinus,\n        });\n        actor.setZPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.zPlus,\n        });\n        actor.setZMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.zMinus,\n        });\n        return actor;\n    }\n    async createAnnotatedCubeActor() {\n        const axes = vtkAnnotatedCubeActor.newInstance();\n        const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\n        axes.setDefaultStyle(defaultStyle);\n        Object.keys(faceProperties).forEach((key) => {\n            const methodName = `set${key.charAt(0).toUpperCase() + key.slice(1)}FaceProperty`;\n            axes[methodName](faceProperties[key]);\n        });\n        return axes;\n    }\n}\nOrientationMarkerTool.toolName = 'OrientationMarker';\nexport default OrientationMarkerTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport RepresentationTypes from '../../enums/SegmentationRepresentations';\nimport { setActiveSegmentIndex } from '../../stateManagement/segmentation/segmentIndex';\nimport { getHoveredContourSegmentationAnnotation, getSegmentIndexAtLabelmapBorder, getSegmentIndexAtWorldPoint, } from '../../utilities/segmentation';\nimport { state } from '../../store/state';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nclass SegmentSelectTool extends BaseTool {\n    static { this.SelectMode = {\n        Inside: 'Inside',\n        Border: 'Border',\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            hoverTimeout: 100,\n            mode: SegmentSelectTool.SelectMode.Border,\n            searchRadius: 6,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt) => {\n            if (this.hoverTimer) {\n                clearTimeout(this.hoverTimer);\n            }\n            this.hoverTimer = setTimeout(() => {\n                this._setActiveSegment(evt);\n                this.hoverTimer = null;\n            }, this.configuration.hoverTimeout);\n            return true;\n        };\n        this.onSetToolEnabled = () => {\n            this.onSetToolActive();\n        };\n        this.onSetToolActive = () => {\n            this.hoverTimer = null;\n        };\n        this.onSetToolDisabled = () => {\n            this.hoverTimer = null;\n        };\n        this.hoverTimer = null;\n    }\n    _setActiveSegment(evt = {}) {\n        if (state.isInteractingWithTool) {\n            return;\n        }\n        const { element, currentPoints } = evt.detail;\n        const worldPoint = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            return;\n        }\n        this._setActiveSegmentForType(activeSegmentation, worldPoint, viewport);\n    }\n    _setActiveSegmentForType(activeSegmentation, worldPoint, viewport) {\n        const imageDataInfo = viewport.getImageData();\n        if (!imageDataInfo) {\n            return;\n        }\n        const { segmentationId, representationData } = activeSegmentation;\n        let hoveredSegmentIndex;\n        if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {\n            hoveredSegmentIndex = getSegmentIndexAtWorldPoint(segmentationId, worldPoint, {\n                viewport,\n            });\n        }\n        else {\n            if (representationData.Labelmap) {\n                hoveredSegmentIndex = getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, {\n                    viewport,\n                    searchRadius: this.configuration.searchRadius,\n                });\n            }\n            else if (representationData.Contour) {\n                hoveredSegmentIndex =\n                    getHoveredContourSegmentationAnnotation(segmentationId);\n            }\n            else if (representationData.Surface) {\n            }\n        }\n        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n            return;\n        }\n        setActiveSegmentIndex(segmentationId, hoveredSegmentIndex);\n        const renderingEngine = viewport.getRenderingEngine();\n        const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n        triggerSegmentationModified(segmentationId);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    }\n}\nSegmentSelectTool.toolName = 'SegmentSelectTool';\nexport default SegmentSelectTool;\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement, triggerEvent, eventTarget, utilities as csUtils, cache, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { drawHandles as drawHandlesSvg, drawRedactionRect as drawRedactionRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nclass VideoRedactionTool extends AnnotationTool {\n    constructor(toolConfiguration = {}) {\n        super(toolConfiguration, {\n            supportedInteractionTypes: ['Mouse', 'Touch'],\n            configuration: { shadow: true, preventHandleOutsideImage: false },\n        });\n        this.addNewAnnotation = (evt) => {\n            const eventData = evt.detail;\n            const { currentPoints, element } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                metadata: {\n                    viewPlaneNormal: [0, 0, 1],\n                    viewUp: [0, 1, 0],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    invalidated: true,\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    active: true,\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            return annotation;\n        };\n        this.getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            for (let i = 0; i < points.length; i++) {\n                const point = points[i];\n                const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\n                const near = vec2.distance(canvasCoords, toolDataCanvasCoordinate) < proximity;\n                if (near === true) {\n                    data.handles.activeHandleIndex = i;\n                    return point;\n                }\n            }\n            data.handles.activeHandleIndex = null;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { data } = annotation;\n            data.active = true;\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle, interactionType = 'mouse') => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { data } = annotation;\n            data.active = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n                handleIndex,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            evt.preventDefault();\n        };\n        this._mouseUpCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.active = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        };\n        this._mouseDragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { annotation, viewportUIDsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            if (handleIndex === undefined) {\n                const { deltaPoints } = eventData;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                data.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventData;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                data.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n            element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n            element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n            element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n            element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID } = annotation;\n                const toolMetadata = annotation.metadata;\n                const data = annotation.data;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return;\n                }\n                let activeHandleCanvasCoords;\n                if (!this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const rectangleUID = '0';\n                drawRedactionRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color: 'black',\n                    lineDash,\n                    lineWidth,\n                });\n            }\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetUIDs = Object.keys(cachedStats);\n            for (let i = 0; i < targetUIDs.length; i++) {\n                const targetUID = targetUIDs[i];\n                const { imageVolume } = this._getImageVolumeFromTargetUID(targetUID, renderingEngine);\n                const { dimensions, scalarData, vtkImageData: imageData, metadata, } = imageVolume;\n                const worldPos1Index = vec3.fromValues(0, 0, 0);\n                const worldPos2Index = vec3.fromValues(0, 0, 0);\n                imageData.worldToIndexVec3(worldPos1, worldPos1Index);\n                worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n                worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n                worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n                imageData.worldToIndexVec3(worldPos2, worldPos2Index);\n                worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n                worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n                worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const area = worldWidth * worldHeight;\n                    let count = 0;\n                    let mean = 0;\n                    let stdDev = 0;\n                    const yMultiple = dimensions[0];\n                    const zMultiple = dimensions[0] * dimensions[1];\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                count++;\n                                mean += value;\n                            }\n                        }\n                    }\n                    mean /= count;\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                const valueMinusMean = value - mean;\n                                stdDev += valueMinusMean * valueMinusMean;\n                            }\n                        }\n                    }\n                    stdDev /= count;\n                    stdDev = Math.sqrt(stdDev);\n                    cachedStats[targetUID] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean,\n                        stdDev,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetUID] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            data.invalidated = false;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportUID,\n                renderingEngineUID,\n                sceneUID: sceneUID,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._getTargetVolumeUID = (scene) => {\n            if (this.configuration.volumeUID) {\n                return this.configuration.volumeUID;\n            }\n            const volumeActors = scene.getVolumeActors();\n            if (!volumeActors && !volumeActors.length) {\n                return;\n            }\n            return volumeActors[0].uid;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    cancel(element) {\n        if (!this.isDrawing) {\n            return;\n        }\n        this.isDrawing = false;\n        this._deactivateDraw(element);\n        this._deactivateModify(element);\n        resetElementCursor(element);\n        const { annotation, viewportUIDsToRender } = this.editData;\n        const { data } = annotation;\n        data.active = false;\n        data.handles.activeHandleIndex = null;\n        triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        this.editData = null;\n        return annotation.metadata.annotationUID;\n    }\n    _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\n        let imageVolume, viewport;\n        if (targetUID.startsWith('stackTarget')) {\n            const coloneIndex = targetUID.indexOf(':');\n            const viewportUID = targetUID.substring(coloneIndex + 1);\n            const viewport = renderingEngine.getViewport(viewportUID);\n            imageVolume = viewport.getImageData();\n        }\n        else {\n            imageVolume = cache.getVolume(targetUID);\n        }\n        return { imageVolume, viewport };\n    }\n    _getTargetStackUID(viewport) {\n        return `stackTarget:${viewport.uid}`;\n    }\n}\nVideoRedactionTool.toolName = 'VideoRedaction';\nexport default VideoRedactionTool;\n","import { getEnabledElement, triggerEvent, getRenderingEngine, } from '@cornerstonejs/core';\nimport { Events, ToolModes } from '../../enums';\nimport { draw as drawSvg } from '../../drawingSvg';\nimport getToolsWithModesForElement from '../../utilities/getToolsWithModesForElement';\nconst { Active, Passive, Enabled } = ToolModes;\nclass AnnotationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._renderFlaggedViewports = () => {\n            this._throwIfDestroyed();\n            const elements = Array.from(this._viewportElements.values());\n            for (let i = 0; i < elements.length; i++) {\n                const element = elements[i];\n                if (this._needsRender.has(element)) {\n                    this._triggerRender(element);\n                    this._needsRender.delete(element);\n                    if (this._needsRender.size === 0) {\n                        break;\n                    }\n                }\n            }\n            this._animationFrameSet = false;\n            this._animationFrameHandle = null;\n            this._render();\n        };\n        this._viewportElements = new Map();\n    }\n    addViewportElement(viewportId, element) {\n        this._viewportElements.set(viewportId, element);\n    }\n    removeViewportElement(viewportId, element) {\n        this._viewportElements.delete(viewportId);\n        this._needsRender.delete(element);\n        this._reset();\n    }\n    renderViewport(element) {\n        this._setViewportsToBeRenderedNextFrame([element]);\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setAllViewportsToBeRenderedNextFrame() {\n        const elements = [...this._viewportElements.values()];\n        elements.forEach((element) => {\n            this._needsRender.add(element);\n        });\n        this._renderFlaggedViewports();\n    }\n    _setViewportsToBeRenderedNextFrame(elements) {\n        const elementsEnabled = [...this._viewportElements.values()];\n        elements.forEach((element) => {\n            if (elementsEnabled.indexOf(element) !== -1) {\n                this._needsRender.add(element);\n            }\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(element) {\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const renderingEngine = getRenderingEngine(enabledElement.renderingEngineId);\n        if (!renderingEngine) {\n            console.warn('rendering Engine has been destroyed');\n            return;\n        }\n        const enabledTools = getToolsWithModesForElement(element, [\n            Active,\n            Passive,\n            Enabled,\n        ]);\n        const { renderingEngineId, viewportId } = enabledElement;\n        const eventDetail = {\n            element,\n            renderingEngineId,\n            viewportId,\n        };\n        drawSvg(element, (svgDrawingHelper) => {\n            let anyRendered = false;\n            const handleDrawSvg = (tool) => {\n                if (tool.renderAnnotation) {\n                    const rendered = tool.renderAnnotation(enabledElement, svgDrawingHelper);\n                    anyRendered = anyRendered || rendered;\n                }\n            };\n            enabledTools.forEach(handleDrawSvg);\n            if (anyRendered) {\n                triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\n            }\n        });\n    }\n    _reset() {\n        window.cancelAnimationFrame(this._animationFrameHandle);\n        this._needsRender.clear();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._setAllViewportsToBeRenderedNextFrame();\n    }\n}\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\nexport { annotationRenderingEngine };\n","import { Enums, eventTarget, getEnabledElement, utilities, } from '@cornerstonejs/core';\nclass FrameOfReferenceSpecificAnnotationManager {\n    constructor(uid) {\n        this.getGroupKey = (annotationGroupSelector) => {\n            if (typeof annotationGroupSelector === 'string') {\n                return annotationGroupSelector;\n            }\n            const element = annotationGroupSelector;\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                throw new Error('Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID');\n            }\n            return enabledElement.FrameOfReferenceUID;\n        };\n        this._imageVolumeModifiedHandler = (evt) => {\n            const eventDetail = evt.detail;\n            const { FrameOfReferenceUID } = eventDetail;\n            const annotations = this.annotations;\n            const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];\n            if (!frameOfReferenceSpecificAnnotations) {\n                return;\n            }\n            Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                toolSpecificAnnotations.forEach((annotation) => {\n                    const invalidated = annotation.invalidated;\n                    if (invalidated !== undefined) {\n                        annotation.invalidated = true;\n                    }\n                });\n            });\n        };\n        this.getFramesOfReference = () => {\n            return Object.keys(this.annotations);\n        };\n        this.getAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (!annotations[groupKey]) {\n                return [];\n            }\n            if (toolName) {\n                return annotations[groupKey][toolName]\n                    ? annotations[groupKey][toolName]\n                    : [];\n            }\n            return annotations[groupKey];\n        };\n        this.getAnnotation = (annotationUID) => {\n            const annotations = this.annotations;\n            for (const frameOfReferenceUID in annotations) {\n                const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\n                for (const toolName in frameOfReferenceAnnotations) {\n                    const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\n                    for (const annotation of toolSpecificAnnotations) {\n                        if (annotationUID === annotation.annotationUID) {\n                            return annotation;\n                        }\n                    }\n                }\n            }\n        };\n        this.getNumberOfAnnotations = (groupKey, toolName) => {\n            const annotations = this.getAnnotations(groupKey, toolName);\n            if (!annotations.length) {\n                return 0;\n            }\n            if (toolName) {\n                return annotations.length;\n            }\n            let total = 0;\n            for (const toolName in annotations) {\n                total += annotations[toolName].length;\n            }\n            return total;\n        };\n        this.addAnnotation = (annotation, groupKey) => {\n            const { metadata } = annotation;\n            const { FrameOfReferenceUID, toolName } = metadata;\n            groupKey = groupKey || FrameOfReferenceUID;\n            const annotations = this.annotations;\n            let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n            if (!frameOfReferenceSpecificAnnotations) {\n                annotations[groupKey] = {};\n                frameOfReferenceSpecificAnnotations = annotations[groupKey];\n            }\n            let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n            if (!toolSpecificAnnotations) {\n                frameOfReferenceSpecificAnnotations[toolName] = [];\n                toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n            }\n            if (this.preprocessingFn) {\n                annotation = this.preprocessingFn(annotation);\n            }\n            toolSpecificAnnotations.push(annotation);\n        };\n        this.removeAnnotation = (annotationUID) => {\n            const { annotations } = this;\n            for (const groupKey in annotations) {\n                const groupAnnotations = annotations[groupKey];\n                for (const toolName in groupAnnotations) {\n                    const toolAnnotations = groupAnnotations[toolName];\n                    const index = toolAnnotations.findIndex((annotation) => annotation.annotationUID === annotationUID);\n                    if (index !== -1) {\n                        toolAnnotations.splice(index, 1);\n                        if (toolAnnotations.length === 0) {\n                            delete groupAnnotations[toolName];\n                        }\n                    }\n                }\n                if (Object.keys(groupAnnotations).length === 0) {\n                    delete annotations[groupKey];\n                }\n            }\n        };\n        this.removeAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            const removedAnnotations = [];\n            if (!annotations[groupKey]) {\n                return removedAnnotations;\n            }\n            if (toolName) {\n                const annotationsForTool = annotations[groupKey][toolName];\n                for (const annotation of annotationsForTool) {\n                    this.removeAnnotation(annotation.annotationUID);\n                    removedAnnotations.push(annotation);\n                }\n            }\n            else {\n                for (const toolName in annotations[groupKey]) {\n                    const annotationsForTool = annotations[groupKey][toolName];\n                    for (const annotation of annotationsForTool) {\n                        this.removeAnnotation(annotation.annotationUID);\n                        removedAnnotations.push(annotation);\n                    }\n                }\n            }\n            return removedAnnotations;\n        };\n        this.saveAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (groupKey && toolName) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                if (!frameOfReferenceSpecificAnnotations) {\n                    return;\n                }\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                return structuredClone(toolSpecificAnnotations);\n            }\n            else if (groupKey) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                return structuredClone(frameOfReferenceSpecificAnnotations);\n            }\n            return structuredClone(annotations);\n        };\n        this.restoreAnnotations = (state, groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (groupKey && toolName) {\n                let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                if (!frameOfReferenceSpecificAnnotations) {\n                    annotations[groupKey] = {};\n                    frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                }\n                frameOfReferenceSpecificAnnotations[toolName] = state;\n            }\n            else if (groupKey) {\n                annotations[groupKey] = state;\n            }\n            else {\n                this.annotations = structuredClone(state);\n            }\n        };\n        this.getAllAnnotations = () => {\n            return Object.values(this.annotations)\n                .map((frameOfReferenceSpecificAnnotations) => Object.values(frameOfReferenceSpecificAnnotations))\n                .flat(2);\n        };\n        this.getNumberOfAllAnnotations = () => {\n            let count = 0;\n            const annotations = this.annotations;\n            for (const groupKey in annotations) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                for (const toolName in frameOfReferenceSpecificAnnotations) {\n                    const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                    count += toolSpecificAnnotations.length;\n                }\n            }\n            return count;\n        };\n        this.removeAllAnnotations = () => {\n            const removedAnnotations = [];\n            for (const annotation of this.getAllAnnotations()) {\n                this.removeAnnotation(annotation.annotationUID);\n                removedAnnotations.push(annotation);\n            }\n            return removedAnnotations;\n        };\n        if (!uid) {\n            uid = utilities.uuidv4();\n        }\n        this.annotations = {};\n        this.uid = uid;\n        eventTarget.addEventListener(Enums.Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);\n    }\n    setPreprocessingFn(preprocessingFn) {\n        this.preprocessingFn = preprocessingFn;\n    }\n}\nconst defaultFrameOfReferenceSpecificAnnotationManager = new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\nexport default FrameOfReferenceSpecificAnnotationManager;\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { getAnnotation } from './getAnnotation';\nconst globalLockedAnnotationUIDsSet = new Set();\nfunction setAnnotationLocked(annotationUID, locked = true) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (locked) {\n            lock(annotationUID, globalLockedAnnotationUIDsSet, detail);\n        }\n        else {\n            unlock(annotationUID, globalLockedAnnotationUIDsSet, detail);\n        }\n    }\n    publish(detail, globalLockedAnnotationUIDsSet);\n}\nfunction unlockAllAnnotations() {\n    const detail = makeEventDetail();\n    clearLockedAnnotationsSet(globalLockedAnnotationUIDsSet, detail);\n    publish(detail, globalLockedAnnotationUIDsSet);\n}\nfunction getAnnotationsLocked() {\n    return Array.from(globalLockedAnnotationUIDsSet);\n}\nfunction isAnnotationLocked(annotationUID) {\n    return globalLockedAnnotationUIDsSet.has(annotationUID);\n}\nfunction getAnnotationsLockedCount() {\n    return globalLockedAnnotationUIDsSet.size;\n}\nfunction checkAndSetAnnotationLocked(annotationUID) {\n    const isLocked = isAnnotationLocked(annotationUID);\n    setAnnotationLocked(annotationUID, isLocked);\n    return isLocked;\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        added: [],\n        removed: [],\n        locked: [],\n    });\n}\nfunction lock(annotationUID, lockedAnnotationUIDsSet, detail) {\n    if (!lockedAnnotationUIDsSet.has(annotationUID)) {\n        lockedAnnotationUIDsSet.add(annotationUID);\n        detail.added.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isLocked = true;\n        }\n    }\n}\nfunction unlock(annotationUID, lockedAnnotationUIDsSet, detail) {\n    if (lockedAnnotationUIDsSet.delete(annotationUID)) {\n        detail.removed.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isLocked = false;\n        }\n    }\n}\nfunction clearLockedAnnotationsSet(lockedAnnotationUIDsSet, detail) {\n    lockedAnnotationUIDsSet.forEach((annotationUID) => {\n        unlock(annotationUID, lockedAnnotationUIDsSet, detail);\n    });\n}\nfunction publish(detail, lockedAnnotationUIDsSet) {\n    if (detail.added.length > 0 || detail.removed.length > 0) {\n        lockedAnnotationUIDsSet.forEach((item) => void detail.locked.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\n    }\n}\nexport { setAnnotationLocked, getAnnotationsLocked, getAnnotationsLockedCount, unlockAllAnnotations, isAnnotationLocked, checkAndSetAnnotationLocked, };\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { getAnnotation } from './getAnnotation';\nconst selectedAnnotationUIDs = new Set();\nfunction setAnnotationSelected(annotationUID, selected = true, preserveSelected = false) {\n    if (selected) {\n        selectAnnotation(annotationUID, preserveSelected);\n    }\n    else {\n        deselectAnnotation(annotationUID);\n    }\n}\nfunction selectAnnotation(annotationUID, preserveSelected = false) {\n    const detail = makeEventDetail();\n    if (!preserveSelected) {\n        clearSelectionSet(selectedAnnotationUIDs, detail);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isSelected = true;\n        }\n    }\n    if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\n        selectedAnnotationUIDs.add(annotationUID);\n        detail.added.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isSelected = true;\n        }\n    }\n    publish(detail, selectedAnnotationUIDs);\n}\nfunction deselectAnnotation(annotationUID) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (selectedAnnotationUIDs.delete(annotationUID)) {\n            detail.removed.push(annotationUID);\n            const annotation = getAnnotation(annotationUID);\n            annotation.isSelected = false;\n        }\n    }\n    else {\n        clearSelectionSet(selectedAnnotationUIDs, detail);\n    }\n    publish(detail, selectedAnnotationUIDs);\n}\nfunction getAnnotationsSelected() {\n    return Array.from(selectedAnnotationUIDs);\n}\nfunction getAnnotationsSelectedByToolName(toolName) {\n    return getAnnotationsSelected().filter((annotationUID) => {\n        const annotation = getAnnotation(annotationUID);\n        return annotation?.metadata?.toolName === toolName;\n    });\n}\nfunction isAnnotationSelected(annotationUID) {\n    return selectedAnnotationUIDs.has(annotationUID);\n}\nfunction getAnnotationsSelectedCount() {\n    return selectedAnnotationUIDs.size;\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        added: [],\n        removed: [],\n        selection: [],\n    });\n}\nfunction clearSelectionSet(selectionSet, detail) {\n    selectionSet.forEach((value) => {\n        if (selectionSet.delete(value)) {\n            detail.removed.push(value);\n            const annotation = getAnnotation(value);\n            if (annotation) {\n                annotation.isSelected = false;\n            }\n        }\n    });\n}\nfunction publish(detail, selectionSet) {\n    if (detail.added.length > 0 || detail.removed.length > 0) {\n        selectionSet.forEach((item) => void detail.selection.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\n    }\n}\nexport { setAnnotationSelected, getAnnotationsSelected, getAnnotationsSelectedByToolName, getAnnotationsSelectedCount, deselectAnnotation, isAnnotationSelected, };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { getAnnotation } from './getAnnotation';\nimport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR, triggerAnnotationRemoved, } from './helpers/state';\nimport { checkAndSetAnnotationLocked } from './annotationLocking';\nimport { checkAndDefineCachedStatsProperty, checkAndDefineTextBoxProperty, } from './utilities/defineProperties';\nimport { checkAndSetAnnotationVisibility } from './annotationVisibility';\nlet defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\nconst preprocessingFn = (annotation) => {\n    annotation = checkAndDefineTextBoxProperty(annotation);\n    annotation = checkAndDefineCachedStatsProperty(annotation);\n    const uid = annotation.annotationUID;\n    const isLocked = checkAndSetAnnotationLocked(uid);\n    annotation.isLocked = isLocked;\n    const isVisible = checkAndSetAnnotationVisibility(uid);\n    annotation.isVisible = isVisible;\n    return annotation;\n};\ndefaultManager.setPreprocessingFn(preprocessingFn);\nfunction getAnnotationManager() {\n    return defaultManager;\n}\nfunction setAnnotationManager(annotationManager) {\n    defaultManager = annotationManager;\n}\nfunction resetAnnotationManager() {\n    defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n}\nfunction getAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    return manager.getAnnotations(groupKey, toolName);\n}\nfunction getAllAnnotations() {\n    const manager = getAnnotationManager();\n    return manager.getAllAnnotations();\n}\nfunction clearParentAnnotation(annotation) {\n    const { annotationUID: childUID, parentAnnotationUID } = annotation;\n    if (!parentAnnotationUID) {\n        return;\n    }\n    const parentAnnotation = getAnnotation(parentAnnotationUID);\n    const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);\n    parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);\n    annotation.parentAnnotationUID = undefined;\n}\nfunction addChildAnnotation(parentAnnotation, childAnnotation) {\n    const { annotationUID: parentUID } = parentAnnotation;\n    const { annotationUID: childUID } = childAnnotation;\n    clearParentAnnotation(childAnnotation);\n    if (!parentAnnotation.childAnnotationUIDs) {\n        parentAnnotation.childAnnotationUIDs = [];\n    }\n    if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {\n        return;\n    }\n    parentAnnotation.childAnnotationUIDs.push(childUID);\n    childAnnotation.parentAnnotationUID = parentUID;\n}\nfunction getParentAnnotation(annotation) {\n    return annotation.parentAnnotationUID\n        ? getAnnotation(annotation.parentAnnotationUID)\n        : undefined;\n}\nfunction getChildAnnotations(annotation) {\n    return (annotation.childAnnotationUIDs?.map((childAnnotationUID) => getAnnotation(childAnnotationUID)) ?? []);\n}\nfunction addAnnotation(annotation, annotationGroupSelector) {\n    if (!annotation.annotationUID) {\n        annotation.annotationUID = csUtils.uuidv4();\n    }\n    const manager = getAnnotationManager();\n    if (annotationGroupSelector instanceof HTMLDivElement) {\n        const groupKey = manager.getGroupKey(annotationGroupSelector);\n        manager.addAnnotation(annotation, groupKey);\n        triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\n    }\n    else {\n        manager.addAnnotation(annotation, undefined);\n        triggerAnnotationAddedForFOR(annotation);\n    }\n    return annotation.annotationUID;\n}\nfunction getNumberOfAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    return manager.getNumberOfAnnotations(groupKey, toolName);\n}\nfunction removeAnnotation(annotationUID) {\n    if (!annotationUID) {\n        return;\n    }\n    const manager = getAnnotationManager();\n    const annotation = manager.getAnnotation(annotationUID);\n    if (!annotation) {\n        return;\n    }\n    annotation.childAnnotationUIDs?.forEach((childAnnotationUID) => removeAnnotation(childAnnotationUID));\n    manager.removeAnnotation(annotationUID);\n    triggerAnnotationRemoved({ annotation, annotationManagerUID: manager.uid });\n}\nfunction removeAllAnnotations() {\n    const manager = getAnnotationManager();\n    const removedAnnotations = manager.removeAllAnnotations();\n    for (const annotation of removedAnnotations) {\n        triggerAnnotationRemoved({\n            annotation,\n            annotationManagerUID: manager.uid,\n        });\n    }\n}\nfunction removeAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    const removedAnnotations = manager.removeAnnotations(groupKey, toolName);\n    for (const annotation of removedAnnotations) {\n        triggerAnnotationRemoved({\n            annotation,\n            annotationManagerUID: manager.uid,\n        });\n    }\n}\nfunction invalidateAnnotation(annotation) {\n    let currAnnotation = annotation;\n    while (currAnnotation) {\n        currAnnotation.invalidated = true;\n        currAnnotation = currAnnotation.parentAnnotationUID\n            ? getAnnotation(currAnnotation.parentAnnotationUID)\n            : undefined;\n    }\n}\nexport { getAllAnnotations, getAnnotations, getParentAnnotation, getChildAnnotations, clearParentAnnotation, addChildAnnotation, getNumberOfAnnotations, addAnnotation, removeAnnotation, removeAnnotations, removeAllAnnotations, setAnnotationManager, getAnnotationManager, resetAnnotationManager, invalidateAnnotation, getAnnotation, };\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { isAnnotationSelected, deselectAnnotation, } from './annotationSelection';\nimport { getAnnotation } from './getAnnotation';\nconst globalHiddenAnnotationUIDsSet = new Set();\nfunction setAnnotationVisibility(annotationUID, visible = true) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (visible) {\n            show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n        }\n        else {\n            hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n        }\n    }\n    publish(detail);\n}\nfunction showAllAnnotations() {\n    const detail = makeEventDetail();\n    globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\n        show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    });\n    publish(detail);\n}\nfunction isAnnotationVisible(annotationUID) {\n    const annotation = getAnnotation(annotationUID);\n    if (annotation) {\n        return !globalHiddenAnnotationUIDsSet.has(annotationUID);\n    }\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        lastVisible: [],\n        lastHidden: [],\n        hidden: [],\n    });\n}\nfunction show(annotationUID, annotationUIDsSet, detail) {\n    if (annotationUIDsSet.delete(annotationUID)) {\n        detail.lastVisible.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        annotation.isVisible = true;\n    }\n}\nfunction hide(annotationUID, annotationUIDsSet, detail) {\n    if (!annotationUIDsSet.has(annotationUID)) {\n        annotationUIDsSet.add(annotationUID);\n        if (isAnnotationSelected(annotationUID)) {\n            deselectAnnotation(annotationUID);\n        }\n        detail.lastHidden.push(annotationUID);\n    }\n}\nfunction publish(detail) {\n    if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\n        globalHiddenAnnotationUIDsSet.forEach((item) => void detail.hidden.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\n    }\n}\nfunction checkAndSetAnnotationVisibility(annotationUID) {\n    const isVisible = !globalHiddenAnnotationUIDsSet.has(annotationUID);\n    setAnnotationVisibility(annotationUID, isVisible);\n    return isVisible;\n}\nexport { setAnnotationVisibility, showAllAnnotations, isAnnotationVisible, checkAndSetAnnotationVisibility, };\n","class ToolStyle {\n    constructor() {\n        const defaultConfig = {\n            color: 'rgb(255, 255, 0)',\n            colorHighlighted: 'rgb(0, 255, 0)',\n            colorSelected: 'rgb(0, 220, 0)',\n            colorLocked: 'rgb(209, 193, 90)',\n            lineWidth: '1',\n            lineDash: '',\n            shadow: true,\n            textBoxVisibility: true,\n            textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n            textBoxFontSize: '14px',\n            textBoxColor: 'rgb(255, 255, 0)',\n            textBoxColorHighlighted: 'rgb(0, 255, 0)',\n            textBoxColorSelected: 'rgb(0, 255, 0)',\n            textBoxColorLocked: 'rgb(209, 193, 90)',\n            textBoxBackground: '',\n            textBoxLinkLineWidth: '1',\n            textBoxLinkLineDash: '2,3',\n            textBoxShadow: true,\n        };\n        this._initializeConfig(defaultConfig);\n    }\n    getAnnotationToolStyles(annotationUID) {\n        return this.config.annotations && this.config.annotations[annotationUID];\n    }\n    getViewportToolStyles(viewportId) {\n        return this.config.viewports && this.config.viewports[viewportId];\n    }\n    getToolGroupToolStyles(toolGroupId) {\n        return this.config.toolGroups && this.config.toolGroups[toolGroupId];\n    }\n    getDefaultToolStyles() {\n        return this.config.default;\n    }\n    setAnnotationStyles(annotationUID, styles) {\n        let annotationSpecificStyles = this.config.annotations;\n        if (!annotationSpecificStyles) {\n            this.config = {\n                ...this.config,\n                annotations: {},\n            };\n            annotationSpecificStyles = this.config.annotations;\n        }\n        annotationSpecificStyles[annotationUID] = styles;\n    }\n    setViewportToolStyles(viewportId, styles) {\n        let viewportSpecificStyles = this.config.viewports;\n        if (!viewportSpecificStyles) {\n            this.config = {\n                ...this.config,\n                viewports: {},\n            };\n            viewportSpecificStyles = this.config.viewports;\n        }\n        viewportSpecificStyles[viewportId] = styles;\n    }\n    setToolGroupToolStyles(toolGroupId, styles) {\n        let toolGroupSpecificStyles = this.config.toolGroups;\n        if (!toolGroupSpecificStyles) {\n            this.config = {\n                ...this.config,\n                toolGroups: {},\n            };\n            toolGroupSpecificStyles = this.config.toolGroups;\n        }\n        toolGroupSpecificStyles[toolGroupId] = styles;\n    }\n    setDefaultToolStyles(styles) {\n        this.config.default = styles;\n    }\n    getStyleProperty(toolStyle, specifications) {\n        const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\n        return this._getToolStyle(toolStyle, annotationUID, viewportId, toolGroupId, toolName);\n    }\n    _getToolStyle(property, annotationUID, viewportId, toolGroupId, toolName) {\n        if (annotationUID) {\n            const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);\n            if (annotationToolStyles) {\n                if (annotationToolStyles[property] !== undefined) {\n                    return annotationToolStyles[property];\n                }\n            }\n        }\n        if (viewportId) {\n            const viewportToolStyles = this.getViewportToolStyles(viewportId);\n            if (viewportToolStyles) {\n                if (viewportToolStyles[toolName] &&\n                    viewportToolStyles[toolName][property] !== undefined) {\n                    return viewportToolStyles[toolName][property];\n                }\n                if (viewportToolStyles.global &&\n                    viewportToolStyles.global[property] !== undefined) {\n                    return viewportToolStyles.global[property];\n                }\n            }\n        }\n        if (toolGroupId) {\n            const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);\n            if (toolGroupToolStyles) {\n                if (toolGroupToolStyles[toolName] &&\n                    toolGroupToolStyles[toolName][property] !== undefined) {\n                    return toolGroupToolStyles[toolName][property];\n                }\n                if (toolGroupToolStyles.global &&\n                    toolGroupToolStyles.global[property] !== undefined) {\n                    return toolGroupToolStyles.global[property];\n                }\n            }\n        }\n        const globalStyles = this.getDefaultToolStyles();\n        if (globalStyles[toolName] &&\n            globalStyles[toolName][property] !== undefined) {\n            return globalStyles[toolName][property];\n        }\n        if (globalStyles.global && globalStyles.global[property] !== undefined) {\n            return globalStyles.global[property];\n        }\n    }\n    _initializeConfig(config) {\n        const toolStyles = {};\n        for (const name in config) {\n            toolStyles[name] = config[name];\n        }\n        this.config = {\n            default: {\n                global: toolStyles,\n            },\n        };\n    }\n}\nconst toolStyle = new ToolStyle();\nexport default toolStyle;\n","import toolStyle from './ToolStyle';\nfunction getHierarchalPropertyStyles(property, state, mode) {\n    const list = [`${property}`];\n    if (state) {\n        list.push(`${list[0]}${state}`);\n    }\n    if (mode) {\n        list.push(`${list[list.length - 1]}${mode}`);\n    }\n    return list;\n}\nfunction getStyleProperty(property, styleSpecifier, state, mode) {\n    const alternatives = getHierarchalPropertyStyles(property, state, mode);\n    for (let i = alternatives.length - 1; i >= 0; --i) {\n        const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\n        if (style !== undefined) {\n            return style;\n        }\n    }\n}\nexport { getStyleProperty };\n","import { isAnnotationLocked } from '../annotationLocking';\nimport { isAnnotationSelected } from '../annotationSelection';\nimport { AnnotationStyleStates } from '../../../enums';\nfunction getState(annotation) {\n    if (annotation) {\n        if (annotation.data && annotation.highlighted) {\n            return AnnotationStyleStates.Highlighted;\n        }\n        if (isAnnotationSelected(annotation.annotationUID)) {\n            return AnnotationStyleStates.Selected;\n        }\n        if (isAnnotationLocked(annotation.annotationUID)) {\n            return AnnotationStyleStates.Locked;\n        }\n        if (annotation.data && annotation.autoGenerated) {\n            return AnnotationStyleStates.AutoGenerated;\n        }\n    }\n    return AnnotationStyleStates.Default;\n}\nexport default getState;\n","import { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nexport function getAnnotation(annotationUID) {\n    const manager = defaultFrameOfReferenceSpecificAnnotationManager;\n    const annotation = manager.getAnnotation(annotationUID);\n    return annotation;\n}\n","import { getEnabledElement, triggerEvent, eventTarget, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { Events, ChangeTypes } from '../../../enums';\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\nfunction triggerAnnotationAddedForElement(annotation, element) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewportId } = enabledElement;\n    const eventType = Events.ANNOTATION_ADDED;\n    const eventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId: renderingEngine.id,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationAddedForFOR(annotation) {\n    const { toolName } = annotation.metadata;\n    const toolGroups = getToolGroupsWithToolName(toolName);\n    if (!toolGroups.length) {\n        return;\n    }\n    const viewportsToRender = [];\n    toolGroups.forEach((toolGroup) => {\n        toolGroup.viewportsInfo.forEach((viewportInfo) => {\n            const { renderingEngineId, viewportId } = viewportInfo;\n            const { FrameOfReferenceUID } = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\n                viewportsToRender.push(viewportInfo);\n            }\n        });\n    });\n    const eventType = Events.ANNOTATION_ADDED;\n    const eventDetail = { annotation };\n    if (!viewportsToRender.length) {\n        triggerEvent(eventTarget, eventType, eventDetail);\n        return;\n    }\n    viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\n        eventDetail.viewportId = viewportId;\n        eventDetail.renderingEngineId = renderingEngineId;\n        triggerEvent(eventTarget, eventType, eventDetail);\n    });\n}\nfunction triggerAnnotationRemoved(eventDetail) {\n    const eventType = Events.ANNOTATION_REMOVED;\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationModified(annotation, element, changeType = ChangeTypes.HandlesUpdated) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId, renderingEngineId } = enabledElement;\n    const eventType = Events.ANNOTATION_MODIFIED;\n    const eventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId,\n        changeType,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationCompleted(annotation) {\n    const eventDetail = {\n        annotation,\n    };\n    _triggerAnnotationCompleted(eventDetail);\n}\nfunction triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled = false) {\n    const eventDetail = {\n        annotation,\n        contourHoleProcessingEnabled,\n    };\n    _triggerAnnotationCompleted(eventDetail);\n}\nfunction _triggerAnnotationCompleted(eventDetail) {\n    const eventType = Events.ANNOTATION_COMPLETED;\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nexport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR, triggerAnnotationRemoved, triggerAnnotationModified, triggerAnnotationCompleted, triggerContourAnnotationCompleted, };\n","import { triggerEvent, eventTarget, Enums, getRenderingEngines, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations, Events as csToolsEvents, } from '../../enums';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport surfaceDisplay from '../../tools/displayTools/Surface/surfaceDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport { addTool } from '../../store/addTool';\nimport { state } from '../../store/state';\nimport PlanarFreehandContourSegmentationTool from '../../tools/annotation/PlanarFreehandContourSegmentationTool';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nconst renderers = {\n    [Representations.Labelmap]: labelmapDisplay,\n    [Representations.Contour]: contourDisplay,\n    [Representations.Surface]: surfaceDisplay,\n};\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\nclass SegmentationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._getAllViewports = () => {\n            const renderingEngine = getRenderingEngines();\n            return renderingEngine.flatMap((renderingEngine) => renderingEngine.getViewports());\n        };\n        this._renderFlaggedSegmentations = () => {\n            this._throwIfDestroyed();\n            const viewportIds = Array.from(this._needsRender);\n            viewportIds.forEach((viewportId) => {\n                this._triggerRender(viewportId);\n            });\n            this._needsRender.clear();\n            this._animationFrameSet = false;\n            this._animationFrameHandle = null;\n        };\n    }\n    renderSegmentationsForViewport(viewportId) {\n        const viewportIds = viewportId\n            ? [viewportId]\n            : this._getViewportIdsForSegmentation();\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    renderSegmentation(segmentationId) {\n        const viewportIds = this._getViewportIdsForSegmentation(segmentationId);\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    _getViewportIdsForSegmentation(segmentationId) {\n        const viewports = this._getAllViewports();\n        const viewportIds = [];\n        for (const viewport of viewports) {\n            const viewportId = viewport.id;\n            if (segmentationId) {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n            else {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n        }\n        return viewportIds;\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setViewportsToBeRenderedNextFrame(viewportIds) {\n        viewportIds.forEach((viewportId) => {\n            this._needsRender.add(viewportId);\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(viewportId) {\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n        if (!segmentationRepresentations?.length) {\n            return;\n        }\n        const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n        if (!viewport) {\n            return;\n        }\n        const viewportRenderList = [];\n        const segmentationRenderList = segmentationRepresentations.map((representation) => {\n            if (representation.type === SegmentationRepresentations.Contour) {\n                this._addPlanarFreeHandToolIfAbsent(viewport);\n            }\n            const display = renderers[representation.type];\n            try {\n                const viewportId = display.render(viewport, representation);\n                viewportRenderList.push(viewportId);\n            }\n            catch (error) {\n                console.error(error);\n            }\n            return Promise.resolve({\n                segmentationId: representation.segmentationId,\n                type: representation.type,\n            });\n        });\n        Promise.allSettled(segmentationRenderList).then((results) => {\n            const segmentationDetails = results\n                .filter((r) => r.status === 'fulfilled')\n                .map((r) => r.value);\n            function onSegmentationRender(evt) {\n                const { element, viewportId } = evt.detail;\n                element.removeEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n                segmentationDetails.forEach((detail) => {\n                    const eventDetail = {\n                        viewportId,\n                        segmentationId: detail.segmentationId,\n                        type: detail.type,\n                    };\n                    triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n                        ...eventDetail,\n                    });\n                });\n            }\n            const element = viewport.element;\n            element.addEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n            viewport.render();\n        });\n    }\n    _addPlanarFreeHandToolIfAbsent(viewport) {\n        if (!(planarContourToolName in state.tools)) {\n            addTool(PlanarFreehandContourSegmentationTool);\n        }\n        const toolGroup = getToolGroupForViewport(viewport.id);\n        if (!toolGroup.hasTool(planarContourToolName)) {\n            toolGroup.addTool(planarContourToolName);\n            toolGroup.setToolPassive(planarContourToolName);\n        }\n    }\n}\nfunction triggerSegmentationRender(viewportId) {\n    segmentationRenderingEngine.renderSegmentationsForViewport(viewportId);\n}\nfunction triggerSegmentationRenderBySegmentationId(segmentationId) {\n    segmentationRenderingEngine.renderSegmentation(segmentationId);\n}\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\nexport { triggerSegmentationRender, triggerSegmentationRenderBySegmentationId, segmentationRenderingEngine, };\n","import { BaseVolumeViewport, cache, utilities as csUtils, getEnabledElementByViewportId, volumeLoader, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport { triggerSegmentationModified, triggerSegmentationRemoved, triggerSegmentationRepresentationModified, triggerSegmentationRepresentationRemoved, } from './triggerSegmentationEvents';\nimport { segmentationStyle } from './SegmentationStyle';\nimport { triggerSegmentationAdded } from './events/triggerSegmentationAdded';\nconst initialDefaultState = {\n    colorLUT: [],\n    segmentations: [],\n    viewportSegRepresentations: {},\n};\nexport default class SegmentationStateManager {\n    constructor(uid) {\n        this._stackLabelmapImageIdReferenceMap = new Map();\n        uid ||= csUtils.uuidv4();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n        this.uid = uid;\n    }\n    getState() {\n        return this.state;\n    }\n    updateState(updater) {\n        const newState = csUtils.deepClone(this.state);\n        updater(newState);\n        this.state = Object.freeze(newState);\n    }\n    getColorLUT(lutIndex) {\n        return this.state.colorLUT[lutIndex];\n    }\n    getNextColorLUTIndex() {\n        return this.state.colorLUT.length;\n    }\n    resetState() {\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n    }\n    getSegmentation(segmentationId) {\n        return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n    }\n    updateSegmentation(segmentationId, payload) {\n        this.updateState((draftState) => {\n            const segmentation = draftState.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n            if (!segmentation) {\n                console.warn(`Segmentation with id ${segmentationId} not found. Update aborted.`);\n                return;\n            }\n            Object.assign(segmentation, payload);\n        });\n        triggerSegmentationModified(segmentationId);\n    }\n    addSegmentation(segmentation) {\n        if (this.getSegmentation(segmentation.segmentationId)) {\n            throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);\n        }\n        this.updateState((state) => {\n            const newSegmentation = csUtils.deepClone(segmentation);\n            if (newSegmentation.representationData.Labelmap &&\n                'volumeId' in newSegmentation.representationData.Labelmap &&\n                !('imageIds' in newSegmentation.representationData.Labelmap)) {\n                const imageIds = this.getLabelmapImageIds(newSegmentation.representationData);\n                newSegmentation.representationData\n                    .Labelmap.imageIds = imageIds;\n            }\n            state.segmentations.push(newSegmentation);\n        });\n        triggerSegmentationAdded(segmentation.segmentationId);\n    }\n    removeSegmentation(segmentationId) {\n        this.updateState((state) => {\n            const filteredSegmentations = state.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);\n            state.segmentations.splice(0, state.segmentations.length, ...filteredSegmentations);\n        });\n        triggerSegmentationRemoved(segmentationId);\n    }\n    addSegmentationRepresentation(viewportId, segmentationId, type, renderingConfig) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const existingRepresentations = this.getSegmentationRepresentations(viewportId, {\n            type: type,\n            segmentationId,\n        });\n        if (existingRepresentations.length > 0) {\n            console.debug('A segmentation representation of type', type, 'already exists in viewport', viewportId, 'for segmentation', segmentationId);\n            return;\n        }\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                state.viewportSegRepresentations[viewportId] = [];\n                segmentationStyle.setRenderInactiveSegmentations(viewportId, true);\n            }\n            if (type !== SegmentationRepresentations.Labelmap) {\n                this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig);\n            }\n            else {\n                this.addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig);\n            }\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId, type);\n    }\n    addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig) {\n        const segmentation = state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const segmentReps = {};\n        Object.keys(segmentation.segments).forEach((segmentIndex) => {\n            segmentReps[Number(segmentIndex)] = {\n                visible: true,\n            };\n        });\n        state.viewportSegRepresentations[viewportId].push({\n            segmentationId,\n            type,\n            active: true,\n            visible: true,\n            colorLUTIndex: renderingConfig?.colorLUTIndex || 0,\n            segments: segmentReps,\n            config: {\n                ...getDefaultRenderingConfig(type),\n                ...renderingConfig,\n            },\n        });\n        this._setActiveSegmentation(state, viewportId, segmentationId);\n    }\n    addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig = getDefaultRenderingConfig(SegmentationRepresentations.Labelmap)) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n        }\n        this.processLabelmapRepresentationAddition(viewportId, segmentationId);\n        this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n    }\n    async processLabelmapRepresentationAddition(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const volumeViewport = enabledElement.viewport instanceof BaseVolumeViewport;\n        const { representationData } = segmentation;\n        const isBaseVolumeSegmentation = 'volumeId' in representationData.Labelmap;\n        const viewport = enabledElement.viewport;\n        if (!volumeViewport && !isBaseVolumeSegmentation) {\n            !this.updateLabelmapSegmentationImageReferences(viewportId, segmentation.segmentationId);\n        }\n    }\n    _updateLabelmapSegmentationReferences(segmentationId, viewport, labelmapImageIds, updateCallback) {\n        const currentImageId = viewport.getCurrentImageId();\n        let viewableLabelmapImageIdFound = false;\n        for (const labelmapImageId of labelmapImageIds) {\n            const viewableImageId = viewport.isReferenceViewable({ referencedImageId: labelmapImageId }, { asOverlay: true });\n            if (viewableImageId) {\n                viewableLabelmapImageIdFound = true;\n                this._stackLabelmapImageIdReferenceMap\n                    .get(segmentationId)\n                    .set(currentImageId, labelmapImageId);\n            }\n        }\n        if (updateCallback) {\n            updateCallback(viewport, segmentationId, labelmapImageIds);\n        }\n        return viewableLabelmapImageIdFound\n            ? this._stackLabelmapImageIdReferenceMap\n                .get(segmentationId)\n                .get(currentImageId)\n            : undefined;\n    }\n    updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        return this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, null);\n    }\n    _updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, (stackViewport, segmentationId, labelmapImageIds) => {\n            const imageIds = stackViewport.getImageIds();\n            imageIds.forEach((imageId, index) => {\n                for (const labelmapImageId of labelmapImageIds) {\n                    const viewableImageId = stackViewport.isReferenceViewable({ referencedImageId: labelmapImageId, sliceIndex: index }, { asOverlay: true, withNavigation: true });\n                    if (viewableImageId) {\n                        this._stackLabelmapImageIdReferenceMap\n                            .get(segmentationId)\n                            .set(imageId, labelmapImageId);\n                    }\n                }\n            });\n        });\n    }\n    getLabelmapImageIds(representationData) {\n        const labelmapData = representationData.Labelmap;\n        let labelmapImageIds;\n        if (labelmapData.imageIds) {\n            labelmapImageIds = labelmapData\n                .imageIds;\n        }\n        else if (!labelmapImageIds &&\n            labelmapData.volumeId) {\n            const volumeId = labelmapData\n                .volumeId;\n            const volume = cache.getVolume(volumeId);\n            labelmapImageIds = volume.imageIds;\n        }\n        return labelmapImageIds;\n    }\n    getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const currentImageId = stackViewport.getCurrentImageId();\n        const imageIdReferenceMap = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIdReferenceMap.get(currentImageId);\n    }\n    getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return [];\n        }\n        this._updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId);\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        const imageIds = viewport.getImageIds();\n        const associatedReferenceImageAndLabelmapImageIds = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIds.map((imageId) => {\n            return associatedReferenceImageAndLabelmapImageIds.get(imageId);\n        });\n    }\n    removeSegmentationRepresentationsInternal(viewportId, specifier) {\n        const removedRepresentations = [];\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                return;\n            }\n            const currentRepresentations = state.viewportSegRepresentations[viewportId];\n            let activeRepresentationRemoved = false;\n            if (!specifier ||\n                Object.values(specifier).every((value) => value === undefined)) {\n                removedRepresentations.push(...currentRepresentations);\n                delete state.viewportSegRepresentations[viewportId];\n            }\n            else {\n                const { segmentationId, type } = specifier;\n                state.viewportSegRepresentations[viewportId] =\n                    currentRepresentations.filter((representation) => {\n                        const shouldRemove = (segmentationId &&\n                            type &&\n                            representation.segmentationId === segmentationId &&\n                            representation.type === type) ||\n                            (segmentationId &&\n                                !type &&\n                                representation.segmentationId === segmentationId) ||\n                            (!segmentationId && type && representation.type === type);\n                        if (shouldRemove) {\n                            removedRepresentations.push(representation);\n                            if (representation.active) {\n                                activeRepresentationRemoved = true;\n                            }\n                        }\n                        return !shouldRemove;\n                    });\n                if (state.viewportSegRepresentations[viewportId].length === 0) {\n                    delete state.viewportSegRepresentations[viewportId];\n                }\n                else if (activeRepresentationRemoved) {\n                    state.viewportSegRepresentations[viewportId][0].active = true;\n                }\n            }\n        });\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentations(viewportId, specifier) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        removedRepresentations.forEach((representation) => {\n            triggerSegmentationRepresentationRemoved(viewportId, representation.segmentationId, representation.type);\n        });\n        const remainingRepresentations = this.getSegmentationRepresentations(viewportId);\n        if (remainingRepresentations.length > 0 &&\n            remainingRepresentations[0].active) {\n            triggerSegmentationRepresentationModified(viewportId, remainingRepresentations[0].segmentationId, remainingRepresentations[0].type);\n        }\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentation(viewportId, specifier, suppressEvent) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        if (!suppressEvent) {\n            removedRepresentations.forEach(({ segmentationId, type }) => {\n                triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type);\n            });\n        }\n        return removedRepresentations;\n    }\n    _setActiveSegmentation(state, viewportId, segmentationId) {\n        const viewport = state.viewportSegRepresentations[viewportId];\n        if (!viewport) {\n            return;\n        }\n        viewport.forEach((value) => {\n            value.active = value.segmentationId === segmentationId;\n        });\n    }\n    setActiveSegmentation(viewportId, segmentationId) {\n        this.updateState((state) => {\n            const viewport = state.viewportSegRepresentations[viewportId];\n            if (!viewport) {\n                return;\n            }\n            viewport.forEach((value) => {\n                value.active = value.segmentationId === segmentationId;\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId);\n    }\n    getActiveSegmentation(viewportId) {\n        if (!this.state.viewportSegRepresentations[viewportId]) {\n            return;\n        }\n        const activeSegRep = this.state.viewportSegRepresentations[viewportId].find((segRep) => segRep.active);\n        if (!activeSegRep) {\n            return;\n        }\n        return this.getSegmentation(activeSegRep.segmentationId);\n    }\n    getSegmentationRepresentations(viewportId, specifier = {}) {\n        const viewportRepresentations = this.state.viewportSegRepresentations[viewportId];\n        if (!viewportRepresentations) {\n            return [];\n        }\n        if (!specifier.type && !specifier.segmentationId) {\n            return viewportRepresentations;\n        }\n        return viewportRepresentations.filter((representation) => {\n            const typeMatch = specifier.type\n                ? representation.type === specifier.type\n                : true;\n            const idMatch = specifier.segmentationId\n                ? representation.segmentationId === specifier.segmentationId\n                : true;\n            return typeMatch && idMatch;\n        });\n    }\n    getSegmentationRepresentation(viewportId, specifier) {\n        return this.getSegmentationRepresentations(viewportId, specifier)[0];\n    }\n    getSegmentationRepresentationVisibility(viewportId, specifier) {\n        const viewportRepresentation = this.getSegmentationRepresentation(viewportId, specifier);\n        return viewportRepresentation?.visible;\n    }\n    setSegmentationRepresentationVisibility(viewportId, specifier, visible) {\n        this.updateState((state) => {\n            const viewportRepresentations = this.getSegmentationRepresentations(viewportId, specifier);\n            if (!viewportRepresentations) {\n                return;\n            }\n            viewportRepresentations.forEach((representation) => {\n                representation.visible = visible;\n                Object.entries(representation.segments).forEach(([segmentIndex, segment]) => {\n                    segment.visible = visible;\n                });\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId, specifier.type);\n    }\n    addColorLUT(colorLUT, lutIndex) {\n        this.updateState((state) => {\n            if (state.colorLUT[lutIndex]) {\n                console.warn('Color LUT table already exists, overwriting');\n            }\n            state.colorLUT[lutIndex] = csUtils.deepClone(colorLUT);\n        });\n    }\n    removeColorLUT(colorLUTIndex) {\n        this.updateState((state) => {\n            delete state.colorLUT[colorLUTIndex];\n        });\n    }\n    _getStackIdForImageIds(imageIds) {\n        return imageIds\n            .map((imageId) => imageId.slice(-Math.round(imageId.length * 0.15)))\n            .join('_');\n    }\n    getAllViewportSegmentationRepresentations() {\n        return Object.entries(this.state.viewportSegRepresentations).map(([viewportId, representations]) => ({\n            viewportId,\n            representations,\n        }));\n    }\n    getSegmentationRepresentationsBySegmentationId(segmentationId) {\n        const result = [];\n        Object.entries(this.state.viewportSegRepresentations).forEach(([viewportId, viewportReps]) => {\n            const filteredReps = viewportReps.filter((representation) => representation.segmentationId === segmentationId);\n            if (filteredReps.length > 0) {\n                result.push({ viewportId, representations: filteredReps });\n            }\n        });\n        return result;\n    }\n}\nasync function internalComputeVolumeLabelmapFromStack({ imageIds, options, }) {\n    const segmentationImageIds = imageIds;\n    const volumeId = options?.volumeId || csUtils.uuidv4();\n    await volumeLoader.createAndCacheVolumeFromImages(volumeId, segmentationImageIds);\n    return { volumeId };\n}\nasync function internalConvertStackToVolumeLabelmap({ segmentationId, options, }) {\n    const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);\n    const data = segmentation.representationData\n        .Labelmap;\n    const { volumeId } = await internalComputeVolumeLabelmapFromStack({\n        imageIds: data.imageIds,\n        options,\n    });\n    segmentation.representationData.Labelmap.volumeId = volumeId;\n}\nfunction getDefaultRenderingConfig(type) {\n    const cfun = vtkColorTransferFunction.newInstance();\n    const ofun = vtkPiecewiseFunction.newInstance();\n    ofun.addPoint(0, 0);\n    if (type === SegmentationRepresentations.Labelmap) {\n        return {\n            cfun,\n            ofun,\n        };\n    }\n    else {\n        return {};\n    }\n}\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { internalConvertStackToVolumeLabelmap, internalComputeVolumeLabelmapFromStack, defaultSegmentationStateManager, };\n","import getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport * as Enums from '../../enums';\nimport { utilities } from '@cornerstonejs/core';\nclass SegmentationStyle {\n    constructor() {\n        this.config = {\n            global: {},\n            segmentations: {},\n            viewportsStyle: {},\n        };\n    }\n    setStyle(specifier, styles) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        const currentStyles = this.getStyle(specifier);\n        let updatedStyles;\n        if (!viewportId && !segmentationId) {\n            updatedStyles = {\n                ...currentStyles,\n                ...styles,\n            };\n        }\n        else {\n            updatedStyles = this.copyActiveToInactiveIfNotProvided({\n                ...currentStyles,\n                ...styles,\n            }, type);\n        }\n        if (!type) {\n            throw new Error('Type is required to set a style');\n        }\n        if (viewportId) {\n            if (!this.config.viewportsStyle[viewportId]) {\n                this.config.viewportsStyle[viewportId] = {\n                    renderInactiveSegmentations: false,\n                    representations: {},\n                };\n            }\n            const representations = this.config.viewportsStyle[viewportId].representations;\n            if (segmentationId) {\n                if (!representations[segmentationId]) {\n                    representations[segmentationId] = {};\n                }\n                if (!representations[segmentationId][type]) {\n                    representations[segmentationId][type] = {};\n                }\n                const repConfig = representations[segmentationId][type];\n                if (segmentIndex !== undefined) {\n                    if (!repConfig.perSegment) {\n                        repConfig.perSegment = {};\n                    }\n                    repConfig.perSegment[segmentIndex] = updatedStyles;\n                }\n                else {\n                    repConfig.allSegments = updatedStyles;\n                }\n            }\n            else {\n                const ALL_SEGMENTATIONS_KEY = '__allSegmentations__';\n                if (!representations[ALL_SEGMENTATIONS_KEY]) {\n                    representations[ALL_SEGMENTATIONS_KEY] = {};\n                }\n                if (!representations[ALL_SEGMENTATIONS_KEY][type]) {\n                    representations[ALL_SEGMENTATIONS_KEY][type] = {};\n                }\n                representations[ALL_SEGMENTATIONS_KEY][type].allSegments =\n                    updatedStyles;\n            }\n        }\n        else if (segmentationId) {\n            if (!this.config.segmentations[segmentationId]) {\n                this.config.segmentations[segmentationId] = {};\n            }\n            if (!this.config.segmentations[segmentationId][type]) {\n                this.config.segmentations[segmentationId][type] = {};\n            }\n            const segConfig = this.config.segmentations[segmentationId][type];\n            if (segmentIndex !== undefined) {\n                if (!segConfig.perSegment) {\n                    segConfig.perSegment = {};\n                }\n                segConfig.perSegment[segmentIndex] = updatedStyles;\n            }\n            else {\n                segConfig.allSegments = updatedStyles;\n            }\n        }\n        else {\n            this.config.global[type] = updatedStyles;\n        }\n    }\n    copyActiveToInactiveIfNotProvided(styles, type) {\n        const processedStyles = { ...styles };\n        if (type === Enums.SegmentationRepresentations.Labelmap) {\n            const labelmapStyles = processedStyles;\n            labelmapStyles.renderOutlineInactive = labelmapStyles.renderOutline;\n            labelmapStyles.outlineWidthInactive = labelmapStyles.outlineWidth;\n            labelmapStyles.renderFillInactive = labelmapStyles.renderFill;\n            labelmapStyles.fillAlphaInactive = labelmapStyles.fillAlpha;\n            labelmapStyles.outlineOpacityInactive = labelmapStyles.outlineOpacity;\n        }\n        else if (type === Enums.SegmentationRepresentations.Contour) {\n            const contourStyles = processedStyles;\n            contourStyles.outlineWidthInactive = contourStyles.outlineWidth;\n            contourStyles.outlineOpacityInactive = contourStyles.outlineOpacity;\n            contourStyles.outlineDashInactive = contourStyles.outlineDash;\n            contourStyles.renderOutlineInactive = contourStyles.renderOutline;\n            contourStyles.renderFillInactive = contourStyles.renderFill;\n            contourStyles.fillAlphaInactive = contourStyles.fillAlpha;\n        }\n        return processedStyles;\n    }\n    getStyle(specifier) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        let combinedStyle = this.getDefaultStyle(type);\n        let renderInactiveSegmentations = false;\n        if (this.config.global[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.global[type],\n            };\n        }\n        if (this.config.segmentations[segmentationId]?.[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.segmentations[segmentationId][type].allSegments,\n            };\n            if (segmentIndex !== undefined &&\n                this.config.segmentations[segmentationId][type].perSegment?.[segmentIndex]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.segmentations[segmentationId][type].perSegment[segmentIndex],\n                };\n            }\n        }\n        if (viewportId && this.config.viewportsStyle[viewportId]) {\n            renderInactiveSegmentations =\n                this.config.viewportsStyle[viewportId].renderInactiveSegmentations;\n            const allSegmentationsKey = '__allSegmentations__';\n            if (this.config.viewportsStyle[viewportId].representations[allSegmentationsKey]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[allSegmentationsKey][type].allSegments,\n                };\n            }\n            if (segmentationId &&\n                this.config.viewportsStyle[viewportId].representations[segmentationId]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].allSegments,\n                };\n                if (segmentIndex !== undefined &&\n                    this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment?.[segmentIndex]) {\n                    combinedStyle = {\n                        ...combinedStyle,\n                        ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment[segmentIndex],\n                    };\n                }\n            }\n        }\n        return combinedStyle;\n    }\n    getRenderInactiveSegmentations(viewportId) {\n        return this.config.viewportsStyle[viewportId]?.renderInactiveSegmentations;\n    }\n    setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {\n        if (!this.config.viewportsStyle[viewportId]) {\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations: false,\n                representations: {},\n            };\n        }\n        this.config.viewportsStyle[viewportId].renderInactiveSegmentations =\n            renderInactiveSegmentations;\n    }\n    getDefaultStyle(type) {\n        switch (type) {\n            case Enums.SegmentationRepresentations.Labelmap:\n                return getDefaultLabelmapConfig();\n            case Enums.SegmentationRepresentations.Contour:\n                return getDefaultContourConfig();\n            case Enums.SegmentationRepresentations.Surface:\n                return {};\n            default:\n                throw new Error(`Unknown representation type: ${type}`);\n        }\n    }\n    clearSegmentationStyle(segmentationId) {\n        if (this.config.segmentations[segmentationId]) {\n            delete this.config.segmentations[segmentationId];\n        }\n    }\n    clearAllSegmentationStyles() {\n        this.config.segmentations = {};\n    }\n    clearViewportStyle(viewportId) {\n        if (this.config.viewportsStyle[viewportId]) {\n            delete this.config.viewportsStyle[viewportId];\n        }\n    }\n    clearAllViewportStyles() {\n        for (const viewportId in this.config.viewportsStyle) {\n            const viewportStyle = this.config.viewportsStyle[viewportId];\n            const renderInactiveSegmentations = viewportStyle.renderInactiveSegmentations;\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations,\n                representations: {},\n            };\n        }\n    }\n    resetToGlobalStyle() {\n        this.clearAllSegmentationStyles();\n        this.clearAllViewportStyles();\n    }\n    hasCustomStyle(specifier) {\n        const { type } = specifier;\n        const style = this.getStyle(specifier);\n        const defaultStyle = this.getDefaultStyle(type);\n        return !utilities.deepEqual(style, defaultStyle);\n    }\n}\nconst segmentationStyle = new SegmentationStyle();\nexport { segmentationStyle };\n","import { getActiveSegmentation as _getActiveSegmentation } from './getActiveSegmentation';\nimport { setActiveSegmentation as _setActiveSegmentation } from './setActiveSegmentation';\nfunction getActiveSegmentation(viewportId) {\n    return _getActiveSegmentation(viewportId);\n}\nfunction setActiveSegmentation(viewportId, segmentationId, suppressEvent = false) {\n    _setActiveSegmentation(viewportId, segmentationId);\n}\nexport { getActiveSegmentation, setActiveSegmentation, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function setActiveSegmentation(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.setActiveSegmentation(viewportId, segmentationId);\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nexport function addColorLUT(colorLUT, index) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const indexToUse = index ?? getNextColorLUTIndex();\n    let colorLUTToUse = [...colorLUT];\n    if (!utilities.isEqual(colorLUTToUse[0], [0, 0, 0, 0])) {\n        console.warn('addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it');\n        colorLUTToUse = [[0, 0, 0, 0], ...colorLUTToUse];\n    }\n    colorLUTToUse = colorLUTToUse.map((color) => {\n        if (color.length === 3) {\n            return [color[0], color[1], color[2], 255];\n        }\n        return color;\n    });\n    if (colorLUTToUse.length < 255) {\n        const missingColorLUTs = CORNERSTONE_COLOR_LUT.slice(colorLUTToUse.length);\n        colorLUTToUse = [...colorLUTToUse, ...missingColorLUTs];\n    }\n    segmentationStateManager.addColorLUT(colorLUTToUse, indexToUse);\n    return indexToUse;\n}\n","import CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { addColorLUT } from './addColorLUT';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getColorLUT } from './getColorLUT';\nfunction internalAddSegmentationRepresentation(viewportId, representationInput) {\n    const { segmentationId, config } = representationInput;\n    const renderingConfig = {\n        colorLUTIndex: getColorLUTIndex(config),\n    };\n    defaultSegmentationStateManager.addSegmentationRepresentation(viewportId, segmentationId, representationInput.type, renderingConfig);\n    if (representationInput.type === SegmentationRepresentations.Contour) {\n        triggerAnnotationRenderForViewportIds([viewportId]);\n    }\n    triggerSegmentationModified(segmentationId);\n}\nfunction getColorLUTIndex(config) {\n    const { colorLUTOrIndex } = config || {};\n    if (colorLUTOrIndex === undefined) {\n        const index = addColorLUT(JSON.parse(JSON.stringify(CORNERSTONE_COLOR_LUT)));\n        return index;\n    }\n    if (typeof colorLUTOrIndex === 'number') {\n        return colorLUTOrIndex;\n    }\n    if (Array.isArray(colorLUTOrIndex) &&\n        colorLUTOrIndex.every((item) => Array.isArray(item) && item.length === 4)) {\n        const index = addColorLUT(colorLUTOrIndex);\n        return index;\n    }\n    const index = addColorLUT(JSON.parse(JSON.stringify(CORNERSTONE_COLOR_LUT)));\n    return index;\n}\nexport { internalAddSegmentationRepresentation };\n","import { SegmentationRepresentations } from '../../enums';\nimport { internalAddSegmentationRepresentation } from './internalAddSegmentationRepresentation';\nexport function addSegmentationRepresentations(viewportId, segmentationInputArray) {\n    segmentationInputArray.map((segmentationInput) => {\n        return internalAddSegmentationRepresentation(viewportId, segmentationInput);\n    });\n}\nfunction addContourRepresentationToViewport(viewportId, contourInputArray) {\n    return addSegmentationRepresentations(viewportId, contourInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Contour,\n    })));\n}\nfunction addContourRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addContourRepresentationToViewport(viewportId, inputArray);\n    }\n    return results;\n}\nfunction addLabelmapRepresentationToViewport(viewportId, labelmapInputArray) {\n    return addSegmentationRepresentations(viewportId, labelmapInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Labelmap,\n    })));\n}\nfunction addLabelmapRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addLabelmapRepresentationToViewport(viewportId, inputArray.map((input) => ({\n            ...input,\n            type: SegmentationRepresentations.Labelmap,\n        })));\n    }\n}\nfunction addSurfaceRepresentationToViewport(viewportId, surfaceInputArray) {\n    return addSegmentationRepresentations(viewportId, surfaceInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Surface,\n    })));\n}\nfunction addSurfaceRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addSurfaceRepresentationToViewport(viewportId, inputArray);\n    }\n    return results;\n}\nexport { addContourRepresentationToViewport, addLabelmapRepresentationToViewport, addSurfaceRepresentationToViewport, addContourRepresentationToViewportMap, addLabelmapRepresentationToViewportMap, addSurfaceRepresentationToViewportMap, };\n","import { addColorLUT as _addColorLUT } from '../addColorLUT';\nimport { getColorLUT as _getColorLUT } from '../getColorLUT';\nimport { getSegmentationRepresentations } from '../getSegmentationRepresentation';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction addColorLUT(colorLUT, colorLUTIndex) {\n    if (!colorLUT) {\n        throw new Error('addColorLUT: colorLUT is required');\n    }\n    return _addColorLUT(colorLUT, colorLUTIndex);\n}\nfunction setColorLUT(viewportId, segmentationId, colorLUTsIndex) {\n    if (!_getColorLUT(colorLUTsIndex)) {\n        throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTsIndex}`);\n    }\n    const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n    if (!segmentationRepresentations) {\n        throw new Error(`viewport specific state for viewport ${viewportId} does not exist`);\n    }\n    segmentationRepresentations.forEach((segmentationRepresentation) => {\n        segmentationRepresentation.colorLUTIndex = colorLUTsIndex;\n    });\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nfunction getSegmentIndexColor(viewportId, segmentationId, segmentIndex) {\n    const representations = getSegmentationRepresentations(viewportId, {\n        segmentationId,\n    });\n    if (!representations || representations.length === 0) {\n        return null;\n    }\n    const representation = representations[0];\n    const { colorLUTIndex } = representation;\n    const colorLUT = _getColorLUT(colorLUTIndex);\n    let colorValue = colorLUT[segmentIndex];\n    if (!colorValue) {\n        if (typeof segmentIndex !== 'number') {\n            throw new Error(`Can't create colour for LUT index ${segmentIndex}`);\n        }\n        colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];\n    }\n    return colorValue;\n}\nfunction setSegmentIndexColor(viewportId, segmentationId, segmentIndex, color) {\n    const colorReference = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    for (let i = 0; i < color.length; i++) {\n        colorReference[i] = color[i];\n    }\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nexport { getSegmentIndexColor, addColorLUT, setColorLUT, setSegmentIndexColor };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport { setSegmentationDirty } from '../../../utilities/segmentation/utilities';\nexport function triggerSegmentationDataModified(segmentationId, modifiedSlicesToUse) {\n    const eventDetail = {\n        segmentationId,\n        modifiedSlicesToUse,\n    };\n    setSegmentationDirty(segmentationId);\n    triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n","import { getSegmentation } from './getSegmentation';\nexport function getActiveSegmentIndex(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (segmentation) {\n        const activeSegmentIndex = Object.keys(segmentation.segments).find((segmentIndex) => segmentation.segments[segmentIndex].active);\n        return activeSegmentIndex ? Number(activeSegmentIndex) : undefined;\n    }\n    return undefined;\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getActiveSegmentation(viewportId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getActiveSegmentation(viewportId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getCurrentLabelmapImageIdForViewport(viewportId, segmentationId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentations(viewportId, specifier = {}) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n}\nexport function getSegmentationRepresentation(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    if (!specifier.segmentationId || !specifier.type) {\n        throw new Error('getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them');\n    }\n    const representations = segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n    return representations?.[0];\n}\nexport function getSegmentationRepresentationsBySegmentationId(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationsBySegmentationId(segmentationId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentationVisibility(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationVisibility(viewportId, specifier);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentations() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    return state.segmentations;\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getViewportIdsWithSegmentation(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    const viewportSegRepresentations = state.viewportSegRepresentations;\n    const viewportIdsWithSegmentation = Object.entries(viewportSegRepresentations)\n        .filter(([, viewportSegmentations]) => viewportSegmentations.some((segRep) => segRep.segmentationId === segmentationId))\n        .map(([viewportId]) => viewportId);\n    return viewportIdsWithSegmentation;\n}\n","import { internalComputeVolumeLabelmapFromStack } from '../SegmentationStateManager';\nexport async function computeVolumeLabelmapFromStack(args) {\n    return internalComputeVolumeLabelmapFromStack(args);\n}\n","import { removeContourRepresentation, removeLabelmapRepresentation, removeSegmentationRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentations, removeAllSegmentationRepresentations, } from './removeSegmentationRepresentations';\nimport { addContourRepresentationToViewport, addContourRepresentationToViewportMap, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentationRepresentations, } from './addSegmentationRepresentationsToViewport';\nimport { addSegmentations } from './addSegmentations';\nimport { updateSegmentations } from './updateSegmentations';\nimport * as activeSegmentation from './activeSegmentation';\nimport * as segmentLocking from './segmentLocking';\nimport * as state from './segmentationState';\nimport * as config from './config';\nimport * as segmentIndex from './segmentIndex';\nimport * as triggerSegmentationEvents from './triggerSegmentationEvents';\nimport { convertStackToVolumeLabelmap } from './helpers/convertStackToVolumeLabelmap';\nimport { computeVolumeLabelmapFromStack } from './helpers/computeVolumeLabelmapFromStack';\nimport * as polySegManager from './polySeg';\nimport { clearSegmentValue } from './helpers/clearSegmentValue';\nimport { convertVolumeToStackLabelmap } from './helpers/computeStackLabelmapFromVolume';\nimport { removeSegment } from './removeSegment';\nimport { getLabelmapImageIds } from './getLabelmapImageIds';\nimport { removeAllSegmentations, removeSegmentation, } from './removeSegmentation';\nconst helpers = {\n    clearSegmentValue,\n    convertStackToVolumeLabelmap,\n    computeVolumeLabelmapFromStack,\n    convertVolumeToStackLabelmap,\n};\nexport { removeSegmentationRepresentation, removeContourRepresentation, removeLabelmapRepresentation, removeSurfaceRepresentation, removeAllSegmentations, removeSegmentation, removeSegmentationRepresentations, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentationRepresentations, removeAllSegmentationRepresentations, addContourRepresentationToViewport, addContourRepresentationToViewportMap, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, addSegmentations, updateSegmentations, state, activeSegmentation, segmentLocking, config, segmentIndex, triggerSegmentationEvents, helpers, polySegManager as polySeg, removeSegment, getLabelmapImageIds, };\n","import { SegmentationRepresentations } from '../../../../enums';\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\nimport { computeContourData } from './contourComputationStrategies';\nexport function computeAndAddContourRepresentation(segmentationId, options = {}) {\n    return computeAndAddRepresentation(segmentationId, SegmentationRepresentations.Contour, () => computeContourData(segmentationId, options), () => undefined);\n}\n","import { SegmentationRepresentations } from '../../../../enums';\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\nimport { computeLabelmapData } from './labelmapComputationStrategies';\nimport { defaultSegmentationStateManager } from '../../SegmentationStateManager';\nimport { triggerSegmentationDataModified } from '../../triggerSegmentationEvents';\nexport async function computeAndAddLabelmapRepresentation(segmentationId, options = {}) {\n    return computeAndAddRepresentation(segmentationId, SegmentationRepresentations.Labelmap, () => computeLabelmapData(segmentationId, options), () => null, () => {\n        defaultSegmentationStateManager.processLabelmapRepresentationAddition(options.viewport.id, segmentationId);\n        setTimeout(() => {\n            triggerSegmentationDataModified(segmentationId);\n        }, 0);\n    });\n}\n","import { SegmentationRepresentations } from '../../../../enums';\nimport { computeAndAddRepresentation } from '../computeAndAddRepresentation';\nimport { computeSurfaceData } from './surfaceComputationStrategies';\nimport { updateSurfaceData } from './updateSurfaceData';\nexport function computeAndAddSurfaceRepresentation(segmentationId, options = {}) {\n    return computeAndAddRepresentation(segmentationId, SegmentationRepresentations.Surface, () => computeSurfaceData(segmentationId, options), () => updateSurfaceData(segmentationId));\n}\n","import { cache } from '@cornerstonejs/core';\nimport { getUniqueSegmentIndices } from '../../../../utilities/segmentation/getUniqueSegmentIndices';\nimport { getViewportIdsWithSegmentation } from '../../getViewportIdsWithSegmentation';\nimport { getSegmentation } from '../../getSegmentation';\nimport { triggerSegmentationModified } from '../../triggerSegmentationEvents';\nimport { getSegmentationRepresentation } from '../../getSegmentationRepresentation';\nimport { SegmentationRepresentations } from '../../../../enums';\nimport { computeSurfaceFromLabelmapSegmentation } from './surfaceComputationStrategies';\nimport { createAndCacheSurfacesFromRaw } from './createAndCacheSurfacesFromRaw';\nexport async function updateSurfaceData(segmentationId) {\n    const surfacesObj = await computeSurfaceFromLabelmapSegmentation(segmentationId);\n    if (!surfacesObj) {\n        return;\n    }\n    const segmentation = getSegmentation(segmentationId);\n    const indices = getUniqueSegmentIndices(segmentationId);\n    if (!indices.length) {\n        const geometryIds = segmentation.representationData.Surface.geometryIds;\n        geometryIds.forEach((geometryId) => {\n            const geometry = cache.getGeometry(geometryId);\n            const surface = geometry.data;\n            surface.points = [];\n            surface.polys = [];\n        });\n        triggerSegmentationModified(segmentationId);\n        return;\n    }\n    const promises = surfacesObj.map(({ data, segmentIndex }) => {\n        const geometryId = `segmentation_${segmentationId}_surface_${segmentIndex}`;\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry) {\n            const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n            return viewportIds.map((viewportId) => {\n                const surfaceRepresentation = getSegmentationRepresentation(viewportId, {\n                    segmentationId,\n                    type: SegmentationRepresentations.Surface,\n                });\n                return [surfaceRepresentation].map((surfaceRepresentation) => {\n                    segmentation.representationData.Surface.geometryIds.set(segmentIndex, geometryId);\n                    return createAndCacheSurfacesFromRaw(segmentationId, [{ segmentIndex, data }], {\n                        segmentationId: surfaceRepresentation.segmentationId,\n                    });\n                });\n            });\n        }\n        else if (indices.includes(segmentIndex)) {\n            const surface = geometry.data;\n            surface.points = data.points;\n            surface.polys = data.polys;\n        }\n        else {\n            const surface = geometry.data;\n            surface.points = [];\n            surface.polys = [];\n        }\n    });\n    await Promise.all(promises);\n    triggerSegmentationModified(segmentationId);\n}\n","import { Enums, geometryLoader } from '@cornerstonejs/core';\nimport { getSegmentIndexColor } from '../../config/segmentationColor';\nimport { getSegmentation } from '../../getSegmentation';\nexport async function createAndCacheSurfacesFromRaw(segmentationId, rawSurfacesData, options = {}) {\n    const segmentation = getSegmentation(segmentationId);\n    const geometryIds = new Map();\n    const promises = Object.keys(rawSurfacesData).map(async (index) => {\n        const rawSurfaceData = rawSurfacesData[index];\n        const segmentIndex = rawSurfaceData.segmentIndex;\n        const color = getSegmentIndexColor(options.viewport.id, segmentation.segmentationId, segmentIndex).slice(0, 3);\n        if (!color) {\n            throw new Error('No color found for segment index, unable to create surface');\n        }\n        const closedSurface = {\n            id: `segmentation_${segmentation.segmentationId}_surface_${segmentIndex}`,\n            color,\n            frameOfReferenceUID: 'test-frameOfReferenceUID',\n            points: rawSurfaceData.data.points,\n            polys: rawSurfaceData.data.polys,\n            segmentIndex,\n        };\n        const geometryId = closedSurface.id;\n        geometryIds.set(segmentIndex, geometryId);\n        return geometryLoader.createAndCacheGeometry(geometryId, {\n            type: Enums.GeometryType.SURFACE,\n            geometryData: closedSurface,\n        });\n    });\n    await Promise.all(promises);\n    return {\n        geometryIds,\n    };\n}\n","import { Enums, eventTarget, triggerEvent, getWebWorkerManager, } from '@cornerstonejs/core';\nimport { getAnnotation } from '../../../annotation/annotationState';\nimport { WorkerTypes } from '../../../../enums';\nconst workerManager = getWebWorkerManager();\nconst triggerWorkerProgress = (eventTarget, progress, id) => {\n    triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n        progress,\n        type: WorkerTypes.POLYSEG_CONTOUR_TO_SURFACE,\n        id,\n    });\n};\nexport async function convertContourToSurface(contourRepresentationData, segmentIndex) {\n    const { annotationUIDsMap } = contourRepresentationData;\n    const polylines = [];\n    const numPointsArray = [];\n    const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n    for (const annotationUID of annotationUIDs) {\n        const annotation = getAnnotation(annotationUID);\n        const { polyline } = annotation.data\n            .contour;\n        numPointsArray.push(polyline.length);\n        polyline.forEach((polyline) => polylines.push(...polyline));\n    }\n    triggerWorkerProgress(eventTarget, 0, segmentIndex);\n    const results = await workerManager.executeTask('polySeg', 'convertContourToSurface', {\n        polylines,\n        numPointsArray,\n    }, {\n        callbacks: [\n            (progress) => {\n                triggerWorkerProgress(eventTarget, progress, segmentIndex);\n            },\n        ],\n    });\n    triggerWorkerProgress(eventTarget, 100, segmentIndex);\n    return results;\n}\n","import { cache, eventTarget, getWebWorkerManager, triggerEvent, Enums, } from '@cornerstonejs/core';\nimport { computeVolumeLabelmapFromStack } from '../../helpers/computeVolumeLabelmapFromStack';\nimport { WorkerTypes } from '../../../../enums';\nconst workerManager = getWebWorkerManager();\nconst triggerWorkerProgress = (eventTarget, progress, id) => {\n    triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n        progress,\n        type: WorkerTypes.POLYSEG_LABELMAP_TO_SURFACE,\n        id,\n    });\n};\nexport async function convertLabelmapToSurface(labelmapRepresentationData, segmentIndex) {\n    let volumeId;\n    if (labelmapRepresentationData.volumeId) {\n        volumeId = labelmapRepresentationData\n            .volumeId;\n    }\n    else {\n        const { imageIds } = labelmapRepresentationData;\n        ({ volumeId } = await computeVolumeLabelmapFromStack({\n            imageIds,\n        }));\n    }\n    const volume = cache.getVolume(volumeId);\n    const scalarData = volume.voxelManager.getCompleteScalarDataArray();\n    const { dimensions, spacing, origin, direction } = volume;\n    triggerWorkerProgress(eventTarget, 0, segmentIndex);\n    const results = await workerManager.executeTask('polySeg', 'convertLabelmapToSurface', {\n        scalarData,\n        dimensions,\n        spacing,\n        origin,\n        direction,\n        segmentIndex,\n    }, {\n        callbacks: [\n            (progress) => {\n                triggerWorkerProgress(eventTarget, progress, segmentIndex);\n            },\n        ],\n    });\n    triggerWorkerProgress(eventTarget, 100, segmentIndex);\n    return results;\n}\n","import { getUniqueSegmentIndices } from '../../../../utilities/segmentation/getUniqueSegmentIndices';\nimport { getSegmentation } from '../../getSegmentation';\nimport { convertContourToSurface } from './convertContourToSurface';\nimport { createAndCacheSurfacesFromRaw } from './createAndCacheSurfacesFromRaw';\nimport { convertLabelmapToSurface } from './convertLabelmapToSurface';\nexport async function computeSurfaceData(segmentationId, options = {}) {\n    const segmentIndices = options.segmentIndices?.length\n        ? options.segmentIndices\n        : getUniqueSegmentIndices(segmentationId);\n    let rawSurfacesData;\n    const segmentation = getSegmentation(segmentationId);\n    const representationData = segmentation.representationData;\n    try {\n        if (representationData.Contour) {\n            rawSurfacesData = await computeSurfaceFromContourSegmentation(segmentationId, {\n                segmentIndices,\n                ...options,\n            });\n        }\n        else if (representationData.Labelmap) {\n            rawSurfacesData = await computeSurfaceFromLabelmapSegmentation(segmentation.segmentationId, {\n                segmentIndices,\n                ...options,\n            });\n        }\n    }\n    catch (error) {\n        console.error(error);\n        throw error;\n    }\n    if (!rawSurfacesData) {\n        throw new Error('Not enough data to convert to surface, currently only support converting volume labelmap to surface if available');\n    }\n    const surfacesData = await createAndCacheSurfacesFromRaw(segmentationId, rawSurfacesData, options);\n    return surfacesData;\n}\nasync function computeSurfaceFromLabelmapSegmentation(segmentationId, options = {}) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation?.representationData?.Labelmap) {\n        console.warn('Only support surface update from labelmaps');\n        return;\n    }\n    const labelmapRepresentationData = segmentation.representationData.Labelmap;\n    const segmentIndices = options.segmentIndices || getUniqueSegmentIndices(segmentationId);\n    const promises = segmentIndices.map((index) => {\n        const surface = convertLabelmapToSurface(labelmapRepresentationData, index);\n        return surface;\n    });\n    const surfaces = await Promise.allSettled(promises);\n    const errors = surfaces.filter((p) => p.status === 'rejected');\n    if (errors.length > 0) {\n        console.error(errors);\n        throw new Error('Failed to convert labelmap to surface');\n    }\n    const rawSurfacesData = surfaces\n        .map((surface, index) => {\n        if (surface.status === 'fulfilled') {\n            return { segmentIndex: segmentIndices[index], data: surface.value };\n        }\n    })\n        .filter(Boolean);\n    return rawSurfacesData;\n}\nasync function computeSurfaceFromContourSegmentation(segmentationId, options = {}) {\n    const segmentation = getSegmentation(segmentationId);\n    const contourRepresentationData = segmentation.representationData.Contour;\n    const segmentIndices = options.segmentIndices || getUniqueSegmentIndices(segmentationId);\n    const promises = segmentIndices.map(async (index) => {\n        const surface = await convertContourToSurface(contourRepresentationData, index);\n        return { segmentIndex: index, data: surface };\n    });\n    const surfaces = await Promise.all(promises);\n    return surfaces;\n}\nexport { computeSurfaceFromContourSegmentation, computeSurfaceFromLabelmapSegmentation, };\n","import { SegmentationRepresentations } from '../../../enums';\nimport { getSegmentation } from '../getSegmentation';\nimport { validate as validateLabelmap } from '../../../tools/displayTools/Labelmap/validateLabelmap';\nconst conversionPaths = new Map([\n    [\n        SegmentationRepresentations.Labelmap,\n        new Set([\n            SegmentationRepresentations.Surface,\n            SegmentationRepresentations.Contour,\n        ]),\n    ],\n    [\n        SegmentationRepresentations.Contour,\n        new Set([\n            SegmentationRepresentations.Labelmap,\n            SegmentationRepresentations.Surface,\n        ]),\n    ],\n    [\n        SegmentationRepresentations.Surface,\n        new Set([SegmentationRepresentations.Labelmap]),\n    ],\n]);\nfunction canComputeRequestedRepresentation(segmentationId, type) {\n    const { representationData } = getSegmentation(segmentationId);\n    const existingRepresentationTypes = getExistingRepresentationTypes(representationData);\n    return existingRepresentationTypes.some((existingRepresentationType) => canConvertFromTo(existingRepresentationType, type));\n}\nfunction getExistingRepresentationTypes(representationData) {\n    const supportedTypes = [];\n    Object.keys(representationData).forEach((representationType) => {\n        const representationTypeData = representationData[representationType];\n        let validateFn;\n        switch (representationType) {\n            case SegmentationRepresentations.Labelmap:\n                validateFn = validateLabelmap;\n                break;\n        }\n        if (validateFn) {\n            try {\n                validateFn(representationTypeData);\n                supportedTypes.push(representationType);\n            }\n            catch (error) {\n                console.warn(`Validation failed for labelmap of type ${representationType}`);\n            }\n        }\n        else {\n            supportedTypes.push(representationType);\n        }\n    });\n    return supportedTypes;\n}\nasync function canConvertFromTo(fromRepresentationType, toRepresentationType) {\n    return (conversionPaths.get(fromRepresentationType)?.has(toRepresentationType) ||\n        false);\n}\nexport { canComputeRequestedRepresentation };\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport addRepresentationData from '../internalAddRepresentationData';\nimport { triggerSegmentationModified } from '../triggerSegmentationEvents';\nimport debounce from '../../../utilities/debounce';\nimport { registerPolySegWorker } from './registerPolySegWorker';\nconst computedRepresentations = new Map();\nasync function computeAndAddRepresentation(segmentationId, type, computeFunction, updateFunction, onComputationComplete) {\n    registerPolySegWorker();\n    const data = await computeFunction();\n    addRepresentationData({\n        segmentationId,\n        type,\n        data,\n    });\n    onComputationComplete?.();\n    if (!computedRepresentations.has(segmentationId)) {\n        computedRepresentations.set(segmentationId, []);\n    }\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations.includes(type)) {\n        representations.push(type);\n    }\n    subscribeToSegmentationChanges(updateFunction);\n    triggerSegmentationModified(segmentationId);\n    return data;\n}\nfunction subscribeToSegmentationChanges(updateFunction) {\n    const debouncedUpdateFunction = (event) => {\n        _debouncedSegmentationModified(event, updateFunction);\n    };\n    updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;\n    eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n    eventTarget.addEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n}\nconst _debouncedSegmentationModified = debounce((event, updateFunction) => {\n    const segmentationId = event.detail.segmentationId;\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations || !representations.length) {\n        return;\n    }\n    updateFunction(segmentationId);\n    if (representations.length) {\n        triggerSegmentationModified(segmentationId);\n    }\n}, 300);\nexport { computeAndAddRepresentation };\n","import { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { invalidateBrushCursor } from '../../utilities/segmentation/invalidateBrushCursor';\nimport { getSegmentation } from './getSegmentation';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { getActiveSegmentIndex } from './getActiveSegmentIndex';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nfunction setActiveSegmentIndex(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (typeof segmentIndex === 'string') {\n        console.warn('segmentIndex is a string, converting to number');\n        segmentIndex = Number(segmentIndex);\n    }\n    Object.values(segmentation.segments).forEach((segment) => {\n        segment.active = false;\n    });\n    if (!segmentation.segments[segmentIndex]) {\n        segmentation.segments[segmentIndex] = {\n            segmentIndex,\n            label: '',\n            locked: false,\n            cachedStats: {},\n            active: false,\n        };\n    }\n    if (segmentation.segments[segmentIndex].active !== true) {\n        segmentation.segments[segmentIndex].active = true;\n        triggerSegmentationModified(segmentationId);\n    }\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    viewportIds.forEach((viewportId) => {\n        const representations = getSegmentationRepresentations(viewportId, {\n            segmentationId,\n        });\n        representations.forEach((representation) => {\n            if (!representation.segments[segmentIndex]) {\n                representation.segments[segmentIndex] = {\n                    visible: true,\n                };\n            }\n        });\n    });\n    viewportIds.forEach((viewportId) => {\n        const toolGroup = getToolGroupForViewport(viewportId);\n        invalidateBrushCursor(toolGroup.id);\n    });\n}\nexport { setActiveSegmentIndex, getActiveSegmentIndex };\n","import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nfunction isSegmentIndexLocked(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    return segments[segmentIndex].locked;\n}\nfunction setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    segments[segmentIndex].locked = locked;\n    triggerSegmentationModified(segmentationId);\n}\nfunction getLockedSegmentIndices(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    const lockedSegmentIndices = Object.keys(segments).filter((segmentIndex) => segments[segmentIndex].locked);\n    return lockedSegmentIndices.map((segmentIndex) => parseInt(segmentIndex));\n}\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegmentIndices };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getStackSegmentationImageIdsForViewport(viewportId, segmentationId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.updateLabelmapSegmentationImageReferences(viewportId, segmentationId);\n}\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { state } from '../state';\nfunction getToolGroupForViewport(viewportId, renderingEngineId) {\n    if (!renderingEngineId) {\n        renderingEngineId = getRenderingEngines().find((re) => re.getViewports().find((vp) => vp.id === viewportId))?.id;\n    }\n    const toolGroupFilteredByIds = state.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)));\n    if (!toolGroupFilteredByIds.length) {\n        return;\n    }\n    if (toolGroupFilteredByIds.length > 1) {\n        throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`);\n    }\n    return toolGroupFilteredByIds[0];\n}\nexport default getToolGroupForViewport;\n","import { state } from '../state';\nfunction getToolGroup(toolGroupId) {\n    return state.toolGroups.find((s) => s.id === toolGroupId);\n}\nexport default getToolGroup;\n","import { MouseBindings, ToolModes, Events } from '../../enums';\nimport get from 'lodash.get';\nimport { triggerEvent, eventTarget, getRenderingEngine, getRenderingEngines, getEnabledElementByIds, Settings, } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport { state } from '../state';\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\nimport getToolGroup from './getToolGroup';\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\nconst PRIMARY_BINDINGS = [{ mouseButton: MouseBindings.Primary }];\nexport default class ToolGroup {\n    constructor(id) {\n        this.viewportsInfo = [];\n        this.toolOptions = {};\n        this.currentActivePrimaryToolName = null;\n        this.prevActivePrimaryToolName = null;\n        this.restoreToolOptions = {};\n        this._toolInstances = {};\n        this.id = id;\n    }\n    getViewportIds() {\n        return this.viewportsInfo.map(({ viewportId }) => viewportId);\n    }\n    getViewportsInfo() {\n        return this.viewportsInfo.slice();\n    }\n    getToolInstance(toolInstanceName) {\n        const toolInstance = this._toolInstances[toolInstanceName];\n        if (!toolInstance) {\n            console.warn(`'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`);\n            return;\n        }\n        return toolInstance;\n    }\n    getToolInstances() {\n        return this._toolInstances;\n    }\n    hasTool(toolName) {\n        return !!this._toolInstances[toolName];\n    }\n    addTool(toolName, configuration = {}) {\n        const toolDefinition = state.tools[toolName];\n        const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n        const localToolInstance = this.toolOptions[toolName];\n        if (!hasToolName) {\n            console.warn('Tool with configuration did not produce a toolName: ', configuration);\n            return;\n        }\n        if (!toolDefinition) {\n            console.warn(`'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`);\n            return;\n        }\n        if (localToolInstance) {\n            console.warn(`'${toolName}' is already registered for ToolGroup ${this.id}.`);\n            return;\n        }\n        const { toolClass: ToolClass } = toolDefinition;\n        const toolProps = {\n            name: toolName,\n            toolGroupId: this.id,\n            configuration,\n        };\n        const instantiatedTool = new ToolClass(toolProps);\n        this._toolInstances[toolName] = instantiatedTool;\n    }\n    addToolInstance(toolName, parentClassName, configuration = {}) {\n        let ToolClassToUse = state.tools[toolName]\n            ?.toolClass;\n        if (!ToolClassToUse) {\n            const ParentClass = state.tools[parentClassName]\n                .toolClass;\n            class ToolInstance extends ParentClass {\n            }\n            ToolInstance.toolName = toolName;\n            ToolClassToUse = ToolInstance;\n            state.tools[toolName] = {\n                toolClass: ToolInstance,\n            };\n        }\n        this.addTool(ToolClassToUse.toolName, configuration);\n    }\n    addViewport(viewportId, renderingEngineId) {\n        if (typeof viewportId !== 'string') {\n            throw new Error('viewportId must be defined and be a string');\n        }\n        const renderingEngineUIDToUse = this._findRenderingEngine(viewportId, renderingEngineId);\n        if (!this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)) {\n            this.viewportsInfo.push({\n                viewportId,\n                renderingEngineId: renderingEngineUIDToUse,\n            });\n        }\n        const toolName = this.getActivePrimaryMouseButtonTool();\n        const runtimeSettings = Settings.getRuntimeSettings();\n        if (runtimeSettings.get('useCursors')) {\n            this.setViewportsCursorByToolName(toolName);\n        }\n        const eventDetail = {\n            toolGroupId: this.id,\n            viewportId,\n            renderingEngineId: renderingEngineUIDToUse,\n        };\n        triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);\n    }\n    removeViewports(renderingEngineId, viewportId) {\n        const indices = [];\n        this.viewportsInfo.forEach((vpInfo, index) => {\n            let match = false;\n            if (vpInfo.renderingEngineId === renderingEngineId) {\n                match = true;\n                if (viewportId && vpInfo.viewportId !== viewportId) {\n                    match = false;\n                }\n            }\n            if (match) {\n                indices.push(index);\n            }\n        });\n        if (indices.length) {\n            for (let i = indices.length - 1; i >= 0; i--) {\n                this.viewportsInfo.splice(indices[i], 1);\n            }\n        }\n        const eventDetail = {\n            toolGroupId: this.id,\n            viewportId,\n            renderingEngineId,\n        };\n        triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);\n    }\n    setActiveStrategy(toolName, strategyName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool configuration.`);\n            return;\n        }\n        toolInstance.setActiveStrategy(strategyName);\n    }\n    setToolMode(toolName, mode, options = {}) {\n        if (!toolName) {\n            console.warn('setToolMode: toolName must be defined');\n            return;\n        }\n        if (mode === ToolModes.Active) {\n            this.setToolActive(toolName, options || this.restoreToolOptions[toolName]);\n            return;\n        }\n        if (mode === ToolModes.Passive) {\n            this.setToolPassive(toolName);\n            return;\n        }\n        if (mode === ToolModes.Enabled) {\n            this.setToolEnabled(toolName);\n            return;\n        }\n        if (mode === ToolModes.Disabled) {\n            this.setToolDisabled(toolName);\n            return;\n        }\n        console.warn('setToolMode: mode must be defined');\n    }\n    setToolActive(toolName, toolBindingsOptions = {}) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        if (!toolInstance) {\n            console.warn(`'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`);\n            return;\n        }\n        const prevBindings = this.toolOptions[toolName]\n            ? this.toolOptions[toolName].bindings\n            : [];\n        const newBindings = toolBindingsOptions.bindings\n            ? toolBindingsOptions.bindings\n            : [];\n        const bindingsToUse = [...prevBindings, ...newBindings].reduce((unique, binding) => {\n            const TouchBinding = binding.numTouchPoints !== undefined;\n            const MouseBinding = binding.mouseButton !== undefined;\n            if (!unique.some((obj) => hasSameBinding(obj, binding)) &&\n                (TouchBinding || MouseBinding)) {\n                unique.push(binding);\n            }\n            return unique;\n        }, []);\n        const toolOptions = {\n            bindings: bindingsToUse,\n            mode: Active,\n        };\n        this.toolOptions[toolName] = toolOptions;\n        this._toolInstances[toolName].mode = Active;\n        const runtimeSettings = Settings.getRuntimeSettings();\n        const useCursor = runtimeSettings.get('useCursors');\n        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\n            this.setViewportsCursorByToolName(toolName);\n        }\n        else {\n            const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n            if (!activeToolIdentifier && useCursor) {\n                const cursor = MouseCursor.getDefinedCursor('default');\n                this._setCursorForViewports(cursor);\n            }\n        }\n        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {\n            if (this.prevActivePrimaryToolName === null) {\n                this.prevActivePrimaryToolName = toolName;\n            }\n            else {\n                this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;\n            }\n            this.currentActivePrimaryToolName = toolName;\n        }\n        if (typeof toolInstance.onSetToolActive === 'function') {\n            toolInstance.onSetToolActive();\n        }\n        this._renderViewports();\n        const eventDetail = {\n            toolGroupId: this.id,\n            toolName,\n            toolBindingsOptions,\n        };\n        triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\n        this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\n    }\n    setToolPassive(toolName, options) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const prevToolOptions = this.getToolOptions(toolName);\n        const toolOptions = Object.assign({\n            bindings: prevToolOptions ? prevToolOptions.bindings : [],\n        }, prevToolOptions, {\n            mode: Passive,\n        });\n        const matchBindings = Array.isArray(options?.removeAllBindings)\n            ? options.removeAllBindings\n            : this.getDefaultPrimaryBindings();\n        toolOptions.bindings = toolOptions.bindings.filter((binding) => options?.removeAllBindings !== true &&\n            !matchBindings.some((matchBinding) => hasSameBinding(binding, matchBinding)));\n        let mode = Passive;\n        if (toolOptions.bindings.length !== 0) {\n            mode = Active;\n            toolOptions.mode = mode;\n        }\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = mode;\n        if (typeof toolInstance.onSetToolPassive === 'function') {\n            toolInstance.onSetToolPassive();\n        }\n        this._renderViewports();\n        this._triggerToolModeChangedEvent(toolName, Passive);\n    }\n    setToolEnabled(toolName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const toolOptions = {\n            bindings: [],\n            mode: Enabled,\n        };\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = Enabled;\n        if (typeof toolInstance.onSetToolEnabled === 'function') {\n            toolInstance.onSetToolEnabled();\n        }\n        this._renderViewports();\n        this._triggerToolModeChangedEvent(toolName, Enabled);\n    }\n    setToolDisabled(toolName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const toolOptions = {\n            bindings: [],\n            mode: Disabled,\n        };\n        this.restoreToolOptions[toolName] = this.toolOptions[toolName];\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = Disabled;\n        if (typeof toolInstance.onSetToolDisabled === 'function') {\n            toolInstance.onSetToolDisabled();\n        }\n        this._renderViewports();\n        this._triggerToolModeChangedEvent(toolName, Disabled);\n    }\n    getToolOptions(toolName) {\n        const toolOptionsForTool = this.toolOptions[toolName];\n        if (toolOptionsForTool === undefined) {\n            return;\n        }\n        return toolOptionsForTool;\n    }\n    getActivePrimaryMouseButtonTool() {\n        return Object.keys(this.toolOptions).find((toolName) => {\n            const toolOptions = this.toolOptions[toolName];\n            return (toolOptions.mode === Active &&\n                this._hasMousePrimaryButtonBinding(toolOptions));\n        });\n    }\n    setViewportsCursorByToolName(toolName, strategyName) {\n        const cursor = this._getCursor(toolName, strategyName);\n        this._setCursorForViewports(cursor);\n    }\n    _getCursor(toolName, strategyName) {\n        let cursorName;\n        let cursor;\n        if (strategyName) {\n            cursorName = `${toolName}.${strategyName}`;\n            cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n            if (cursor) {\n                return cursor;\n            }\n        }\n        cursorName = `${toolName}`;\n        cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n        if (cursor) {\n            return cursor;\n        }\n        cursorName = toolName;\n        cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n        if (cursor) {\n            return cursor;\n        }\n        return MouseCursor.getDefinedCursor('default');\n    }\n    _setCursorForViewports(cursor) {\n        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            initElementCursor(viewport.element, cursor);\n        });\n    }\n    setToolConfiguration(toolName, configuration, overwrite) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);\n            return false;\n        }\n        let _configuration;\n        if (overwrite) {\n            _configuration = configuration;\n        }\n        else {\n            _configuration = Object.assign(toolInstance.configuration, configuration);\n        }\n        toolInstance.configuration = _configuration;\n        if (typeof toolInstance.onSetToolConfiguration === 'function') {\n            toolInstance.onSetToolConfiguration();\n        }\n        this._renderViewports();\n        return true;\n    }\n    getDefaultMousePrimary() {\n        return MouseBindings.Primary;\n    }\n    getDefaultPrimaryBindings() {\n        return PRIMARY_BINDINGS;\n    }\n    getToolConfiguration(toolName, configurationPath) {\n        if (this._toolInstances[toolName] === undefined) {\n            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);\n            return;\n        }\n        const _configuration = get(this._toolInstances[toolName].configuration, configurationPath) ||\n            this._toolInstances[toolName].configuration;\n        return utilities.deepClone(_configuration);\n    }\n    getPrevActivePrimaryToolName() {\n        return this.prevActivePrimaryToolName;\n    }\n    setActivePrimaryTool(toolName) {\n        const activeToolName = this.getCurrentActivePrimaryToolName();\n        this.setToolDisabled(activeToolName);\n        this.setToolActive(toolName, {\n            bindings: [{ mouseButton: MouseBindings.Primary }],\n        });\n    }\n    getCurrentActivePrimaryToolName() {\n        return this.currentActivePrimaryToolName;\n    }\n    clone(newToolGroupId, fnToolFilter = null) {\n        let toolGroup = getToolGroup(newToolGroupId);\n        if (toolGroup) {\n            console.debug(`ToolGroup ${newToolGroupId} already exists`);\n            return toolGroup;\n        }\n        toolGroup = new ToolGroup(newToolGroupId);\n        state.toolGroups.push(toolGroup);\n        fnToolFilter = fnToolFilter ?? (() => true);\n        Object.keys(this._toolInstances)\n            .filter(fnToolFilter)\n            .forEach((toolName) => {\n            const sourceToolInstance = this._toolInstances[toolName];\n            const sourceToolOptions = this.toolOptions[toolName];\n            const sourceToolMode = sourceToolInstance.mode;\n            toolGroup.addTool(toolName);\n            toolGroup.setToolMode(toolName, sourceToolMode, {\n                bindings: sourceToolOptions.bindings ?? [],\n            });\n        });\n        return toolGroup;\n    }\n    _hasMousePrimaryButtonBinding(toolOptions) {\n        const primaryBindings = this.getDefaultPrimaryBindings();\n        return toolOptions?.bindings?.some((binding) => primaryBindings.some((primary) => hasSameBinding(binding, primary)));\n    }\n    _renderViewports() {\n        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n        });\n    }\n    _triggerToolModeChangedEvent(toolName, mode, toolBindingsOptions) {\n        const eventDetail = {\n            toolGroupId: this.id,\n            toolName,\n            mode,\n            toolBindingsOptions,\n        };\n        triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\n    }\n    _findRenderingEngine(viewportId, renderingEngineId) {\n        const renderingEngines = getRenderingEngines();\n        if (renderingEngines?.length === 0) {\n            throw new Error('No rendering engines found.');\n        }\n        if (renderingEngineId) {\n            return renderingEngineId;\n        }\n        const matchingEngines = renderingEngines.filter((engine) => engine.getViewport(viewportId));\n        if (matchingEngines.length === 0) {\n            if (renderingEngines.length === 1) {\n                return renderingEngines[0].id;\n            }\n            throw new Error('No rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');\n        }\n        if (matchingEngines.length > 1) {\n            throw new Error('Multiple rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');\n        }\n        return matchingEngines[0].id;\n    }\n}\nfunction hasSameBinding(binding1, binding2) {\n    if (binding1.mouseButton !== binding2.mouseButton) {\n        return false;\n    }\n    if (binding1.numTouchPoints !== binding2.numTouchPoints) {\n        return false;\n    }\n    return binding1.modifierKey === binding2.modifierKey;\n}\n","import { state } from '../state';\nfunction getAllToolGroups() {\n    return state.toolGroups;\n}\nexport default getAllToolGroups;\n","import { state } from '../state';\nimport { ToolModes } from '../../enums';\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\nfunction getToolGroupsWithToolName(toolName) {\n    return state.toolGroups.filter(({ toolOptions }) => {\n        const toolGroupToolNames = Object.keys(toolOptions);\n        for (let i = 0; i < toolGroupToolNames.length; i++) {\n            if (toolName !== toolGroupToolNames[i]) {\n                continue;\n            }\n            if (!toolOptions[toolName]) {\n                continue;\n            }\n            if (MODES.includes(toolOptions[toolName].mode)) {\n                return true;\n            }\n        }\n        return false;\n    });\n}\nexport default getToolGroupsWithToolName;\n","import { state } from './state';\nexport function addTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    const toolAlreadyAdded = state.tools[toolName] !== undefined;\n    if (!toolName) {\n        throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\n    }\n    state.tools[toolName] = {\n        toolClass: ToolClass,\n    };\n}\nexport function hasTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    return !!(toolName && state.tools[toolName]);\n}\nexport function hasToolByName(toolName) {\n    return !!(toolName && state.tools[toolName]);\n}\nexport function removeTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    if (!toolName) {\n        throw new Error(`No tool found for: ${ToolClass.name}`);\n    }\n    if (!state.tools[toolName] !== undefined) {\n        delete state.tools[toolName];\n    }\n    else {\n        throw new Error(`${toolName} cannot be removed because it has not been added`);\n    }\n}\nexport default addTool;\n","import svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\nconst defaultState = {\n    isInteractingWithTool: false,\n    isMultiPartToolActive: false,\n    tools: {},\n    toolGroups: [],\n    synchronizers: [],\n    svgNodeCache: svgNodeCache,\n    enabledElements: [],\n    handleRadius: 6,\n};\nlet state = {\n    isInteractingWithTool: false,\n    isMultiPartToolActive: false,\n    tools: {},\n    toolGroups: [],\n    synchronizers: [],\n    svgNodeCache: svgNodeCache,\n    enabledElements: [],\n    handleRadius: 6,\n};\nfunction resetCornerstoneToolsState() {\n    resetSvgNodeCache();\n    state = {\n        ...structuredClone({\n            ...defaultState,\n            svgNodeCache: {},\n        }),\n        svgNodeCache: {\n            ...defaultState.svgNodeCache,\n        },\n    };\n}\nexport { resetCornerstoneToolsState, state, state as default };\n","let svgNodeCache = {};\nexport function resetSvgNodeCache() {\n    svgNodeCache = {};\n}\nexport default svgNodeCache;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nconst { transformWorldToIndex } = csUtils;\nclass BidirectionalTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            let canvasPoint1 = viewport.worldToCanvas(points[0]);\n            let canvasPoint2 = viewport.worldToCanvas(points[1]);\n            let line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            let distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            canvasPoint1 = viewport.worldToCanvas(points[2]);\n            canvasPoint2 = viewport.worldToCanvas(points[3]);\n            line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const data = annotation.data;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            hideElementCursor(element);\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            if (this.editData.handleIndex !== undefined) {\n                const { points } = data.handles;\n                const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n                const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n                if (secondLineSegmentLength > firstLineSegmentLength) {\n                    const longAxis = [[...points[2]], [...points[3]]];\n                    const shortAxisPoint0 = [...points[0]];\n                    const shortAxisPoint1 = [...points[1]];\n                    const longAxisVector = vec2.create();\n                    vec2.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);\n                    const counterClockWisePerpendicularToLongAxis = vec2.create();\n                    vec2.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);\n                    const currentShortAxisVector = vec2.create();\n                    vec2.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);\n                    let shortAxis;\n                    if (vec2.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {\n                        shortAxis = [shortAxisPoint0, shortAxisPoint1];\n                    }\n                    else {\n                        shortAxis = [shortAxisPoint1, shortAxisPoint0];\n                    }\n                    data.handles.points = [\n                        longAxis[0],\n                        longAxis[1],\n                        shortAxis[0],\n                        shortAxis[1],\n                    ];\n                }\n            }\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { worldToCanvas } = viewport;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            data.handles.points[handleIndex] = [...worldPos];\n            const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n            const canvasCoords = {\n                longLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[0][0],\n                        y: canvasCoordPoints[0][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[1][0],\n                        y: canvasCoordPoints[1][1],\n                    },\n                },\n                shortLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[2][0],\n                        y: canvasCoordPoints[2][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[3][0],\n                        y: canvasCoordPoints[3][1],\n                    },\n                },\n            };\n            const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n            const shortAxisDistFromCenter = dist / 3;\n            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n            const length = Math.sqrt(dx * dx + dy * dy);\n            const vectorX = dx / length;\n            const vectorY = dy / length;\n            const xMid = (canvasCoords.longLineSegment.start.x +\n                canvasCoords.longLineSegment.end.x) /\n                2;\n            const yMid = (canvasCoords.longLineSegment.start.y +\n                canvasCoords.longLineSegment.end.y) /\n                2;\n            const startX = xMid + shortAxisDistFromCenter * vectorY;\n            const startY = yMid - shortAxisDistFromCenter * vectorX;\n            const endX = xMid - shortAxisDistFromCenter * vectorY;\n            const endY = yMid + shortAxisDistFromCenter * vectorX;\n            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.editData.hasMoved = true;\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragModifyHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotation, handleIndex: movingHandleIndex } = this.editData;\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            const canvasCoordHandlesCurrent = [\n                viewport.worldToCanvas(data.handles.points[0]),\n                viewport.worldToCanvas(data.handles.points[1]),\n                viewport.worldToCanvas(data.handles.points[2]),\n                viewport.worldToCanvas(data.handles.points[3]),\n            ];\n            const firstLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[0][0],\n                    y: canvasCoordHandlesCurrent[0][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[1][0],\n                    y: canvasCoordHandlesCurrent[1][1],\n                },\n            };\n            const secondLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[2][0],\n                    y: canvasCoordHandlesCurrent[2][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[3][0],\n                    y: canvasCoordHandlesCurrent[3][1],\n                },\n            };\n            const proposedPoint = [...worldPos];\n            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n            if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];\n                const fixedHandleToProposedCoordVec = vec2.set(vec2.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);\n                const fixedHandleToOldCoordVec = vec2.set(vec2.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -\n                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -\n                    fixedHandleCanvasCoord[1]);\n                vec2.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);\n                vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n                const proposedFirstLineSegment = {\n                    start: {\n                        x: fixedHandleCanvasCoord[0],\n                        y: fixedHandleCanvasCoord[1],\n                    },\n                    end: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                };\n                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {\n                    return;\n                }\n                const centerOfRotation = fixedHandleCanvasCoord;\n                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);\n                let firstPointX = canvasCoordHandlesCurrent[2][0];\n                let firstPointY = canvasCoordHandlesCurrent[2][1];\n                let secondPointX = canvasCoordHandlesCurrent[3][0];\n                let secondPointY = canvasCoordHandlesCurrent[3][1];\n                firstPointX -= centerOfRotation[0];\n                firstPointY -= centerOfRotation[1];\n                secondPointX -= centerOfRotation[0];\n                secondPointY -= centerOfRotation[1];\n                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n                firstPointX = rotatedFirstPoint + centerOfRotation[0];\n                firstPointY = rotatedFirstPointY + centerOfRotation[1];\n                secondPointX = rotatedSecondPoint + centerOfRotation[0];\n                secondPointY = rotatedSecondPointY + centerOfRotation[1];\n                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n                const newSecondPoint = viewport.canvasToWorld([\n                    secondPointX,\n                    secondPointY,\n                ]);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n                data.handles.points[2] = newFirstPoint;\n                data.handles.points[3] = newSecondPoint;\n            }\n            else {\n                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n                const canvasCoordsCurrent = {\n                    longLineSegment: {\n                        start: firstLineSegment.start,\n                        end: firstLineSegment.end,\n                    },\n                    shortLineSegment: {\n                        start: secondLineSegment.start,\n                        end: secondLineSegment.end,\n                    },\n                };\n                const longLineSegmentVec = vec2.subtract(vec2.create(), [\n                    canvasCoordsCurrent.longLineSegment.end.x,\n                    canvasCoordsCurrent.longLineSegment.end.y,\n                ], [\n                    canvasCoordsCurrent.longLineSegment.start.x,\n                    canvasCoordsCurrent.longLineSegment.start.y,\n                ]);\n                const longLineSegmentVecNormalized = vec2.normalize(vec2.create(), longLineSegmentVec);\n                const proposedToCurrentVec = vec2.subtract(vec2.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [\n                    canvasCoordHandlesCurrent[movingHandleIndex][0],\n                    canvasCoordHandlesCurrent[movingHandleIndex][1],\n                ]);\n                const movementLength = vec2.length(proposedToCurrentVec);\n                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);\n                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n                const newTranslatedPoint = vec2.scaleAndAdd(vec2.create(), [\n                    canvasCoordHandlesCurrent[translateHandleIndex][0],\n                    canvasCoordHandlesCurrent[translateHandleIndex][1],\n                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);\n                if (this._movingLongAxisWouldPutItThroughShortAxis({\n                    start: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                    end: {\n                        x: newTranslatedPoint[0],\n                        y: newTranslatedPoint[1],\n                    },\n                }, {\n                    start: {\n                        x: canvasCoordsCurrent.longLineSegment.start.x,\n                        y: canvasCoordsCurrent.longLineSegment.start.y,\n                    },\n                    end: {\n                        x: canvasCoordsCurrent.longLineSegment.end.x,\n                        y: canvasCoordsCurrent.longLineSegment.end.y,\n                    },\n                })) {\n                    return;\n                }\n                const intersectionPoint = lineSegment.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n                if (!intersectionPoint) {\n                    return;\n                }\n                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {\n            const vectorInSecondLineDirection = vec2.create();\n            vec2.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);\n            vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n            const extendedSecondLineSegment = {\n                start: {\n                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n                },\n                end: {\n                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n                },\n            };\n            const proposedIntersectionPoint = lineSegment.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n            const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n            return wouldPutThroughShortAxis;\n        };\n        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { element } = enabledElement.viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const worldPos3 = data.handles.points[2];\n            const worldPos4 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, dimensions } = image;\n                const index1 = transformWorldToIndex(imageData, worldPos1);\n                const index2 = transformWorldToIndex(imageData, worldPos2);\n                const index3 = transformWorldToIndex(imageData, worldPos3);\n                const index4 = transformWorldToIndex(imageData, worldPos4);\n                const handles1 = [index1, index2];\n                const handles2 = [index3, index4];\n                const { scale: scale1, unit: units1 } = getCalibratedLengthUnitsAndScale(image, handles1);\n                const { scale: scale2, unit: units2 } = getCalibratedLengthUnitsAndScale(image, handles2);\n                const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\n                const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\n                const length = dist1 > dist2 ? dist1 : dist2;\n                const width = dist1 > dist2 ? dist2 : dist1;\n                const unit = dist1 > dist2 ? units1 : units2;\n                const widthUnit = dist1 > dist2 ? units2 : units1;\n                this._isInsideVolume(index1, index2, index3, index4, dimensions)\n                    ? (this.isHandleOutsideImage = false)\n                    : (this.isHandleOutsideImage = true);\n                cachedStats[targetId] = {\n                    length,\n                    width,\n                    unit,\n                    widthUnit,\n                };\n            }\n            annotation.invalidated = false;\n            triggerAnnotationModified(annotation, element);\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions) &&\n                csUtils.indexWithinDimensions(index3, dimensions) &&\n                csUtils.indexWithinDimensions(index4, dimensions));\n        };\n        this._getSignedAngle = (vector1, vector2) => {\n            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        this.isDrawing = true;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const annotation = {\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.getToolName(),\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...viewport.getViewReference({ points: [worldPos] }),\n            },\n            data: {\n                handles: {\n                    points: [\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                    ],\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n        };\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const { cachedStats, label } = data;\n    const { length, width, unit } = cachedStats[targetId];\n    const textLines = [];\n    if (label) {\n        textLines.push(label);\n    }\n    if (length === undefined) {\n        return textLines;\n    }\n    textLines.push(`L: ${csUtils.roundNumber(length)} ${unit || unit}`, `W: ${csUtils.roundNumber(width)} ${unit}`);\n    return textLines;\n}\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n","import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport PlanarFreehandROITool from './PlanarFreehandROITool';\nclass PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n                allowOpenContours: false,\n            },\n        }, toolProps);\n        super(initialProps);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    renderAnnotationInstance(renderContext) {\n        const annotation = renderContext.annotation;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated) {\n            const { segmentationId } = annotation.data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n        }\n        return renderResult;\n    }\n}\nPlanarFreehandContourSegmentationTool.toolName =\n    'PlanarFreehandContourSegmentationTool';\nexport default PlanarFreehandContourSegmentationTool;\n","import { CONSTANTS, getEnabledElement, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport * as math from '../../utilities/math';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            alwaysRenderOpenContourHandles: {\n                enabled: false,\n                radius: 2,\n            },\n            allowOpenContours: true,\n            closeContourProximity: 10,\n            checkCanvasEditFallbackProximity: 6,\n            makeClockWise: true,\n            subPixelResolution: 4,\n            smoothing: {\n                smoothOnAdd: false,\n                smoothOnEdit: false,\n                knotsRatioPercentageOnAdd: 40,\n                knotsRatioPercentageOnEdit: 40,\n            },\n            interpolation: {\n                enabled: false,\n                onInterpolationComplete: null,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            displayOnePointAsCrosshairs: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isEditingClosed = false;\n        this.isEditingOpen = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const annotation = this.createAnnotation(evt);\n            this.addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateDraw(evt, annotation, viewportIdsToRender);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            if (annotation.data.contour.closed) {\n                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            else {\n                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { polyline: points } = annotation.data.contour;\n            let previousPoint = viewport.worldToCanvas(points[0]);\n            for (let i = 1; i < points.length; i++) {\n                const p1 = previousPoint;\n                const p2 = viewport.worldToCanvas(points[i]);\n                const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n                if (canProject) {\n                    return true;\n                }\n                previousPoint = p2;\n            }\n            if (!annotation.data.contour.closed) {\n                return false;\n            }\n            const pStart = viewport.worldToCanvas(points[0]);\n            const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n            return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n        };\n        this.cancel = (element) => {\n            const isDrawing = this.isDrawing;\n            const isEditingOpen = this.isEditingOpen;\n            const isEditingClosed = this.isEditingClosed;\n            if (isDrawing) {\n                this.cancelDrawing(element);\n            }\n            else if (isEditingOpen) {\n                this.cancelOpenContourEdit(element);\n            }\n            else if (isEditingClosed) {\n                this.cancelClosedContourEdit(element);\n            }\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { cachedStats } = data;\n            const { polyline: points, closed } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const modalityUnitOptions = {\n                    isPreScaled: isViewportPreScaled(viewport, targetId),\n                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                };\n                const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n                const calibratedScale = getCalibratedLengthUnitsAndScale(image, () => {\n                    const polyline = data.contour.polyline;\n                    const numPoints = polyline.length;\n                    const projectedPolyline = new Array(numPoints);\n                    for (let i = 0; i < numPoints; i++) {\n                        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n                    }\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(projectedPolyline);\n                    const topLeftBBWorld = viewport.canvasToWorld([canvasMinX, canvasMinY]);\n                    const topLeftBBIndex = csUtils.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = csUtils.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                if (closed) {\n                    this.updateClosedCachedStats({\n                        targetId,\n                        viewport,\n                        canvasCoordinates,\n                        points,\n                        imageData,\n                        metadata,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                    });\n                }\n                else {\n                    this.updateOpenCachedStats({\n                        metadata,\n                        canvasCoordinates,\n                        targetId,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                    });\n                }\n            }\n            triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.StatsUpdated);\n            annotation.invalidated = false;\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {\n            const { data } = annotation;\n            const targetId = this.getTargetId(viewport);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n            if (!options.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = '1';\n            const boundingBox = drawLinkedTextBox(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        registerDrawLoop(this);\n        registerEditLoopCommon(this);\n        registerClosedContourEditLoop(this);\n        registerOpenContourEditLoop(this);\n        registerOpenContourEndEditLoop(this);\n        registerRenderMethods(this);\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations || !annotations.length) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let annotationsToDisplay;\n        if (viewport instanceof VolumeViewport) {\n            const camera = viewport.getCamera();\n            const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n            annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n        }\n        else {\n            annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n        }\n        return annotationsToDisplay;\n    }\n    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n        const { viewPlaneNormal } = camera;\n        const annotationsWithParallelNormals = annotations.filter((td) => {\n            const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n            const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n                PARALLEL_THRESHOLD;\n            return annotationViewPlaneNormal && isParallel;\n        });\n        if (!annotationsWithParallelNormals.length) {\n            return [];\n        }\n        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n        const { focalPoint } = camera;\n        const annotationsWithinSlice = [];\n        for (const annotation of annotationsWithParallelNormals) {\n            const data = annotation.data;\n            const point = data.contour.polyline[0];\n            if (!annotation.isVisible) {\n                continue;\n            }\n            const dir = vec3.create();\n            vec3.sub(dir, focalPoint, point);\n            const dot = vec3.dot(dir, viewPlaneNormal);\n            if (Math.abs(dot) < halfSpacingInNormalDirection) {\n                annotationsWithinSlice.push(annotation);\n            }\n        }\n        return annotationsWithinSlice;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const worldPos = evt.detail.currentPoints.world;\n        const contourAnnotation = super.createAnnotation(evt);\n        const onInterpolationComplete = (annotation) => {\n            annotation.data.handles.points.length = 0;\n        };\n        const annotation = csUtils.deepMerge(contourAnnotation, {\n            data: {\n                contour: {\n                    polyline: [[...worldPos]],\n                },\n                label: '',\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n        return annotation;\n    }\n    getAnnotationStyle(context) {\n        return super.getAnnotationStyle(context);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        let renderStatus = false;\n        const { viewport, renderingEngine } = enabledElement;\n        const isDrawing = this.isDrawing;\n        const isEditingOpen = this.isEditingOpen;\n        const isEditingClosed = this.isEditingClosed;\n        if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n            if (this.configuration.displayOnePointAsCrosshairs &&\n                annotation.data.contour.polyline.length === 1) {\n                this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n            }\n            else {\n                this.renderContour(enabledElement, svgDrawingHelper, annotation);\n            }\n        }\n        else {\n            const activeAnnotationUID = this.commonData.annotation.annotationUID;\n            if (annotation.annotationUID === activeAnnotationUID) {\n                if (isDrawing) {\n                    this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingClosed) {\n                    this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingOpen) {\n                    this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);\n                }\n            }\n            else {\n                if (this.configuration.displayOnePointAsCrosshairs &&\n                    annotation.data.contour.polyline.length === 1) {\n                    this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    this.renderContour(enabledElement, svgDrawingHelper, annotation);\n                }\n            }\n            renderStatus = true;\n        }\n        if (!this.configuration.calculateStats) {\n            return;\n        }\n        this._calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement);\n        this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n        return renderStatus;\n    }\n    _calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement) {\n        const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n        if (annotation.annotationUID === activeAnnotationUID &&\n            !this.commonData?.movingTextBox) {\n            return;\n        }\n        if (!this.commonData?.movingTextBox) {\n            const { data } = annotation;\n            if (!data.cachedStats[targetId] ||\n                data.cachedStats[targetId].areaUnit == null) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    area: null,\n                    max: null,\n                    mean: null,\n                    stdDev: null,\n                    areaUnit: null,\n                };\n                this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n        }\n    }\n    updateClosedCachedStats({ viewport, points, imageData, metadata, cachedStats, targetId, modalityUnit, canvasCoordinates, calibratedScale, }) {\n        const { scale, areaUnit, units } = calibratedScale;\n        const { voxelManager } = viewport.getImageData();\n        const canvasPoint = canvasCoordinates[0];\n        const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n        const deltaXPoint = viewport.canvasToWorld([\n            canvasPoint[0] + 1,\n            canvasPoint[1],\n        ]);\n        const deltaYPoint = viewport.canvasToWorld([\n            canvasPoint[0],\n            canvasPoint[1] + 1,\n        ]);\n        const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n        const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n        const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        let iMin = worldPosIndex[0];\n        let iMax = worldPosIndex[0];\n        let jMin = worldPosIndex[1];\n        let jMax = worldPosIndex[1];\n        let kMin = worldPosIndex[2];\n        let kMax = worldPosIndex[2];\n        for (let j = 1; j < points.length; j++) {\n            const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[j]);\n            worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n            worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n            worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n            iMin = Math.min(iMin, worldPosIndex[0]);\n            iMax = Math.max(iMax, worldPosIndex[0]);\n            jMin = Math.min(jMin, worldPosIndex[1]);\n            jMax = Math.max(jMax, worldPosIndex[1]);\n            kMin = Math.min(kMin, worldPosIndex[2]);\n            kMax = Math.max(kMax, worldPosIndex[2]);\n        }\n        const worldPosIndex2 = csUtils.transformWorldToIndex(imageData, points[1]);\n        worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\n        worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\n        worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\n        let area = polyline.getArea(canvasCoordinates) / scale / scale;\n        area *= deltaInX * deltaInY;\n        const iDelta = 0.01 * (iMax - iMin);\n        const jDelta = 0.01 * (jMax - jMin);\n        const kDelta = 0.01 * (kMax - kMin);\n        iMin = Math.floor(iMin - iDelta);\n        iMax = Math.ceil(iMax + iDelta);\n        jMin = Math.floor(jMin - jDelta);\n        jMax = Math.ceil(jMax + jDelta);\n        kMin = Math.floor(kMin - kDelta);\n        kMax = Math.ceil(kMax + kDelta);\n        const boundsIJK = [\n            [iMin, iMax],\n            [jMin, jMax],\n            [kMin, kMax],\n        ];\n        const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n        const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n        let curRow = 0;\n        let intersections = [];\n        let intersectionCounter = 0;\n        const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n            imageData,\n            isInObject: (pointLPS, _pointIJK) => {\n                let result = true;\n                const point = viewport.worldToCanvas(pointLPS);\n                if (point[1] != curRow) {\n                    intersectionCounter = 0;\n                    curRow = point[1];\n                    intersections = getLineSegmentIntersectionsCoordinates(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);\n                    intersections.sort((function (index) {\n                        return function (a, b) {\n                            return a[index] === b[index]\n                                ? 0\n                                : a[index] < b[index]\n                                    ? -1\n                                    : 1;\n                        };\n                    })(0));\n                }\n                if (intersections.length && point[0] > intersections[0][0]) {\n                    intersections.shift();\n                    intersectionCounter++;\n                }\n                if (intersectionCounter % 2 === 0) {\n                    result = false;\n                }\n                return result;\n            },\n            boundsIJK,\n            returnPoints: this.configuration.storePointData,\n        });\n        const stats = this.configuration.statsCalculator.getStatistics();\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            area,\n            perimeter: calculatePerimeter(canvasCoordinates, closed) / scale,\n            mean: stats.mean?.value,\n            max: stats.max?.value,\n            stdDev: stats.stdDev?.value,\n            statsArray: stats.array,\n            pointsInShape: pointsInShape,\n            areaUnit,\n            modalityUnit,\n            unit: units,\n        };\n    }\n    updateOpenCachedStats({ targetId, metadata, canvasCoordinates, cachedStats, modalityUnit, calibratedScale, }) {\n        const { scale, units } = calibratedScale;\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            length: calculatePerimeter(canvasCoordinates, false) / scale,\n            modalityUnit,\n            getPixelValueUnitunit: units,\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, length, perimeter, max, isEmptyArea, unit, areaUnit, modalityUnit, } = cachedVolumeStats || {};\n    const textLines = [];\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (mean) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (Number.isFinite(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (stdDev) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    if (perimeter) {\n        textLines.push(`Perimeter: ${csUtils.roundNumber(perimeter)} ${unit}`);\n    }\n    if (length) {\n        textLines.push(`${csUtils.roundNumber(length)} ${unit}`);\n    }\n    return textLines;\n}\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\nexport default PlanarFreehandROITool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawRectByCoordinates as drawRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROITool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { viewPlaneNormal, viewUp } = viewport.getCamera();\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                        boundsIJK,\n                        imageData,\n                        returnPoints: this.configuration.storePointData,\n                    });\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        stdDev: stats.stdDev?.value,\n                        max: stats.max?.value,\n                        statsArray: stats.array,\n                        pointsInShape: pointsInShape,\n                        areaUnit,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            annotation.invalidated = false;\n            triggerAnnotationModified(annotation, element);\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const instance = new this();\n        const referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nRectangleROITool.toolName = 'RectangleROI';\nexport default RectangleROITool;\n","import { utilities, getEnabledElement, StackViewport, cache, VideoViewport, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport BaseTool from './BaseTool';\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nimport { getState } from '../../stateManagement/annotation/config';\nclass AnnotationDisplayTool extends BaseTool {\n    constructor() {\n        super(...arguments);\n        this.onImageSpacingCalibrated = (evt) => {\n            const { element, imageId } = evt.detail;\n            const imageURI = utilities.imageIdToURI(imageId);\n            const annotationManager = getAnnotationManager();\n            const framesOfReference = annotationManager.getFramesOfReference();\n            framesOfReference.forEach((frameOfReference) => {\n                const frameOfReferenceSpecificAnnotations = annotationManager.getAnnotations(frameOfReference);\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[this.getToolName()];\n                if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\n                    return;\n                }\n                toolSpecificAnnotations.forEach((annotation) => {\n                    if (!annotation.metadata?.referencedImageId) {\n                        return;\n                    }\n                    const referencedImageURI = utilities.imageIdToURI(annotation.metadata.referencedImageId);\n                    if (referencedImageURI === imageURI) {\n                        annotation.invalidated = true;\n                        annotation.data.cachedStats = {};\n                    }\n                });\n                triggerAnnotationRender(element);\n            });\n        };\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations || !annotations.length) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        return filterAnnotationsForDisplay(viewport, annotations);\n    }\n    getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp) {\n        const targetId = this.getTargetId(viewport);\n        let referencedImageId = targetId.split(/^[a-zA-Z]+:/)[1];\n        if (viewport instanceof BaseVolumeViewport) {\n            const volumeId = utilities.getVolumeId(targetId);\n            const imageVolume = cache.getVolume(volumeId);\n            referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n        }\n        return referencedImageId;\n    }\n    getStyle(property, specifications, annotation) {\n        return getStyleProperty(property, specifications, getState(annotation), this.mode);\n    }\n}\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\nexport default AnnotationDisplayTool;\n","import { utilities, BaseVolumeViewport } from '@cornerstonejs/core';\nimport ToolModes from '../../enums/ToolModes';\nclass BaseTool {\n    constructor(toolProps, defaultToolProps) {\n        const initialProps = utilities.deepMerge(defaultToolProps, toolProps);\n        const { configuration = {}, supportedInteractionTypes, toolGroupId, } = initialProps;\n        if (!configuration.strategies) {\n            configuration.strategies = {};\n            configuration.defaultStrategy = undefined;\n            configuration.activeStrategy = undefined;\n            configuration.strategyOptions = {};\n        }\n        this.toolGroupId = toolGroupId;\n        this.supportedInteractionTypes = supportedInteractionTypes || [];\n        this.configuration = Object.assign({}, configuration);\n        this.mode = ToolModes.Disabled;\n    }\n    getToolName() {\n        return this.constructor.toolName;\n    }\n    applyActiveStrategy(enabledElement, operationData) {\n        const { strategies, activeStrategy } = this.configuration;\n        return strategies[activeStrategy]?.call(this, enabledElement, operationData);\n    }\n    applyActiveStrategyCallback(enabledElement, operationData, callbackType) {\n        const { strategies, activeStrategy } = this.configuration;\n        if (!strategies[activeStrategy]) {\n            throw new Error(`applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`);\n        }\n        return strategies[activeStrategy][callbackType]?.call(this, enabledElement, operationData);\n    }\n    setConfiguration(newConfiguration) {\n        this.configuration = utilities.deepMerge(this.configuration, newConfiguration);\n    }\n    setActiveStrategy(strategyName) {\n        this.setConfiguration({ activeStrategy: strategyName });\n    }\n    getTargetImageData(targetId) {\n        if (targetId.startsWith('imageId:')) {\n            const imageId = targetId.split('imageId:')[1];\n            const imageURI = utilities.imageIdToURI(imageId);\n            let viewports = utilities.getViewportsWithImageURI(imageURI);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            viewports = viewports.filter((viewport) => {\n                return viewport.getCurrentImageId() === imageId;\n            });\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else if (targetId.startsWith('volumeId:')) {\n            const volumeId = utilities.getVolumeId(targetId);\n            const viewports = utilities.getViewportsWithVolumeId(volumeId);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else if (targetId.startsWith('videoId:')) {\n            const imageURI = utilities.imageIdToURI(targetId);\n            const viewports = utilities.getViewportsWithImageURI(imageURI);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else {\n            throw new Error('getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"');\n        }\n    }\n    getTargetId(viewport) {\n        const targetId = viewport.getViewReferenceId?.();\n        if (targetId) {\n            return targetId;\n        }\n        throw new Error('getTargetId: viewport must have a getViewReferenceId method');\n    }\n}\nBaseTool.toolName = 'BaseTool';\nexport default BaseTool;\n","import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport { handleContourSegmentation } from './contourHandler/handleContourSegmentation';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { canComputeRequestedRepresentation } from '../../../stateManagement/segmentation/polySeg/canComputeRequestedRepresentation';\nimport { computeAndAddContourRepresentation } from '../../../stateManagement/segmentation/polySeg/Contour/computeAndAddContourRepresentation';\nimport removeContourFromElement from './removeContourFromElement';\nlet polySegConversionInProgress = false;\nconst processedViewportSegmentations = new Map();\nfunction removeRepresentation(viewportId, segmentationId, renderImmediate = false) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    if (!renderImmediate) {\n        return;\n    }\n    removeContourFromElement(viewportId, segmentationId);\n    viewport.render();\n}\nasync function render(viewport, contourRepresentation) {\n    const { segmentationId } = contourRepresentation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    let contourData = segmentation.representationData[Representations.Contour];\n    if (!contourData &&\n        canComputeRequestedRepresentation(segmentationId, Representations.Contour) &&\n        !polySegConversionInProgress) {\n        polySegConversionInProgress = true;\n        contourData = await computeAndAddContourRepresentation(segmentationId, {\n            viewport,\n        });\n        polySegConversionInProgress = false;\n    }\n    if (!contourData) {\n        return;\n    }\n    if (!contourData.geometryIds?.length) {\n        return;\n    }\n    handleContourSegmentation(viewport, contourData.geometryIds, contourData.annotationUIDsMap, contourRepresentation);\n}\nexport default {\n    render,\n    removeRepresentation,\n};\n","import { getEnabledElementByViewportId, VolumeViewport, } from '@cornerstonejs/core';\nimport addLabelmapToElement from './addLabelmapToElement';\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\nimport { getActiveSegmentation } from '../../../stateManagement/segmentation/activeSegmentation';\nimport { getColorLUT } from '../../../stateManagement/segmentation/getColorLUT';\nimport { getCurrentLabelmapImageIdForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { canComputeRequestedRepresentation } from '../../../stateManagement/segmentation/polySeg/canComputeRequestedRepresentation';\nimport { computeAndAddLabelmapRepresentation } from '../../../stateManagement/segmentation/polySeg/Labelmap/computeAndAddLabelmapRepresentation';\nimport { segmentationStyle } from '../../../stateManagement/segmentation/SegmentationStyle';\nimport SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport { internalGetHiddenSegmentIndices } from '../../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nimport { getActiveSegmentIndex } from '../../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getLabelmapActorEntry } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nconst MAX_NUMBER_COLORS = 255;\nconst labelMapConfigCache = new Map();\nlet polySegConversionInProgress = false;\nfunction removeRepresentation(viewportId, segmentationId, renderImmediate = false) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    labelMapConfigCache.forEach((value, key) => {\n        if (key.includes(segmentationId)) {\n            labelMapConfigCache.delete(key);\n        }\n    });\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    removeLabelmapFromElement(viewport.element, segmentationId);\n    if (!renderImmediate) {\n        return;\n    }\n    viewport.render();\n}\nasync function render(viewport, representation) {\n    const { segmentationId } = representation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn('No segmentation found for segmentationId: ', segmentationId);\n        return;\n    }\n    let labelmapData = segmentation.representationData[SegmentationRepresentations.Labelmap];\n    let labelmapActorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n    if (!labelmapData &&\n        canComputeRequestedRepresentation(segmentationId, SegmentationRepresentations.Labelmap) &&\n        !polySegConversionInProgress) {\n        polySegConversionInProgress = true;\n        labelmapData = await computeAndAddLabelmapRepresentation(segmentationId, {\n            viewport,\n        });\n        if (!labelmapData) {\n            throw new Error(`No labelmap data found for segmentationId ${segmentationId}.`);\n        }\n        polySegConversionInProgress = false;\n    }\n    if (!labelmapData) {\n        return;\n    }\n    if (viewport instanceof VolumeViewport) {\n        if (!labelmapActorEntry) {\n            await _addLabelmapToViewport(viewport, labelmapData, segmentationId);\n        }\n        labelmapActorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n    }\n    else {\n        const labelmapImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n        if (!labelmapImageId) {\n            return;\n        }\n        if (!labelmapActorEntry) {\n            await _addLabelmapToViewport(viewport, labelmapData, segmentationId);\n        }\n        labelmapActorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n    }\n    if (!labelmapActorEntry) {\n        return;\n    }\n    _setLabelmapColorAndOpacity(viewport.id, labelmapActorEntry, representation);\n}\nfunction _setLabelmapColorAndOpacity(viewportId, labelmapActorEntry, segmentationRepresentation) {\n    const { segmentationId } = segmentationRepresentation;\n    const { cfun, ofun } = segmentationRepresentation.config;\n    const { colorLUTIndex } = segmentationRepresentation;\n    const activeSegmentation = getActiveSegmentation(viewportId);\n    const isActiveLabelmap = activeSegmentation?.segmentationId === segmentationId;\n    const labelmapStyle = segmentationStyle.getStyle({\n        viewportId,\n        type: SegmentationRepresentations.Labelmap,\n        segmentationId,\n    });\n    const renderInactiveSegmentations = segmentationStyle.getRenderInactiveSegmentations(viewportId);\n    const colorLUT = getColorLUT(colorLUTIndex);\n    const numColors = Math.min(256, colorLUT.length);\n    const { outlineWidth, renderOutline, outlineOpacity, activeSegmentOutlineWidthDelta, } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap);\n    const segmentsHidden = internalGetHiddenSegmentIndices(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Labelmap,\n    });\n    for (let i = 0; i < numColors; i++) {\n        const segmentIndex = i;\n        const segmentColor = colorLUT[segmentIndex];\n        const perSegmentStyle = segmentationStyle.getStyle({\n            viewportId,\n            type: SegmentationRepresentations.Labelmap,\n            segmentationId,\n            segmentIndex,\n        });\n        const segmentSpecificLabelmapConfig = perSegmentStyle;\n        const { fillAlpha, outlineWidth, renderFill, renderOutline } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap, segmentSpecificLabelmapConfig);\n        const { forceOpacityUpdate, forceColorUpdate } = _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            segmentColor,\n            outlineWidth,\n            segmentsHidden: segmentsHidden,\n            cfun,\n            ofun,\n        });\n        if (forceColorUpdate) {\n            cfun.addRGBPoint(segmentIndex, segmentColor[0] / MAX_NUMBER_COLORS, segmentColor[1] / MAX_NUMBER_COLORS, segmentColor[2] / MAX_NUMBER_COLORS);\n        }\n        if (forceOpacityUpdate) {\n            if (renderFill) {\n                const segmentOpacity = segmentsHidden.has(segmentIndex)\n                    ? 0\n                    : (segmentColor[3] / 255) * fillAlpha;\n                ofun.removePoint(segmentIndex);\n                ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\n            }\n            else {\n                ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\n            }\n        }\n    }\n    const labelmapActor = labelmapActorEntry.actor;\n    labelmapActor.getProperty().setRGBTransferFunction(0, cfun);\n    ofun.setClamping(false);\n    labelmapActor.getProperty().setScalarOpacity(0, ofun);\n    labelmapActor.getProperty().setInterpolationTypeToNearest();\n    if (renderOutline) {\n        labelmapActor.getProperty().setUseLabelOutline(renderOutline);\n        labelmapActor.getProperty().setLabelOutlineOpacity(outlineOpacity);\n        const activeSegmentIndex = getActiveSegmentIndex(segmentationRepresentation.segmentationId);\n        const outlineWidths = new Array(numColors - 1);\n        for (let i = 1; i < numColors; i++) {\n            const isHidden = segmentsHidden.has(i);\n            if (isHidden) {\n                outlineWidths[i - 1] = 0;\n                continue;\n            }\n            outlineWidths[i - 1] =\n                i === activeSegmentIndex\n                    ? outlineWidth + activeSegmentOutlineWidthDelta\n                    : outlineWidth;\n        }\n        labelmapActor.getProperty().setLabelOutlineThickness(outlineWidths);\n    }\n    else {\n        labelmapActor\n            .getProperty()\n            .setLabelOutlineThickness(new Array(numColors - 1).fill(0));\n    }\n    const visible = isActiveLabelmap || renderInactiveSegmentations;\n    labelmapActor.setVisibility(visible);\n}\nfunction _getLabelmapConfig(labelmapConfig, isActiveLabelmap, segmentsLabelmapConfig) {\n    const segmentLabelmapConfig = segmentsLabelmapConfig || {};\n    const configToUse = {\n        ...labelmapConfig,\n        ...segmentLabelmapConfig,\n    };\n    const fillAlpha = isActiveLabelmap\n        ? configToUse.fillAlpha\n        : configToUse.fillAlphaInactive;\n    const outlineWidth = isActiveLabelmap\n        ? configToUse.outlineWidth\n        : configToUse.outlineWidthInactive;\n    const renderFill = isActiveLabelmap\n        ? configToUse.renderFill\n        : configToUse.renderFillInactive;\n    const renderOutline = isActiveLabelmap\n        ? configToUse.renderOutline\n        : configToUse.renderOutlineInactive;\n    const outlineOpacity = isActiveLabelmap\n        ? configToUse.outlineOpacity\n        : configToUse.outlineOpacityInactive;\n    const activeSegmentOutlineWidthDelta = configToUse.activeSegmentOutlineWidthDelta;\n    return {\n        fillAlpha,\n        outlineWidth,\n        renderFill,\n        renderOutline,\n        outlineOpacity,\n        activeSegmentOutlineWidthDelta,\n    };\n}\nfunction _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, { fillAlpha, renderFill, renderOutline, segmentColor, outlineWidth, segmentsHidden, cfun, ofun, }) {\n    const cacheUID = `${viewportId}-${segmentationId}-${segmentIndex}`;\n    const oldConfig = labelMapConfigCache.get(cacheUID);\n    if (!oldConfig) {\n        labelMapConfigCache.set(cacheUID, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            outlineWidth,\n            segmentColor: segmentColor.slice(),\n            segmentsHidden: new Set(segmentsHidden),\n            cfunMTime: cfun.getMTime(),\n            ofunMTime: ofun.getMTime(),\n        });\n        return {\n            forceOpacityUpdate: true,\n            forceColorUpdate: true,\n        };\n    }\n    const { fillAlpha: oldFillAlpha, renderFill: oldRenderFill, renderOutline: oldRenderOutline, outlineWidth: oldOutlineWidth, segmentColor: oldSegmentColor, segmentsHidden: oldSegmentsHidden, cfunMTime: oldCfunMTime, ofunMTime: oldOfunMTime, } = oldConfig;\n    const forceColorUpdate = oldSegmentColor[0] !== segmentColor[0] ||\n        oldSegmentColor[1] !== segmentColor[1] ||\n        oldSegmentColor[2] !== segmentColor[2];\n    const forceOpacityUpdate = oldSegmentColor[3] !== segmentColor[3] ||\n        oldFillAlpha !== fillAlpha ||\n        oldRenderFill !== renderFill ||\n        oldRenderOutline !== renderOutline ||\n        oldOutlineWidth !== outlineWidth ||\n        oldSegmentsHidden !== segmentsHidden;\n    if (forceOpacityUpdate || forceColorUpdate) {\n        labelMapConfigCache.set(cacheUID, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            outlineWidth,\n            segmentColor: segmentColor.slice(),\n            segmentsHidden: new Set(segmentsHidden),\n            cfunMTime: cfun.getMTime(),\n            ofunMTime: ofun.getMTime(),\n        });\n    }\n    return {\n        forceOpacityUpdate,\n        forceColorUpdate,\n    };\n}\nasync function _addLabelmapToViewport(viewport, labelmapData, segmentationId) {\n    await addLabelmapToElement(viewport.element, labelmapData, segmentationId);\n}\nexport default {\n    render,\n    removeRepresentation,\n};\nexport { render, removeRepresentation };\n","import { cache, getEnabledElementByViewportId, Enums, } from '@cornerstonejs/core';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport removeSurfaceFromElement from './removeSurfaceFromElement';\nimport addOrUpdateSurfaceToElement from './addOrUpdateSurfaceToElement';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { getColorLUT } from '../../../stateManagement/segmentation/getColorLUT';\nimport { canComputeRequestedRepresentation } from '../../../stateManagement/segmentation/polySeg/canComputeRequestedRepresentation';\nimport { computeAndAddSurfaceRepresentation } from '../../../stateManagement/segmentation/polySeg/Surface/computeAndAddSurfaceRepresentation';\nconst { ViewportType } = Enums;\nfunction removeRepresentation(viewportId, segmentationId, renderImmediate = false) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    removeSurfaceFromElement(viewport.element, segmentationId);\n    if (!renderImmediate) {\n        return;\n    }\n    viewport.render();\n}\nasync function render(viewport, representation) {\n    const { segmentationId } = representation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    let SurfaceData = segmentation.representationData[Representations.Surface];\n    if (!SurfaceData &&\n        canComputeRequestedRepresentation(segmentationId, Representations.Surface)) {\n        SurfaceData = await computeAndAddSurfaceRepresentation(segmentationId, {\n            viewport,\n        });\n        if (!SurfaceData) {\n            throw new Error(`No Surface data found for segmentationId ${segmentationId}.`);\n        }\n    }\n    const { geometryIds } = SurfaceData;\n    if (!geometryIds?.size) {\n        console.warn(`No Surfaces found for segmentationId ${segmentationId}. Skipping render.`);\n    }\n    const { colorLUTIndex } = representation;\n    const colorLUT = getColorLUT(colorLUTIndex);\n    const surfaces = [];\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry?.data) {\n            console.warn(`No Surfaces found for geometryId ${geometryId}. Skipping render.`);\n            return;\n        }\n        const segmentIndex = geometry.data.segmentIndex;\n        const surface = geometry.data;\n        const color = colorLUT[segmentIndex];\n        surface.color = color.slice(0, 3);\n        surfaces.push(surface);\n        addOrUpdateSurfaceToElement(viewport.element, surface, segmentationId);\n    });\n    viewport.render();\n}\nexport default {\n    render,\n    removeRepresentation,\n};\nexport { render, removeRepresentation };\n","import { utilities as csUtils, cache, getEnabledElement, StackViewport, eventTarget, Enums, BaseVolumeViewport, volumeLoader, } from '@cornerstonejs/core';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { BaseTool } from '../base';\nimport { fillInsideSphere, thresholdInsideSphere, } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { thresholdInsideCircle, fillInsideCircle, } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events, ToolModes, SegmentationRepresentations, StrategyCallbacks, } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, getStackSegmentationImageIdsForViewport, } from '../../stateManagement/segmentation/segmentationState';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nclass BrushTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE_CIRCLE: fillInsideCircle,\n                ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n                FILL_INSIDE_SPHERE: fillInsideSphere,\n                ERASE_INSIDE_SPHERE: eraseInsideSphere,\n                THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n                THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n            },\n            strategySpecificConfiguration: {\n                THRESHOLD: {\n                    threshold: [-150, -70],\n                },\n            },\n            defaultStrategy: 'FILL_INSIDE_CIRCLE',\n            activeStrategy: 'FILL_INSIDE_CIRCLE',\n            thresholdVolumeId: null,\n            brushSize: 25,\n            preview: {\n                enabled: false,\n                previewColors: {},\n                previewTimeMs: 250,\n                previewMoveDistance: 8,\n                dragMoveDistance: 4,\n                dragTimeMs: 500,\n            },\n            actions: {\n                [StrategyCallbacks.AcceptPreview]: {\n                    method: StrategyCallbacks.AcceptPreview,\n                    bindings: [\n                        {\n                            key: 'Enter',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.RejectPreview]: {\n                    method: StrategyCallbacks.RejectPreview,\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._previewData = {\n            preview: null,\n            element: null,\n            timerStart: 0,\n            timer: null,\n            startPoint: [NaN, NaN],\n            isDrag: false,\n        };\n        this.onSetToolPassive = (evt) => {\n            this.disableCursor();\n        };\n        this.onSetToolEnabled = () => {\n            this.disableCursor();\n        };\n        this.onSetToolDisabled = (evt) => {\n            this.disableCursor();\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            this._editData = this.createEditData(element);\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            this._previewData.isDrag = false;\n            this._previewData.timerStart = Date.now();\n            const hoverData = this._hoverData || this.createHoverData(element);\n            triggerAnnotationRenderForViewportUIDs(hoverData.viewportIdsToRender);\n            const operationData = this.getOperationData(element);\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionStart);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.updateCursor(evt);\n                if (!this.configuration.preview.enabled) {\n                    return;\n                }\n                const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;\n                const { currentPoints, element } = evt.detail;\n                const { canvas } = currentPoints;\n                const { preview, startPoint, timer, timerStart, isDrag } = this._previewData;\n                const delta = vec2.distance(canvas, startPoint);\n                const time = Date.now() - timerStart;\n                if (delta > previewMoveDistance ||\n                    (time > previewTimeMs && delta > dragMoveDistance)) {\n                    if (timer) {\n                        window.clearTimeout(timer);\n                        this._previewData.timer = null;\n                    }\n                    if (preview && !isDrag) {\n                        this.rejectPreview(element);\n                    }\n                }\n                if (!this._previewData.timer) {\n                    const timer = window.setTimeout(this.previewCallback, 250);\n                    Object.assign(this._previewData, {\n                        timerStart: Date.now(),\n                        timer,\n                        startPoint: canvas,\n                        element,\n                    });\n                }\n            }\n        };\n        this.previewCallback = () => {\n            this._previewData.timer = null;\n            if (this._previewData.preview) {\n                return;\n            }\n            this._previewData.preview = this.applyActiveStrategyCallback(getEnabledElement(this._previewData.element), this.getOperationData(this._previewData.element), StrategyCallbacks.Preview);\n        };\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const enabledElement = getEnabledElement(element);\n            this.updateCursor(evt);\n            const { viewportIdsToRender } = this._hoverData;\n            triggerAnnotationRenderForViewportUIDs(viewportIdsToRender);\n            const delta = vec2.distance(currentPoints.canvas, this._previewData.startPoint);\n            const { dragTimeMs, dragMoveDistance } = this.configuration.preview;\n            if (!this._previewData.isDrag &&\n                this._previewData.preview &&\n                Date.now() - this._previewData.timerStart < dragTimeMs &&\n                delta < dragMoveDistance) {\n                return;\n            }\n            this._previewData.preview = this.applyActiveStrategy(enabledElement, this.getOperationData(element));\n            this._previewData.element = element;\n            this._previewData.timerStart = Date.now() + dragTimeMs;\n            this._previewData.isDrag = true;\n            this._previewData.startPoint = currentPoints.canvas;\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const operationData = this.getOperationData(element);\n            if (!this._previewData.preview && !this._previewData.isDrag) {\n                this.applyActiveStrategy(enabledElement, operationData);\n            }\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.updateCursor(evt);\n            this._editData = null;\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionEnd);\n            if (!this._previewData.isDrag) {\n                this.acceptPreview(element);\n            }\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    disableCursor() {\n        this._hoverData = undefined;\n        this.rejectPreview();\n    }\n    createEditData(element) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                detail: {\n                    type: 'Segmentation',\n                    message: 'No active segmentation detected, create a segmentation representation before using the brush tool',\n                },\n                cancelable: true,\n            });\n            eventTarget.dispatchEvent(event);\n            return null;\n        }\n        const { segmentationId } = activeSegmentation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const { representationData } = getSegmentation(segmentationId);\n        if (viewport instanceof BaseVolumeViewport) {\n            const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n            const actors = viewport.getActors();\n            const isStackViewport = viewport instanceof StackViewport;\n            if (isStackViewport) {\n                const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                    detail: {\n                        type: 'Segmentation',\n                        message: 'Cannot perform brush operation on the selected viewport',\n                    },\n                    cancelable: true,\n                });\n                eventTarget.dispatchEvent(event);\n                return null;\n            }\n            const volumes = actors.map((actorEntry) => cache.getVolume(actorEntry.referencedId));\n            const segmentationVolume = cache.getVolume(volumeId);\n            const referencedVolumeIdToThreshold = volumes.find((volume) => csUtils.isEqual(volume.dimensions, segmentationVolume.dimensions))?.volumeId || volumes[0]?.volumeId;\n            return {\n                volumeId,\n                referencedVolumeId: this.configuration.thresholdVolumeId ?? referencedVolumeIdToThreshold,\n                segmentsLocked,\n            };\n        }\n        else {\n            const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n            if (!segmentationImageId) {\n                return;\n            }\n            if (this.configuration.activeStrategy.includes('SPHERE')) {\n                const referencedImageIds = viewport.getImageIds();\n                const isValidVolumeForSphere = csUtils.isValidVolume(referencedImageIds);\n                if (!isValidVolumeForSphere) {\n                    throw new Error('Volume is not reconstructable for sphere manipulation');\n                }\n                const volumeId = `${segmentationId}_${viewport.id}`;\n                const volume = cache.getVolume(volumeId);\n                if (volume) {\n                    return {\n                        imageId: segmentationImageId,\n                        segmentsLocked,\n                        override: {\n                            voxelManager: volume.voxelManager,\n                            imageData: volume.imageData,\n                        },\n                    };\n                }\n                else {\n                    const labelmapImageIds = getStackSegmentationImageIdsForViewport(viewport.id, segmentationId);\n                    if (!labelmapImageIds || labelmapImageIds.length === 1) {\n                        return {\n                            imageId: segmentationImageId,\n                            segmentsLocked,\n                        };\n                    }\n                    const volume = volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, labelmapImageIds);\n                    return {\n                        imageId: segmentationImageId,\n                        segmentsLocked,\n                        override: {\n                            voxelManager: volume.voxelManager,\n                            imageData: volume.imageData,\n                        },\n                    };\n                }\n            }\n            else {\n                return {\n                    imageId: segmentationImageId,\n                    segmentsLocked,\n                };\n            }\n        }\n    }\n    createHoverData(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const viewportIdsToRender = [viewport.id];\n        const { segmentIndex, segmentationId, segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        const brushCursor = {\n            metadata: {\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                referencedImageId: '',\n                toolName: this.getToolName(),\n                segmentColor,\n            },\n            data: {},\n        };\n        return {\n            brushCursor,\n            centerCanvas,\n            segmentIndex,\n            viewport,\n            segmentationId,\n            segmentColor,\n            viewportIdsToRender,\n        };\n    }\n    getActiveSegmentationData(viewport) {\n        const viewportId = viewport.id;\n        const activeRepresentation = getActiveSegmentation(viewportId);\n        if (!activeRepresentation) {\n            return;\n        }\n        const { segmentationId } = activeRepresentation;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        if (!segmentIndex) {\n            return;\n        }\n        const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n        return {\n            segmentIndex,\n            segmentationId,\n            segmentColor,\n        };\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const { element } = eventData;\n        const { currentPoints } = eventData;\n        const centerCanvas = currentPoints.canvas;\n        this._hoverData = this.createHoverData(element, centerCanvas);\n        this._calculateCursor(element, centerCanvas);\n        if (!this._hoverData) {\n            return;\n        }\n        triggerAnnotationRenderForViewportUIDs(this._hoverData.viewportIdsToRender);\n    }\n    getOperationData(element) {\n        const editData = this._editData || this.createEditData(element);\n        const { segmentIndex, segmentationId, brushCursor } = this._hoverData || this.createHoverData(element);\n        const { data, metadata = {} } = brushCursor || {};\n        const { viewPlaneNormal, viewUp } = metadata;\n        const operationData = {\n            ...editData,\n            points: data?.handles?.points,\n            segmentIndex,\n            previewColors: this.configuration.preview.enabled\n                ? this.configuration.preview.previewColors\n                : null,\n            viewPlaneNormal,\n            toolGroupId: this.toolGroupId,\n            segmentationId,\n            viewUp,\n            strategySpecificConfiguration: this.configuration.strategySpecificConfiguration,\n            preview: this._previewData?.preview,\n        };\n        return operationData;\n    }\n    _calculateCursor(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvasToWorld } = viewport;\n        const camera = viewport.getCamera();\n        const { brushSize } = this.configuration;\n        const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n        const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, viewUp, viewPlaneNormal);\n        const centerCursorInWorld = canvasToWorld([\n            centerCanvas[0],\n            centerCanvas[1],\n        ]);\n        const bottomCursorInWorld = vec3.create();\n        const topCursorInWorld = vec3.create();\n        const leftCursorInWorld = vec3.create();\n        const rightCursorInWorld = vec3.create();\n        for (let i = 0; i <= 2; i++) {\n            bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n            topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n            leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n            rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n        }\n        if (!this._hoverData) {\n            return;\n        }\n        const { brushCursor } = this._hoverData;\n        const { data } = brushCursor;\n        if (data.handles === undefined) {\n            data.handles = {};\n        }\n        data.handles.points = [\n            bottomCursorInWorld,\n            topCursorInWorld,\n            leftCursorInWorld,\n            rightCursorInWorld,\n        ];\n        const activeStrategy = this.configuration.activeStrategy;\n        const strategy = this.configuration.strategies[activeStrategy];\n        if (typeof strategy.computeInnerCircleRadius === 'function') {\n            strategy.computeInnerCircleRadius({\n                configuration: this.configuration,\n                viewport,\n            });\n        }\n        data.invalidated = false;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element || !this._previewData.preview) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.AcceptPreview);\n        this._previewData.isDrag = false;\n        this._previewData.preview = null;\n    }\n    invalidateBrushCursor() {\n        if (this._hoverData === undefined) {\n            return;\n        }\n        const { data } = this._hoverData.brushCursor;\n        const { viewport } = this._hoverData;\n        data.invalidated = true;\n        const { segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        this._hoverData.brushCursor.metadata.segmentColor = segmentColor;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this._hoverData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n        if (!viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const brushCursor = this._hoverData.brushCursor;\n        if (brushCursor.data.invalidated === true) {\n            const { centerCanvas } = this._hoverData;\n            const { element } = viewport;\n            this._calculateCursor(element, centerCanvas);\n        }\n        const toolMetadata = brushCursor.metadata;\n        if (!toolMetadata) {\n            return;\n        }\n        const annotationUID = toolMetadata.brushCursorUID;\n        const data = brushCursor.data;\n        const { points } = data.handles;\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const bottom = canvasCoordinates[0];\n        const top = canvasCoordinates[1];\n        const center = [\n            Math.floor((bottom[0] + top[0]) / 2),\n            Math.floor((bottom[1] + top[1]) / 2),\n        ];\n        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n        const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return;\n        }\n        const circleUID = '0';\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n            color,\n        });\n        const activeStrategy = this.configuration.activeStrategy;\n        const { dynamicRadiusInCanvas } = this.configuration\n            .strategySpecificConfiguration[activeStrategy] || {\n            dynamicRadiusInCanvas: 0,\n        };\n        if (dynamicRadiusInCanvas) {\n            const circleUID1 = '1';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {\n                color,\n            });\n        }\n    }\n}\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import { getEnabledElement, cache, StackViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawHandles as drawHandlesSvg, drawRect as drawRectSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor, resetElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            storePointData: false,\n            numSlicesToPropagate: 10,\n            computePointsInsideVolume: false,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            showTextBox: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            let referencedImageId, imageVolume, volumeId;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Stack Viewport Not implemented');\n            }\n            else {\n                const targetId = this.getTargetId(viewport);\n                volumeId = csUtils.getVolumeId(targetId);\n                imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const spacingInNormal = csUtils.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n            const startCoord = this._getStartCoordinate(worldPos, viewPlaneNormal);\n            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    enabledElement,\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                    volumeId,\n                    spacingInNormal,\n                },\n                data: {\n                    label: '',\n                    startCoordinate: startCoord,\n                    endCoordinate: endCoord,\n                    cachedStats: {\n                        pointsInVolume: [],\n                        projectionPoints: [],\n                        projectionPointsImageIds: [referencedImageId],\n                        statistics: [],\n                    },\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    labelmapUID: null,\n                },\n            };\n            this._computeProjectionPoints(annotation, imageVolume);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const targetId = this.getTargetId(enabledElement.viewport);\n            const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n            if (this.configuration.calculatePointsInsideVolume) {\n                this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            let annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = filterAnnotationsWithinSamePlane(annotations, viewport.getCamera());\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { startCoordinate, endCoordinate } = data;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const focalPoint = viewport.getCamera().focalPoint;\n                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n                let startCoord = startCoordinate;\n                let endCoord = endCoordinate;\n                if (Array.isArray(startCoordinate)) {\n                    startCoord = this._getCoordinateForViewplaneNormal(startCoord, viewplaneNormal);\n                    data.startCoordinate = startCoord;\n                    data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = startCoord;\n                    data.startCoordinate = startCoord;\n                    data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = startCoord;\n                }\n                if (Array.isArray(endCoordinate)) {\n                    endCoord = this._getCoordinateForViewplaneNormal(endCoord, viewplaneNormal);\n                    data.endCoordinate = endCoord;\n                    data.endCoordinate = endCoord;\n                }\n                const roundedStartCoord = csUtils.roundToPrecision(startCoord);\n                const roundedEndCoord = csUtils.roundToPrecision(endCoord);\n                const coord = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);\n                const roundedCoord = csUtils.roundToPrecision(coord);\n                if (roundedCoord < Math.min(roundedStartCoord, roundedEndCoord) ||\n                    roundedCoord > Math.max(roundedStartCoord, roundedEndCoord)) {\n                    continue;\n                }\n                if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, enabledElement);\n                }\n                let firstOrLastSlice = false;\n                if (roundedCoord === roundedStartCoord ||\n                    roundedCoord === roundedEndCoord) {\n                    firstOrLastSlice = true;\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    firstOrLastSlice) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                let lineDashToUse = lineDash;\n                if (!firstOrLastSlice) {\n                    lineDashToUse = 2;\n                }\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash: lineDashToUse,\n                    lineWidth,\n                });\n                renderStatus = true;\n                if (this.configuration.showTextBox &&\n                    this.configuration.calculatePointsInsideVolume) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data);\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    if (!data.handles.textBox.hasMoved) {\n                        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStatsTool, 100, { trailing: true });\n    }\n    _computeProjectionPoints(annotation, imageVolume) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, spacingInNormal } = metadata;\n        const { imageData } = imageVolume;\n        const { startCoordinate, endCoordinate } = data;\n        const { points } = data.handles;\n        const startIJK = transformWorldToIndex(imageData, points[0]);\n        const endIJK = transformWorldToIndex(imageData, points[0]);\n        const startWorld = vec3.create();\n        imageData.indexToWorldVec3(startIJK, startWorld);\n        const endWorld = vec3.create();\n        imageData.indexToWorldVec3(endIJK, endWorld);\n        if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 2) {\n            startWorld[2] = startCoordinate;\n            endWorld[2] = endCoordinate;\n        }\n        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 0) {\n            startWorld[0] = startCoordinate;\n            endWorld[0] = endCoordinate;\n        }\n        else if (this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) == 1) {\n            startWorld[1] = startCoordinate;\n            endWorld[1] = endCoordinate;\n        }\n        const distance = vec3.distance(startWorld, endWorld);\n        const newProjectionPoints = [];\n        for (let dist = 0; dist < distance; dist += spacingInNormal) {\n            newProjectionPoints.push(points.map((point) => {\n                const newPoint = vec3.create();\n                vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n                return Array.from(newPoint);\n            }));\n        }\n        data.cachedStats.projectionPoints = newProjectionPoints;\n    }\n    _computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, viewUp } = metadata;\n        const { viewport } = enabledElement;\n        const projectionPoints = data.cachedStats.projectionPoints;\n        const pointsInsideVolume = [[]];\n        const image = this.getTargetImageData(targetId);\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[3];\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n        const measureInfo = getCalibratedLengthUnitsAndScale(image, data.habdles);\n        const area = Math.abs(worldWidth * worldHeight) /\n            (measureInfo.scale * measureInfo.scale);\n        const modalityUnitOptions = {\n            isPreScaled: isViewportPreScaled(viewport, targetId),\n            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n        };\n        const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n        for (let i = 0; i < projectionPoints.length; i++) {\n            if (!imageVolume) {\n                continue;\n            }\n            const projectionPoint = projectionPoints[i][0];\n            const { dimensions, imageData, voxelManager } = imageVolume;\n            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n            const worldProjectionPointIndex = transformWorldToIndex(imageData, projectionPoint);\n            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n            worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n            worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n            worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n            worldPos1Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n            worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n            worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n            worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n            worldPos2Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                this.isHandleOutsideImage = false;\n                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                    boundsIJK,\n                    imageData,\n                    returnPoints: this.configuration.storePointData,\n                });\n                pointsInsideVolume.push(pointsInShape);\n            }\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        data.cachedStats.pointsInVolume = pointsInsideVolume;\n        data.cachedStats.statistics = {\n            Modality: metadata.Modality,\n            area,\n            mean: stats.mean?.value,\n            stdDev: stats.stdDev?.value,\n            max: stats.max?.value,\n            statsArray: stats.array,\n            areaUnit: measureInfo.areaUnit,\n            modalityUnit,\n        };\n    }\n    _calculateCachedStatsTool(annotation, enabledElement) {\n        const data = annotation.data;\n        const { viewport } = enabledElement;\n        const { cachedStats } = data;\n        const targetId = this.getTargetId(viewport);\n        const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n        this._computeProjectionPoints(annotation, imageVolume);\n        if (this.configuration.calculatePointsInsideVolume) {\n            this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);\n        }\n        if (this.configuration.calculatePointsInsideVolume) {\n            this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);\n        }\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, viewport.element);\n        return cachedStats;\n    }\n    _getStartCoordinate(worldPos, viewPlaneNormal) {\n        const startPos = worldPos;\n        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);\n        return startCoord;\n    }\n    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const endPos = vec3.create();\n        vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagate * spacingInNormal);\n        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);\n        return endCoord;\n    }\n    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {\n        const viewplaneNormalAbs = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));\n        return indexOfDirection;\n    }\n    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {\n        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        return pos[indexOfDirection];\n    }\n}\nfunction defaultGetTextLines(data) {\n    const cachedVolumeStats = data.cachedStats.statistics;\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import { getEnabledElement, cache, StackViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawHandles as drawHandlesSvg, drawRect as drawRectSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport RectangleROITool from '../annotation/RectangleROITool';\nclass RectangleROIThresholdTool extends RectangleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const targetId = this.getTargetId(viewport);\n            let referencedImageId, volumeId;\n            if (viewport instanceof StackViewport) {\n                referencedImageId = targetId.split('imageId:')[1];\n            }\n            else {\n                volumeId = csUtils.getVolumeId(targetId);\n                const imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    enabledElement,\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                    volumeId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: null,\n                            worldBoundingBox: null,\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    segmentationId: null,\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                triggerAnnotationModified(annotation, element);\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n    }\n}\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","export var ContourWindingDirection;\n(function (ContourWindingDirection) {\n    ContourWindingDirection[ContourWindingDirection[\"CounterClockwise\"] = -1] = \"CounterClockwise\";\n    ContourWindingDirection[ContourWindingDirection[\"Unknown\"] = 0] = \"Unknown\";\n    ContourWindingDirection[ContourWindingDirection[\"Clockwise\"] = 1] = \"Clockwise\";\n})(ContourWindingDirection || (ContourWindingDirection = {}));\n","import { getEnabledElements, utilities as csUtils } from '@cornerstonejs/core';\nconst { isEqual } = csUtils;\nexport default function getViewportsForAnnotation(annotation) {\n    const { metadata } = annotation;\n    return getEnabledElements()\n        .filter((enabledElement) => {\n        if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {\n            const viewport = enabledElement.viewport;\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            return (isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&\n                (!metadata.viewUp || isEqual(viewUp, metadata.viewUp)));\n        }\n        return;\n    })\n        .map((enabledElement) => enabledElement.viewport);\n}\n","import { utilities, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement, } from './getAnnotationNearPoint';\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport { getCalibratedLengthUnitsAndScale, getCalibratedProbeUnitsAndValue, getCalibratedAspect, } from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport { pointToString } from './pointToString';\nimport annotationFrameRange from './annotationFrameRange';\nimport getViewportForAnnotation from './getViewportForAnnotation';\nimport { annotationHydration, getClosestImageIdForStackViewport, } from './annotationHydration';\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\nimport * as contourSegmentation from './contourSegmentation';\nimport { pointInSurroundingSphereCallback } from './pointInSurroundingSphereCallback';\nconst roundNumber = utilities.roundNumber;\nexport { math, planar, viewportFilters, drawing, debounce, dynamicVolume, throttle, orientation, isObject, touch, triggerEvent, calibrateImageSpacing, getCalibratedLengthUnitsAndScale, getCalibratedProbeUnitsAndValue, getCalibratedAspect, segmentation, contours, triggerAnnotationRenderForViewportIds, triggerAnnotationRenderForToolGroupIds, triggerAnnotationRender, getSphereBoundsInfo, getAnnotationNearPoint, getViewportForAnnotation, getAnnotationNearPointOnEnabledElement, viewport, cine, boundingBox, rectangleROITool, planarFreehandROITool, stackPrefetch, stackContextPrefetch, roundNumber, pointToString, polyDataUtils, voi, annotationFrameRange, contourSegmentation, annotationHydration, getClosestImageIdForStackViewport, pointInSurroundingSphereCallback, };\n","export default function findClosestPoint(sourcePoints, targetPoint) {\n    let minPoint = [0, 0];\n    let minDistance = Number.MAX_SAFE_INTEGER;\n    sourcePoints.forEach(function (sourcePoint) {\n        const distance = _distanceBetween(targetPoint, sourcePoint);\n        if (distance < minDistance) {\n            minDistance = distance;\n            minPoint = [...sourcePoint];\n        }\n    });\n    return minPoint;\n}\nfunction _distanceBetween(p1, p2) {\n    const [x1, y1] = p1;\n    const [x2, y2] = p2;\n    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n","import { cache } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getCachedSegmentIndices, setCachedSegmentIndices } from './utilities';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nfunction getUniqueSegmentIndices(segmentationId) {\n    const cachedResult = getCachedSegmentIndices(segmentationId);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation found for segmentationId ${segmentationId}`);\n    }\n    let indices;\n    if (segmentation.representationData.Labelmap) {\n        indices = handleLabelmapSegmentation(segmentation, segmentationId);\n    }\n    else if (segmentation.representationData.Contour) {\n        indices = handleContourSegmentation(segmentation);\n    }\n    else if (segmentation.representationData.Surface) {\n        indices = handleSurfaceSegmentation(segmentation);\n    }\n    else {\n        throw new Error(`Unsupported segmentation type: ${segmentation.representationData}`);\n    }\n    setCachedSegmentIndices(segmentationId, indices);\n    return indices;\n}\nfunction handleLabelmapSegmentation(segmentation, segmentationId) {\n    const labelmapData = segmentation.representationData[SegmentationRepresentations.Labelmap];\n    const keySet = new Set();\n    if (labelmapData.imageIds) {\n        addImageSegmentIndices(keySet, labelmapData.imageIds);\n    }\n    else {\n        addVolumeSegmentIndices(keySet, segmentationId);\n    }\n    return Array.from(keySet)\n        .map(Number)\n        .sort((a, b) => a - b);\n}\nfunction addVolumeSegmentIndices(keySet, segmentationId) {\n    const volume = cache.getVolume(segmentationId);\n    volume.voxelManager.forEach(({ value }) => {\n        if (value !== 0) {\n            keySet.add(value);\n        }\n    });\n}\nfunction addImageSegmentIndices(keySet, imageIds) {\n    imageIds.forEach((segmentationImageId) => {\n        const image = cache.getImage(segmentationImageId);\n        const scalarData = image.voxelManager.getScalarData();\n        scalarData.forEach((segmentIndex) => {\n            if (segmentIndex !== 0) {\n                keySet.add(segmentIndex);\n            }\n        });\n    });\n}\nfunction handleContourSegmentation(segmentation) {\n    const { annotationUIDsMap, geometryIds } = segmentation.representationData.Contour || {};\n    if (!geometryIds) {\n        throw new Error(`No geometryIds found for segmentationId ${segmentation.segmentationId}`);\n    }\n    const indices = new Set([...annotationUIDsMap.keys()]);\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        indices.add(geometry.data.segmentIndex);\n    });\n    return Array.from(indices).sort((a, b) => a - b);\n}\nfunction handleSurfaceSegmentation(segmentation) {\n    const geometryIds = segmentation.representationData.Surface?.geometryIds ?? [];\n    return Array.from(geometryIds.keys())\n        .map(Number)\n        .sort((a, b) => a - b);\n}\nexport { getUniqueSegmentIndices };\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nexport function invalidateBrushCursor(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    brushBasedToolInstances.forEach((tool) => {\n        tool.invalidateBrushCursor();\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);\n    if (!viewportsInfoArray.length) {\n        return;\n    }\n    const viewportIds = toolGroup.getViewportIds();\n    triggerAnnotationRenderForViewportIds(viewportIds);\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nconst equalsCheck = (a, b) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\nexport function getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter) {\n    const halfSpacingX = voxelSpacing[0] / 2;\n    const halfSpacingY = voxelSpacing[1] / 2;\n    const halfSpacingZ = voxelSpacing[2] / 2;\n    const voxelCornersIJK = new Array(8);\n    voxelCornersIJK[0] = csUtils.transformWorldToIndex(imageData, [\n        voxelCenter[0] - halfSpacingX,\n        voxelCenter[1] - halfSpacingY,\n        voxelCenter[2] - halfSpacingZ,\n    ]);\n    const offsets = [\n        [1, -1, -1],\n        [-1, 1, -1],\n        [1, 1, -1],\n        [-1, -1, 1],\n        [1, -1, 1],\n        [-1, 1, 1],\n        [1, 1, 1],\n    ];\n    for (let i = 0; i < 7; i++) {\n        const [xOff, yOff, zOff] = offsets[i];\n        voxelCornersIJK[i + 1] = csUtils.transformWorldToIndex(imageData, [\n            voxelCenter[0] + xOff * halfSpacingX,\n            voxelCenter[1] + yOff * halfSpacingY,\n            voxelCenter[2] + zOff * halfSpacingZ,\n        ]);\n    }\n    return getBoundingBoxAroundShapeIJK(voxelCornersIJK, dimensions);\n}\nexport function processVolumes(segmentationVolume, thresholdVolumeInformation) {\n    const { spacing: segmentationSpacing } = segmentationVolume;\n    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();\n    const volumeInfoList = [];\n    let baseVolumeIdx = 0;\n    for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n        const { imageData, spacing, dimensions, voxelManager } = thresholdVolumeInformation[i].volume;\n        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();\n        if (volumeSize === scalarDataLength &&\n            equalsCheck(spacing, segmentationSpacing)) {\n            baseVolumeIdx = i;\n        }\n        const lower = thresholdVolumeInformation[i].lower;\n        const upper = thresholdVolumeInformation[i].upper;\n        volumeInfoList.push({\n            imageData,\n            lower,\n            upper,\n            spacing,\n            dimensions,\n            volumeSize,\n            voxelManager,\n        });\n    }\n    return {\n        volumeInfoList,\n        baseVolumeIdx,\n    };\n}\nconst segmentIndicesCache = new Map();\nexport const setSegmentationDirty = (segmentationId) => {\n    const cached = segmentIndicesCache.get(segmentationId);\n    if (cached) {\n        cached.isDirty = true;\n    }\n};\nexport const setSegmentationClean = (segmentationId) => {\n    const cached = segmentIndicesCache.get(segmentationId);\n    if (cached) {\n        cached.isDirty = false;\n    }\n};\nexport const getCachedSegmentIndices = (segmentationId) => {\n    const cached = segmentIndicesCache.get(segmentationId);\n    if (cached && !cached.isDirty) {\n        return cached.indices;\n    }\n    return null;\n};\nexport const setCachedSegmentIndices = (segmentationId, indices) => {\n    segmentIndicesCache.set(segmentationId, { indices, isDirty: false });\n};\n","import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nexport function triggerAnnotationRenderForViewportIds(viewportIdsToRender) {\n    if (!viewportIdsToRender.length) {\n        return;\n    }\n    viewportIdsToRender.forEach((viewportId) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const { viewport } = enabledElement;\n        if (!viewport) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const element = viewport.element;\n        triggerAnnotationRender(element);\n    });\n}\nexport default triggerAnnotationRenderForViewportIds;\n","import { m as macro } from '../../macros2.js';\nimport vtkDataArray from './DataArray.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction extractCellSizes(cellArray) {\n  let currentIdx = 0;\n  return cellArray.filter((value, index) => {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return true;\n    }\n    return false;\n  });\n}\nfunction getNumberOfCells(cellArray) {\n  let cellId = 0;\n  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length;) {\n    cellArrayIndex += cellArray[cellArrayIndex] + 1;\n    cellId++;\n  }\n  return cellId;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  extractCellSizes,\n  getNumberOfCells\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellArray');\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.getNumberOfCells = recompute => {\n    if (model.numberOfCells !== undefined && !recompute) {\n      return model.numberOfCells;\n    }\n    if (model.cellSizes) {\n      model.numberOfCells = model.cellSizes.length;\n    } else {\n      model.numberOfCells = getNumberOfCells(publicAPI.getData());\n    }\n    return model.numberOfCells;\n  };\n  publicAPI.getCellSizes = recompute => {\n    if (model.cellSizes !== undefined && !recompute) {\n      return model.cellSizes;\n    }\n    model.cellSizes = extractCellSizes(publicAPI.getData());\n    return model.cellSizes;\n  };\n\n  /**\n   * When `resize()` is being used, you then MUST use `insertNextCell()`.\n   */\n  publicAPI.resize = requestedNumTuples => {\n    const oldNumTuples = publicAPI.getNumberOfTuples();\n    superClass.resize(requestedNumTuples);\n    const newNumTuples = publicAPI.getNumberOfTuples();\n    if (newNumTuples < oldNumTuples) {\n      if (newNumTuples === 0) {\n        model.numberOfCells = 0;\n        model.cellSizes = [];\n      } else {\n        // We do not know how many cells are left.\n        // Set to undefined to ensure insertNextCell works correctly.\n        model.numberOfCells = undefined;\n        model.cellSizes = undefined;\n      }\n    }\n  };\n  publicAPI.setData = typedArray => {\n    superClass.setData(typedArray, 1);\n    model.numberOfCells = undefined;\n    model.cellSizes = undefined;\n  };\n  publicAPI.getCell = loc => {\n    let cellLoc = loc;\n    const numberOfPoints = model.values[cellLoc++];\n    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);\n  };\n  publicAPI.insertNextCell = cellPointIds => {\n    const cellId = publicAPI.getNumberOfCells();\n    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);\n    // By computing the number of cells earlier, we made sure that numberOfCells is defined\n    ++model.numberOfCells;\n    if (model.cellSizes != null) {\n      model.cellSizes.push(cellPointIds.length);\n    }\n    return cellId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    empty: true,\n    numberOfComponents: 1,\n    dataType: VtkDataTypes.UNSIGNED_INT,\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkDataArray.extend(publicAPI, model, defaultValues(initialValues));\n  vtkCellArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellArray');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellArray$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkCellArray$1 as default, extend, newInstance };\n","const DataTypeByteSize = {\n  Int8Array: 1,\n  Uint8Array: 1,\n  Uint8ClampedArray: 1,\n  Int16Array: 2,\n  Uint16Array: 2,\n  Int32Array: 4,\n  Uint32Array: 4,\n  Float32Array: 4,\n  Float64Array: 8\n};\nconst VtkDataTypes = {\n  VOID: '',\n  // not sure to know what that should be\n  CHAR: 'Int8Array',\n  SIGNED_CHAR: 'Int8Array',\n  UNSIGNED_CHAR: 'Uint8Array',\n  UNSIGNED_CHAR_CLAMPED: 'Uint8ClampedArray',\n  // should be used for VTK.js internal purpose only\n  SHORT: 'Int16Array',\n  UNSIGNED_SHORT: 'Uint16Array',\n  INT: 'Int32Array',\n  UNSIGNED_INT: 'Uint32Array',\n  FLOAT: 'Float32Array',\n  DOUBLE: 'Float64Array'\n};\nconst DefaultDataType = VtkDataTypes.FLOAT;\nvar Constants = {\n  DefaultDataType,\n  DataTypeByteSize,\n  VtkDataTypes\n};\n\nexport { DataTypeByteSize, DefaultDataType, VtkDataTypes, Constants as default };\n","const AttributeTypes = {\n  SCALARS: 0,\n  VECTORS: 1,\n  NORMALS: 2,\n  TCOORDS: 3,\n  TENSORS: 4,\n  GLOBALIDS: 5,\n  PEDIGREEIDS: 6,\n  EDGEFLAG: 7,\n  NUM_ATTRIBUTES: 8\n};\nconst AttributeLimitTypes = {\n  MAX: 0,\n  EXACT: 1,\n  NOLIMIT: 2\n};\nconst CellGhostTypes = {\n  DUPLICATECELL: 1,\n  // the cell is present on multiple processors\n  HIGHCONNECTIVITYCELL: 2,\n  // the cell has more neighbors than in a regular mesh\n  LOWCONNECTIVITYCELL: 4,\n  // the cell has less neighbors than in a regular mesh\n  REFINEDCELL: 8,\n  // other cells are present that refines it.\n  EXTERIORCELL: 16,\n  // the cell is on the exterior of the data set\n  HIDDENCELL: 32 // the cell is needed to maintain connectivity, but the data values should be ignored.\n};\n\nconst PointGhostTypes = {\n  DUPLICATEPOINT: 1,\n  // the cell is present on multiple processors\n  HIDDENPOINT: 2 // the point is needed to maintain connectivity, but the data values should be ignored.\n};\n\nconst AttributeCopyOperations = {\n  COPYTUPLE: 0,\n  INTERPOLATE: 1,\n  PASSDATA: 2,\n  ALLCOPY: 3 // all of the above\n};\n\nconst ghostArrayName = 'vtkGhostType';\nconst DesiredOutputPrecision = {\n  DEFAULT: 0,\n  // use the point type that does not truncate any data\n  SINGLE: 1,\n  // use Float32Array\n  DOUBLE: 2 // use Float64Array\n};\n\nvar Constants = {\n  AttributeCopyOperations,\n  AttributeLimitTypes,\n  AttributeTypes,\n  CellGhostTypes,\n  DesiredOutputPrecision,\n  PointGhostTypes,\n  ghostArrayName\n};\n\nexport { AttributeCopyOperations, AttributeLimitTypes, AttributeTypes, CellGhostTypes, DesiredOutputPrecision, PointGhostTypes, Constants as default, ghostArrayName };\n","import { m as macro } from '../../macros2.js';\nimport { b as roundVector, c as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n    if (extentArray.length !== 6) {\n      return false;\n    }\n    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n  publicAPI.setDimensions = function () {\n    let i;\n    let j;\n    let k;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (arguments.length === 1) {\n      const array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n    return nCells;\n  };\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n  publicAPI.getPoint = index => {\n    const dims = publicAPI.getDimensions();\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n    const ijk = new Float64Array(3);\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n      case StructuredType.SINGLE_POINT:\n        break;\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  };\n\n  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  publicAPI.extentToBounds = ex => vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);\n\n  // Internal, shouldn't need to call this manually.\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n  publicAPI.indexToWorld = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n  publicAPI.worldToIndex = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n  publicAPI.indexToWorldBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n  publicAPI.worldToIndexBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  };\n\n  // Make sure the transform is correct\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n  publicAPI.computeHistogram = function (worldBounds) {\n    let voxelFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    const dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n    const pixels = publicAPI.getPointData().getScalars().getData();\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunction || voxelFunction([x, y, z], bounds)) {\n            const pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n          ++index;\n        }\n      }\n    }\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    const sigma = Math.sqrt(variance);\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum\n    };\n  };\n\n  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n  publicAPI.computeIncrements = function (extent) {\n    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const increments = [];\n    let incr = numberOfComponents;\n\n    // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n  publicAPI.computeOffsetIndex = _ref => {\n    let [i, j, k] = _ref;\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents);\n    // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n  publicAPI.getOffsetIndexFromWorld = xyz => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz);\n\n    // Confirm indexed i,j,k coords are within the bounds of the volume\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);\n        return NaN;\n      }\n    }\n\n    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);\n      return NaN;\n    }\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16);\n\n  // Set/Get methods\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6);\n\n  // Object specific methods\n  vtkImageData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageData$1 as default, extend, newInstance };\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import min from \"./min.js\";\n\nexport default function transpose(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n}\n\nfunction length(d) {\n  return d.length;\n}\n","import transpose from \"./transpose.js\";\n\nexport default function zip() {\n  return transpose(arguments);\n}\n","export default function min(values, valueof) {\n  let min;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  }\n  return min;\n}\n","export default function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n"],"names":["enabledElement","invalidated","image","canvas","start","stats","lastGetPixelDataTime","lastStoredPixelDataToCanvasImageDataTime","lastPutImageDataTime","lastRenderTime","lastLutGenerateTime","render","viewport","colormap","color","renderTimeInMs","invalid","needsRedraw","scale","transform","displayedArea","translate","width","height","angle","rotation","rotate","Math","PI","widthScale","heightScale","brhc","x","tlhc","y","presentationSizeMode","rowPixelSpacing","columnPixelSpacing","verticalScale","horizontalScale","min","translation","undefined","hflip","vflip","modality","Error","scaleFactor","voi","isPreScaled","windowWidth","windowCenter","Array","isArray","invert","pixelReplication","modalityLUT","voiLUT","columns","rows","async","renderingEngine","volumeInputs","viewportIds","immediateRender","suppressEvents","viewportId","getViewport","BaseVolumeViewport","console","warn","addVolumePromises","map","addVolumes","Promise","all","stackInputs","getStackViewport","addImages","addStackPromises","DEFAULT_SETTINGS","Symbol","RUNTIME_SETTINGS","OBJECT_SETTINGS_MAP","DICTIONARY","Settings","constructor","base","dictionary","Object","create","seal","defineProperty","this","value","set","key","get","unset","name","endsWith","deleteCount","namespace","slice","deleteAll","length","prototype","hasOwnProperty","call","startsWith","forEach","callback","iterate","extend","import","root","isPlainObject","keys","dump","context","deepSet","assert","subject","getRuntimeSettings","getDefaultSettings","subfield","defaultSettings","settingObj","setting","split","runtimeSettings","getObjectSettings","from","settings","objectSettingsMap","WeakMap","extendRuntimeSettings","references","last","current","previous","indexOf","isValidKey","prefix","record","failCount","has","add","field","delete","setAll","WeakSet","getPrototypeOf","separator","subKey","subContext","subContextValue","props","points","type","data","id","_points","_type","_color","_segmentIndex","segmentIndex","sizeInBytes","_getSizeInBytes","flatPointsArray","point","flat","ContourSet","_contours","frameOfReferenceUID","_createEachContour","contourDataArray","contourData","contour","push","_updateContourSetCentroid","numberOfPoints","totalNumberOfPoints","sumOfPoints","reduce","acc","centroid","closestPoint","_getDistance","_centroid","pointA","pointB","sqrt","contours","flatMap","numberOfContours","numberOfPointsArray","getPointsInContour","contourIndex","getNumberOfPointsInAContour","Surface","_polys","polys","_updateCentroid","sumX","sumY","sumZ","i","BlendMode","BlendModes","COMPOSITE_BLEND","MAXIMUM_INTENSITY_BLEND","MINIMUM_INTENSITY_BLEND","AVERAGE_INTENSITY_BLEND","GeometryType","CalibrationTypes","GenerateImageType","getEnabledElement","element","viewportUid","renderingEngineUid","dataset","getEnabledElementByIds","renderingEngineId","hasBeenDestroyed","FrameOfReferenceUID","getFrameOfReferenceUID","getEnabledElementByViewportId","renderingEngines","getEnabledElements","enabledElements","getViewports","workerRegistry","workerPoolManager","R","registerWorker","workerName","workerFn","options","maxWorkerInstances","overwrite","autoTerminateOnIdle","enabled","idleTimeThreshold","idleCheckIntervalId","clearInterval","workerProperties","instances","loadCounters","lastActiveTime","nativeWorkers","fill","worker","getNextWorkerAPI","error","workerInstances","filter","instance","minLoadIndex","minLoadValue","currentLoadValue","api","index","executeTask","methodName","args","requestType","RequestType","Compute","priority","callbacks","resolve","reject","addRequest","finalCallbacks","cb","processing","results","Date","now","setInterval","terminateIdleWorkers","err","_","terminateWorkerInstance","terminate","workerInstance","csRenderInitialized","defaultConfig","gpuTier","tier","isMobile","rendering","useCPURendering","preferSizeOverAccuracy","strictZSpacingForVolumeViewport","peerImport","moduleId","config","isIOS","test","navigator","platform","maxTouchPoints","includes","canRenderFloatTextures","getShouldUseCPURendering","isCornerstoneInitialized","getConfiguration","getWebWorkerManager","geometryLoaders","unknownGeometryLoader","loadGeometryFromGeometryLoader","geometryId","colonIndex","scheme","substring","loader","geometryLoadObject","promise","then","geometry","GEOMETRY_LOADED","errorObject","GEOMETRY_LOADED_FAILED","loadGeometry","getGeometryLoadObject","loadAndCacheGeometry","putGeometryLoadObject","createAndCacheGeometry","getGeometry","CONTOUR","geometryData","SURFACE","putGeometrySync","registerGeometryLoader","geometryLoader","registerUnknownGeometryLoader","oldGeometryLoader","imageLoaders","unknownImageLoader","loadImageFromImageLoader","imageId","cachedImageLoadObject","getImageLoadObject","handleImageLoadPromise","imageLoadObject","imagePromise","voxelManager","numberOfComponents","createImageVoxelManager","scalarData","getPixelData","getScalarData","imageFrame","pixelData","ensureVoxelManager","IMAGE_LOADED","catch","errorDetails","IMAGE_LOAD_FAILED","loadImage","loadAndCacheImage","putImageLoadObject","loadAndCacheImages","imageIds","createAndCacheDerivedImage","referencedImageId","skipCreateBuffer","onCacheAdd","imagePlaneModule","TypedArrayConstructor","targetBuffer","imageScalarData","derivedImageId","referencedImagePlaneMetadata","metadata","referencedImageGeneralSeriesMetadata","instanceNumber","imagePixelModule","bitsAllocated","bitsStored","highBit","samplesPerPixel","pixelRepresentation","localImage","createAndCacheLocalImage","dimensions","spacing","origin","imagePositionPatient","direction","imageOrientationPatient","putImageSync","createAndCacheDerivedImages","referencedImageIds","derivedImageIds","newOptions","getDerivedImageId","rowCosines","columnCosines","pixelSpacing","scalarDataToUse","Uint8Array","Float32Array","Uint16Array","Int16Array","numBytes","photometricInterpretation","minPixelValue","maxPixelValue","intercept","dataType","slope","getCanvas","rgba","byteLength","cancelLoadImage","filterRequests","additionalDetails","cancelFn","cancelLoadImages","cancelLoadAll","requestPool","getRequestPool","requests","pop","volumeId","loadObject","getVolumeLoadObject","cancel","clearRequestStack","registerImageLoader","imageLoader","registerUnknownImageLoader","oldImageLoader","unregisterAllImageLoaders","createAndCacheDerivedLabelmapImages","createAndCacheDerivedLabelmapImage","createContourSet","contourSetData","contourSet","validateContourSet","createSurface","surfaceData","surface","validateSurface","volumeLoaders","unknownVolumeLoader","loadVolumeFromVolumeLoader","volumeLoadObject","volume","VOLUME_LOADED","VOLUME_LOADED_FAILED","loadVolume","createAndCacheVolume","putVolumeLoadObject","createAndCacheDerivedVolume","referencedVolumeId","referencedVolume","getVolume","isDynamicVolume","getCurrentTimePointImageIds","derivedImages","derivedVolumeImageIds","derivedVolume","structuredClone","putVolumeSync","createAndCacheVolumeFromImages","cachedVolume","getImage","createAndCacheVolumeFromImagesSync","volumeProps","createLocalVolume","preventCache","sliceLength","totalNumberOfVoxels","isCacheable","sliceData","subarray","derivedImage","imageVolume","createImageVolumeVoxelManager","registerVolumeLoader","volumeLoader","getVolumeLoaderSchemes","registerUnknownVolumeLoader","oldVolumeLoader","getUnknownVolumeLoaderSchema","createAndCacheDerivedLabelmapVolume","createLocalLabelmapVolume","ProgressiveIterator","as","iterator","v","e","reason","done","nextValue","waiting","rejectReason","getRecent","asyncIterator","errorCallback","generate","processFunction","bind","nextPromise","donePromise","getNextPromise","getDonePromise","RLEVoxelMap","depth","Map","jMultiple","kMultiple","defaultValue","pixelDataConstructor","j","rle","getRLE","getRun","k","runIndex","row","end","rleIndex","findIndex","rle1","rle0","oldValue","rleInsert","isAfter","insertIndex","rlePrev","rleNext","splice","nextnext","iEnd","clear","rowOffset","comp","isImageActor","actorEntry","actorIsA","actorType","actor","isA","applyPreset","preset","colorTransferArray","colorTransfer","parseFloat","shiftRange","Infinity","max","center","getShiftRange","cfun","normColorTransferValuePoints","r","g","b","range","rescaled","removeAllPoints","addRGBPoint","applyPointsToRGBFunction","getProperty","setRGBTransferFunction","scalarOpacityArray","scalarOpacity","ofun","normPoints","opacity","pwf","addPoint","applyPointsToPiecewiseFunction","property","setScalarOpacity","gradientMinValue","gradientMinOpacity","gradientMaxValue","gradientMaxOpacity","gradientOpacity","setUseGradientOpacity","setGradientOpacityMinimumValue","setGradientOpacityMinimumOpacity","setGradientOpacityMaximumValue","setGradientOpacityMaximumOpacity","interpolation","setInterpolationTypeToFastLinear","setShade","shade","ambient","diffuse","specular","specularPower","setAmbient","setDiffuse","setSpecular","setSpecularPower","renderingEngineAndViewportIds","renderingEnginesArray","viewports","getRenderingEngineAndViewportsContainingVolume","renderViewports","clamp","_colormaps","registerColormap","Name","getColormap","getColormapNames","findMatchingColormap","rgbPoints","colormapsVTK","rgbPresetNames","presetName","getPresetByName","colormapsCS3D","colormapName","matchedColormap","concat","find","RGBPoints","presetRGBPoints","opacityPoints","getScalarOpacity","getDataPointer","createLinearRGBTransferFunction","voiRange","lower","upper","createSigmoidRGBTransferFunction","approximationNodes","table","wc","ww","log","logit","buildFunctionFromArray","values","decimate","list","interleave","offset","interleaveIndices","deepClone","obj","clonedObj","getClosestImageId","worldPos","viewPlaneNormal","kVector","dotProducts","abs","EPSILON","halfSpacingInNormalDirection","imageIdForTool","dir","dot","camera","getCamera","spacingInNormalDirection","focalPoint","getActors","a","referencedId","uid","volumeActor","sliceRange","numberOfSlices","round","imageIndex","floor","getMinMax","storedPixelData","storedPixel","numPixels","getScalingParameters","modalityLutModule","generalSeriesModule","scalingParameters","rescaleSlope","rescaleIntercept","suvFactor","suvbw","suvbsa","suvlbm","SMALL_EPSILON","isOne","isUnit","off","isOrthonormal","getSliceRange","imageData","getMapper","getInputData","corners","getDirection","dx","dy","dz","getDimensions","it","indexToWorld","buildFromDegree","identity","rotateFromDirections","pt","apply","transformedFocalPoint","currentSlice","minX","maxX","getSpacingInNormalDirection","iVector","jVector","projectedSpacing","EPSILON_PART","isPrimaryVolume","str","starts","getTargetVolumeAndSpacingInNormalDir","targetId","useSlabThickness","volumeActors","actorUID","imageVolumes","va","iv","targetVolumeId","imageVolumeIndex","getSpacingInNormal","smallest","hasPrimaryVolume","slabThickness","getProperties","targetViewports","filteredViewports","getVolumeViewports","vp","hasVolumeId","getVoiFromSigmoidRGBTransferFunction","cfunRange","getRange","getTable","cfunDomain","y1","logy1","x1","y2","logy2","x2","getVolumeActorCorners","bounds","extentToBounds","getExtent","getVolumeId","getActor","numScrollSteps","floatingStepNumber","currentStepIndex","sliceRangeInfo","hasFloatScalingParameters","some","Number","isInteger","hasNaNValues","input","isNaN","imageIdToURI","retrieveConfigurationState","IMAGE_RETRIEVE_CONFIGURATION","imageRetrieveMetadataProvider","payload","clone","restore","state","queries","query","addProvider","EventListenerPhases","TargetEventListeners","target","_eventListeners","_children","_target","isEmpty","size","addEventListener","dotIndex","namespaceToken","childElementEventListener","_addEventListener","removeEventListener","_removeEventListener","reset","entries","child","_unregisterAllEvents","listenersMap","listenerPhase","capture","Capture","Bubble","registeredPhases","None","callbackItem","newListenerPhase","_unregisterAllListeners","listener","eventPhases","currentPhase","useCapture","MultiTargetEventListenerManager","_targetsEventListeners","eventListeners","targetEventListeners","scaleRGBTransferFunction","rgbTransferFunction","scalingFactor","getSize","nodeValue1","getNodeValue","setNodeValue","LAST_RUNTIME_ID","GLOBAL_CONTEXT","DEFAULT_MAX","DEFAULT_SEPARATOR","getRuntimeId","symbol","idComponents","carry","n","getNextRuntimeId","join","imageURI","isOpposite","v1","v2","tolerance","indexWithinDimensions","targetViewport","getRenderingEngine","sameVolumesViewports","targetActors","vpActors","every","vpActor","preScale","scaled","renderToCanvasGPU","imageOrVolume","viewportOptions","displayArea","imageArea","HTMLCanvasElement","isVolume","document","createElement","devicePixelRatio","window","originalWidth","originalHeight","style","visibility","position","body","appendChild","uniqueId","setAttribute","temporaryCanvas","getOrCreateCanvas","RenderingEngine","viewportInput","ViewportType","ORTHOGRAPHIC","STACK","defaultOptions","enableElement","elementRendered","viewReference","onImageRendered","eventDetail","useViewRef","setViewReference","getContext","drawImage","canvasToWorld","topRight","bottomLeft","Events","IMAGE_RENDERED","setTimeout","disableElement","querySelectorAll","remove","thicknessMm","setVolumes","renderImageObject","resetCamera","setProperties","renderToCanvasCPU","_renderingEngineId","_viewportOptions","getDefaultViewport","renderingTools","calculateTransform","drawImageSync","loadImageToCanvas","Thumbnail","thumbnail","imageAspect","baseViewportOptions","renderFn","successCallback","metaData","useRGBA","cache","imageLoadPoolManager","imageIdIndex","worldCoords","newOrigin","sub","imageToWorldCoords","imageCoords","imageCoordsInWorld","getViewportsWithImageURI","hasImageURI","getClosestStackImageIndexForPoint","minimalDistance","getImageIds","currentImageIdIndex","getCurrentImageIdIndex","getDistance","planeMetadata","targetImagePlane","rowVec","colVec","planeNormal","getPlaneMetadata","plane","planar","planeEquation","planeDistanceToPoint","closestStack","distance","higherImageIds","lowerImageIds","calculateMinimalDistanceForStackViewport","getCurrentVolumeViewportSlice","canvasWidth","canvasHeight","sliceToIndexMatrix","indexToSliceMatrix","getSliceViewInfo","ijkOriginPoint","transformCanvasToIJK","ijkRowPoint","ijkColPoint","ijkRowVec","ijkColVec","ijkSliceVec","maxIJKRowVec","maxIJKColVec","getImageData","sliceViewInfo","getSliceData","spatialRegistrationMetadataProvider","viewportId1","viewportId2","entryId","entryIdReverse","viewport1","viewport2","imageId1","getSliceIndex","imageId2","imagePlaneModule1","toString","imagePlaneModule2","iop2","imagePositionPatient1","imagePositionPatient2","mat","getViewportImageCornersInWorld","ratio","topRightCanvas","bottomRightCanvas","bottomLeftCanvas","topLeftWorld","topRightWorld","bottomRightWorld","bottomLeftWorld","topLeftImage","worldToIndex","topRightImage","bottomRightImage","bottomLeftImage","topLeftImageWorld","_isInBounds","topRightImageWorld","bottomRightImageWorld","bottomLeftImageWorld","_getStackViewportImageCorners","imageCoord","PointsManager","configuration","_dimensions","_length","_byteSize","growSize","initialSize","itemLength","array","ArrayBuffer","func","getPoint","dimensionLength","getPointArray","grow","additionalSize","newSize","newArray","newData","reverse","midLength","indexStart","indexEnd","dimension","valueStart","f","mapData","p","toXYZ","xyz","z","fromXYZ","create3","subselect","count","selected","create2","StackViewport","getCornerstoneImage","isValidVolume","imageId0","seriesInstanceUID","baseMetadata","validVolume","isEqual","videoUIDs","Set","isVideoTransferSyntax","uidOrUids","convertStackToVolumeViewport","uuidv4","prevViewPresentation","getViewPresentation","prevViewReference","getViewReference","background","orientation","load","volumeViewport","volumeViewportNewVolumeHandler","VOLUME_VIEWPORT_NEW_VOLUME","setViewPresentation","convertVolumeToStackViewport","ImageVolume","prevView","stackViewport","setStack","roundToPrecision","roundNumber","precision","absValue","fixedPrecision","toFixed","convertToGrayscale","isRGBA","isRGB","newScalarData","destOffset","increment","getRandomSampleFromArray","clonedArray","shuffleArray","random","componentToHex","c","hex","rgbToHex","hexToRgb","result","exec","parseInt","deepEqual","obj1","obj2","JSON","stringify","debug","groupBy","rv","test4DTag","IPPGroups","value_getter","frame_groups","first_frame_value_set","positions","frame_value_set","frames","frame_value","setEquals","getTagValue","tag","getPhilipsPrivateBValue","InlineBinary","value_bytes","atob","ary_buf","dv","DataView","setUint8","charCodeAt","getSiemensPrivateBValue","getGEPrivateBValue","set_a","set_b","getPetFrameReferenceTime","moduleInfo","positionGroups","ippMetadata","item","frame_count","getIPPGroups","imageIdGroups","splittingTag","tags","fncList2","sort","timePoints","scaleArray","arrayLength","clip","val","low","high","delta","scrollSlabs","getVolumeViewportScrollInfo","newFocalPoint","newPosition","snapFocalPointToSlice","setCamera","desiredStepIndex","VolumeScrollEventDetail","currentImageId","getCurrentImageId","triggerEvent","eventTarget","VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS","VOLUME_VIEWPORT_SCROLL","scrollVolume","eventData","STACK_SCROLL_OUT_OF_BOUNDS","scroll","debounceLoading","loop","jumpToSlice","currentImageIndex","getTargetImageIdIndex","getNumberOfSlices","_getImageSliceData","imageIndexToJump","lastSliceIndex","_getImageIndexToJump","getViewportModality","Modality","_getViewportModality","invertRgbTransferFunction","areNumbersEqualWithTolerance","num1","num2","isNumberType","isNumberArrayLike","arr1","arr2","areArraysEqual","negative","isEqualNegative","isEqualAbs","makeVolumeMetadata","voiLut","voiLutModule","voiLUTFunction","BitsAllocated","BitsStored","SamplesPerPixel","HighBit","PhotometricInterpretation","PixelRepresentation","ImageOrientationPatient","PixelSpacing","Columns","Rows","VOILUTFunction","SeriesInstanceUID","linePlaneIntersection","p0","p1","x0","y0","z0","z1","A","B","C","D","t","normal","normalized","threePlaneIntersection","firstPlane","secondPlane","thirdPlane","A1","B1","C1","D1","A2","B2","C2","D2","A3","B3","C3","D3","m0","m1","m2","m3","signed","numerator","sign","pointInShapeCallback","pointInShapeFn","boundsIJK","returnPoints","iMin","iMax","jMin","jMax","kMin","kMax","numComps","getPointData","getScalars","getData","scanAxisNormal","getSpacing","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","rowStep","columnStep","scanAxisStep","xMultiple","yMultiple","zMultiple","pointsInShape","currentPos","startPosJ","startPosI","pointIJK","pointLPS","deltaFrames","posDiffFromFocalPoint","steps","frameIndex","newSlicePosFromMin","sortImageIdsAndGetSpacing","referenceImagePositionPatient","rowCosineVec","colCosineVec","refIppVec","usingWadoUri","sortedImageIds","zSpacing","positionVector","prefetchedImageIds","metadataForMiddleImage","distanceBetweenFirstAndMiddleImages","distanceImagePairs","numImages","sliceThickness","spacingBetweenSlices","getTransferFunctionNodes","transferFunction","setTransferFunctionNodes","nodes","node","canvasPoint","vtkImageData","worldPoint","transformIndexToWorld","voxelPos","transformWorldToIndex","updateVTKImageDataWithCornerstoneImage","sourceImageData","newPixelData","modified","toWindowLevel","toLowHighRange","DEFINED_CURSORS","STANDARD_CURSORS","MouseCursor","fallback","getName","addFallbackStyleProperty","getStyleProperty","getDefinedCursor","definedCursors","getDefinedCursors","mouseCursor","setDefinedCursor","cursor","standardCursorNames","ELEMENT_CURSORS_MAP","_setElementCursor","cursors","_getElementCursors","resetElementCursor","hideElementCursor","BASE","iconContent","iconSize","viewBox","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Height","Probe","RectangleROI","TextMarker","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","assign","svgCursorNames","AnnotationStyleStates","Highlighted","ToolModes","Active","VIEWPORT_ELEMENT","getSvgNode","canvasHash","cacheKey","svgNodeCache","domRef","appendNode","svgLayerElement","svgNode","touched","setNodeTouched","clearUntouched","cacheEntry","removeChild","viewportElement","internalDivElement","querySelector","svgLayer","_getSvgLayer","svgNodeCacheForCanvas","fn","svgDrawingHelper","attributes","currentValue","getAttribute","newValue","removeAttribute","annotationUID","circleUID","radius","dataId","lineWidth","lineDash","fillOpacity","strokeOpacity","strokeWidth","svgNodeHash","_getHash","existingCircleElement","cx","cy","stroke","newCircleElement","createElementNS","ellipseUID","canvasCoordinates","existingEllipse","bottom","top","left","right","w","hypot","h","atan2","rx","ry","svgEllipseElement","handleGroupUID","handle","uniqueIndex","handleRadius","side","existingHandleElement","newHandleElement","handlePoints","drawLine","lineUID","shadow","existingLine","dropShadowStyle","newLine","drawHeight","heightUID","midX","endfirstLine","endsecondLine","firstLine","secondLine","threeLine","drawPolyline","polylineUID","fillColor","closePath","existingPolyLine","pointsAttribute","firstPoint","newPolyLine","drawPath","pathUID","pointsArrays","existingNode","numArrays","numPoints","d","newNode","_createTextSpan","text","textSpanElement","textContent","_drawTextBackground","group","getBBox","insertBefore","firstChild","bBox","textUID","textLines","padding","fontFamily","fontSize","textGroupBoundingBox","svgns","existingTextGroup","textElement","textSpans","children","textSpan","textGroupAttributes","textGroup","noSelectStyle","combinedStyle","_createTextElement","_drawTextGroup","centerX","centerY","linkUID","annotationAnchorPoints","refPoint","boundingBox","findClosestPoint","boundingBoxPoints","halfWidth","halfHeight","_boundingBoxPoints","textBoxUID","textBoxPosition","textBox","mergedOptions","centering","canvasBoundingBox","drawRectByCoordinates","rectangleUID","_width","existingRect","topLeft","bottomRight","leftEdgeCenter","svgRectElement","drawRect","drawArrow","arrowUID","cos","sin","drawRedactionRect","ChangeTypes","StrategyCallbacks","Swipe","DEFAULT_CONTOUR_SEG_TOOL_NAME","convertContourPolylineToCanvasSpace","polyline","projectedPolyline","worldToCanvas","createPolylineHole","targetAnnotation","holeAnnotation","windingDirection","targetWindingDirection","holeWindingDirection","addChildAnnotation","removeContourSegmentationAnnotation","holeContour","holePolyline","closed","updatedToolNames","toolName","viewportIdsToRender","getViewportIdsWithToolToRender","Passive","Enabled","CAMERA_MODIFIED","Enums","STACK_NEW_IMAGE","VOLUME_NEW_IMAGE","PanTool","toolProps","defaultToolProps","supportedInteractionTypes","super","touchDragCallback","evt","_dragCallback","mouseDragCallback","deltaPoints","detail","deltaPointsWorld","world","updatedPosition","updatedFocalPoint","TrackballRotateTool","rotateIncrementDegrees","_resizeObservers","_hasResolutionChanged","preMouseDownCallback","mapper","getDefaultActor","originalSampleDistance","getSampleDistance","setSampleDistance","cleanUp","once","_getViewportsInfo","getToolGroup","toolGroupId","viewportsInfo","onSetToolActive","subscribeToElementResize","resizeObserver","ResizeObserver","observe","_viewportAddedListener","TOOLGROUP_VIEWPORT_ADDED","onSetToolDisabled","disconnect","rotateCamera","centerWorld","axis","vtkCamera","getVtkActiveCamera","viewUp","getViewUp","getFocalPoint","getPosition","newViewUp","currentPoints","lastPoints","currentPointsCanvas","lastPointsCanvas","clientWidth","clientHeight","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","noe","angleX","acos","upVec","atV","rightV","forwardV","angleY","WindowLevelTool","_getImageDynamicRangeFromMiddleSlice","middleSliceIndex","frameLength","bytesPerVoxel","frame","buffer","_getMinMax","newRange","viewportsContainingVolumeUID","properties","VolumeViewport","utilities","scaling","getPTScaledNewRange","deltaPointsCanvas","getNewRange","multiplier","_getMultiplierFromDynamicRange","wwDelta","wcDelta","imageDynamicRange","calculatedDynamicRange","getMiddleSliceData","pixel","metadataDynamicRange","_getImageDynamicRangeFromViewport","imageDataRange","voxel","WindowLevelRegionTool","minWindowWidth","addNewAnnotation","isDrawing","getReferencedImageId","annotation","highlighted","getToolName","handles","cachedStats","editData","_activateDraw","preventDefault","triggerAnnotationRenderForViewportIds","_endCallback","_deactivateDraw","applyWindowLevelRegion","topLeftCanvas","isInteractingWithTool","MOUSE_UP","MOUSE_DRAG","MOUSE_MOVE","MOUSE_CLICK","TOUCH_END","TOUCH_DRAG","TOUCH_TAP","renderAnnotation","renderStatus","annotations","filterInteractableAnnotationsForElement","styleSpecifier","getAnnotationStyle","windowLevel","startCanvas","endCanvas","pixelLuminanceData","minMaxMean","mean","isPointNearTool","toolSelectedCallback","handleSelectedCallback","_activateModify","_deactivateModify","StackScrollTool","debounceIfNotLoaded","deltaY","mouseWheelCallback","_scroll","_scrollDrag","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","wheel","offsetHeight","PlanarRotateTool","setAngle","startPoints","currentPointWorld","startPointWorld","centerCanvas","angleBetweenLines","cross","rotAngle","rotMat","rotatedViewUp","ZoomTool","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","pan","initialMousePosWorld","dirVec","preTouchStartCallback","_dragParallelProjection","pinch","deltaDistance","parallelScale","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","cappedParallelScale","thresholdExceeded","_dragPerspectiveProjection","zoomScale","directionOfProjection","tmp","_pinchCallback","currentPointsList","parallelProjection","_panCallback","MIPJumpToClickTool","targetViewportIds","mouseClickCallback","maxIntensity","brightestPoint","getPointInLineOfSightWithCriteria","intensity","foundToolGroup","getToolGroupForViewport","jumpToWorld","RENDERING_DEFAULTS","CONSTANTS","defaultReferenceLineColor","defaultReferenceLineControllable","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","OPERATION","CrosshairsTool","viewportIndicators","viewportIndicatorsConfig","autoPan","panSize","referenceLinesCenterGapRadius","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","mobile","toolCenter","initializeViewport","_getAnnotations","removeAnnotation","cameraPosition","cameraFocalPoint","rotationPoints","slabThicknessPoints","activeOperation","activeViewportIds","addAnnotation","resetCrosshairs","viewportInfo","resetPan","resetZoom","resetToCenter","resetRotation","resetSlabThickness","_computeToolCenter","computeToolCenter","firstViewport","secondViewport","thirdViewport","normal1","point1","normal2","point2","normal3","point3","jumpWorld","_jump","filteredAnnotations","viewportIdArray","otherViewport","viewportControllable","_getReferenceLineControllable","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","canvasCoords","proximity","_pointNearTool","interactionType","onCameraModified","viewportAnnotation","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","getViewportIds","_autoPanViewportIfNecessary","onResetCamera","mouseMoveCallback","filteredToolAnnotations","imageNeedsUpdate","isAnnotationLocked","previousActiveOperation","previousActiveViewportIds","near","getHandleNearImagePoint","_areViewportIdArraysEqual","viewportUIDSpecificCrosshairs","canvasDiagonalLength","canvasMinDimensionLength","crosshairCenterCanvas","otherViewportAnnotations","_filterAnnotationsByUniqueViewportOrientations","referenceLines","canvasBox","otherCamera","otherViewportControllable","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","pointWorld0","pointWorld1","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","centerGap","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","liangBarksyClip","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","matrix","worldUnitOrthoVectorFromCenter","slabThicknessValue","getSlabThickness","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportColor","_getReferenceLineColor","line","lineIndex","viewportSlabThicknessControlsOn","selectedViewportId","lineActive","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","handleUID","drawHandles","referenceColorCoordinates","xOffset","yOffset","circleRadius","drawCircle","getAnnotations","toolGroupAnnotations","_onNewVolume","viewportIdArrayOne","viewportIdArrayTwo","itemFound","_getAnnotationsForViewportsWithDifferentCameras","viewportsWithDifferentCameras","cameraOfTarget","_filterViewportWithSameOrientation","referenceAnnotation","linkedViewportAnnotations","otherViewportsAnnotationsWithSameCameraDirection","otherViewPlaneNormal","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_checkIfViewportsRenderingSameScene","volumeIds","getAllVolumeIds","otherVolumeIds","viewportsAnnotationsToUpdate","sameScene","_applyDeltaShiftToSelectedViewportCameras","dir1","dir2","finalPointCanvas","originalPointCanvas","_isClockWise","rotationAxis","buildFromRadian","otherViewportsIds","referenceAnnotations","viewportsIds","dotProd","projectedDelta","mod","currentPoint","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","getToolInstance","setSlabThickness","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineColor","getReferenceLineControllable","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","onSetToolPassive","onSetToolEnabled","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","toolCenterCanvas","visiblePointCanvas","visiblePointWorld","actorUIDs","blendModeToUse","COMPOSITE","setBlendMode","_applyDeltaShiftToViewportCamera","annotationCanvasCoordinate","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_hasBeenRemoved","_getReferencedImageId","_createMagnificationViewport","viewportProperties","canvasPos","magnifyToolElement","magnifyElement","classList","display","magnifyViewport","pow","_dragEndCallback","getTargetId","csEvents","isSegmentation","AdvancedMagnifyToolActions","PARALLEL_THRESHOLD","AdvancedMagnifyTool","Actions","magnifyingGlass","zoomFactor","zoomFactorList","actions","showZoomFactorsList","method","bindings","mouseButton","MouseBindings","Secondary","modifierKey","KeyboardBindings","Shift","canvasHandlePoints","_getCanvasHandlePoints","magnifyViewportId","sourceViewportId","isCanvasAnnotation","activeHandleIndex","magnifyViewportManager","createViewport","sourceEnabledElement","annotationPoints","canvasDelta","len","dispose","getAllAnnotations","canvasTop","canvasBottom","canvasLeft","radiusPoint","handleIndex","newAnnotation","_dragDrawCallback","hasMoved","_dragModifyCallback","_dragHandle","canvasCenter","currentCanvasPoints","newRadius","newCanvasHandlePoints","getStyle","activeHandleCanvasCoords","isAnnotationVisible","update","canvasCenterPos","canvasRadius","AdvancedMagnifyViewportManager","getInstance","currentZoomFactor","dropdown","_getZoomFactorsListDropdown","newZoomFactor","parentElement","focus","onChangeCallback","eventName","stopPropagation","keyCode","which","toLowerCase","option","label","title","defaultSelected","sourceViewport","sourceElement","AdvancedMagnifyViewport","_addSourceElementEventListener","_magnifyViewportsMap","magnifyViewportInfo","_annotationRemovedCallback","destroyViewport","_newStackImageCallback","magnifyViewportsMapEntries","_getMagnifyViewportsMapEntriesBySourceViewportId","stackActorReInitialized","_reset","_newVolumeImageCallback","currentViewPlaneNormal","worldImagePlanePoint","vecHandleToImagePlane","worldDist","worldDelta","_initialize","_singleton","_removeEventListeners","_destroyViewports","magnifyViewportMapEntry","_removeSourceElementEventListener","newEnabledElement","_addEventListeners","ANNOTATION_REMOVED","newStackHandler","VIEWPORT_NEW_IMAGE_SET","newVolumeHandler","_enabledElement","_sourceToolGroup","_magnifyToolGroup","_isViewportReady","_radius","_resized","_canAutoPan","_viewportId","_sourceEnabledElement","_autoPan","visible","_browserMouseDownCallback","_browserMouseUpCallback","_handleToolModeChanged","_mouseDragCallback","_resizeViewportAsync","debounce","_resizeViewport","_syncViewports","parentNode","magnifyToolGroup","mode","toolBindingsOptions","setToolActive","setToolPassive","setToolEnabled","Disabled","setToolDisabled","_inheritBorderRadius","borderRadius","_createViewportNode","overflow","boxSizing","_convertZoomFactorToParallelScale","offsetWidth","_isStackViewport","_isVolumeViewport","_cloneToolGroups","sourceActors","magnifyToolGroupId","sourceToolGroup","toolInstance","addViewport","addSegmentationRepresentations","segmentationId","SegmentationRepresentations","Labelmap","_cloneStack","_cloneVolumes","volumeInputArray","_cloneViewport","sourceViewportOptions","toolGroups","_cancelMouseEventCallback","closest","canvasCurrent","magnifyRadius","dist","distanceToPoint","maxDist","panDist","canvasDeltaPos","newCanvasPosition","currentWorldPos","newWorldPos","worldDeltaPos","autoPanCallbackData","currentPosition","_addBrowserEventListeners","_removeBrowserEventListeners","TOOL_MODE_CHANGED","sourceCanvas","_syncViewportsCameras","_syncStackViewports","setImageIdIndex","sourceProperties","resize","ReferenceLines","AnnotationDisplayTool","enforceSameFrameOfReference","showFullDimension","_init","getRenderingEngines","filterViewportsWithToolEnabled","sourceViewportCanvasCornersInWorld","onSetToolConfiguration","sourceViewPlaneNormal","isParallel","targetViewportPlane","pointSet1","pointSet2","pointSetToUse","topBottomVec","topRightVec","newNormal","isPerpendicular","lineStartWorld","lineEndWorld","handleFullDimension","vec1","vec2","targetImage","getTargetImageData","topLeftImageCoord","topRightImageCoord","bottomRightImageCoord","bottomLeftImageCoord","lineStartImageCoord","lineEndImageCoord","intersectInfiniteLines","isInBound","line1Start","line1End","line2Start","line2End","x3","y3","x4","y4","a1","b1","c1","a2","b2","c2","OverlayGridTool","sourceImageIds","pointSets","calculateImageIdPointSets","viewportData","imageIdNormal","getImageIdNormal","targetData","initializeViewportData","pointSetsToUse","lineStartsWorld","lineEndsWorld","SegmentationIntersectionTool","actorsWorldPointsMap","calculateSurfaceSegmentationIntersectionsForViewport","calculateSurfaceSegmentationIntersections","actorEntries","cacheId","getCacheId","clippingFilter","actorWorldPointMap","polyLineIdx","worldPointsSet","canvasPoints","polyLineUID","actorWorldPointsMap","polyData","getOutputData","polyDataUtils","colorArray","colorComponentToString","component","componentString","colorToString","getColor","pointToString","ReferenceCursors","preventHandleOutsideImage","displayThreshold","positionSync","disableCursor","isHandleOutsideImage","_elementWithCursor","_currentCursorWorldPosition","_currentCanvasPosition","_disableCursorEnabled","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","worldPosition","worldBoundingBox","previousCamera","oldFocalPoint","cameraNormal","dotProduct","isElementWithCursor","updateViewportImage","lineWidthBase","crosshairUIDs","centerSpace","lineLength","currentMousePosition","closestIndex","currentDistance","normalizedViewPlane","scaledPlaneNormal","renderViewport","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","viewportCanvasCornersInWorld","thisAnnotation","computeScaleSize","worldWidthViewport","worldHeightViewport","location","scaleSizes","currentScaleSize","scaleSize","computeEndScaleTicks","locationTickOffset","endTick1","endTick2","computeInnerScaleTicks","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","computeWorldScaleCoordinates","pointSet","worldCoordinates","midpointLocation","midpoint","computeCanvasScaleCoordinates","canvasSize","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","computeScaleBounds","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","scaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textCanvasCoordinates","textBoxLines","_getTextLines","drawTextBox","scaleSizeDisplayValue","scaleSizeUnits","SculptorTool","minSpacing","referencedToolNames","toolShape","referencedToolName","registeredShapes","isActive","commonData","activeAnnotationUID","isEditingOpenContour","canvasLocation","configureToolSize","selectFreehandTool","activateModify","updateCursor","endCallback","deactivateModify","activeAnnotation","filterSculptableAnnotationsForElement","calculateStats","dragCallback","sculpt","registerShapes","CircleSculptCursor","shapeName","setToolShape","shapeClass","shape","cursorShape","selectedShape","sculptData","mouseCanvasPoint","maxSpacing","getMaxSpacing","pushedHandles","pushHandles","first","insertNewHandles","interpolatePointsWithinMaxSpacing","indicesToInsertAfter","nextHandleIndex","currentCanvasPoint","nextCanvasPoint","updateToolSize","sculptableAnnotations","findNewHandleIndices","newIndexModifier","insertHandleRadially","previousIndex","nextIndex","handleData","getInsertPosition","closestAnnotationUID","getClosestFreehandToolOnElement","toolIndex","isLocked","isVisible","distanceFromTool","distancePointToContour","Default","renderShape","DIRECTIONS","VolumeRotateTool","cz","ax","ay","az","LengthTool","getTextLines","defaultGetTextLines","movingTextBox","canvasPoint1","canvasPoint2","worldPosDelta","unit","_throttledCalculateCachedStats","_calculateCachedStats","getLinkedTextBoxStyle","canvasTextBoxCoords","getTextBoxCoordsCanvas","drawLinkedTextBox","throttle","trailing","hydrate","autoGenerated","_calculateLength","pos1","pos2","worldPos1","worldPos2","targetIds","index1","index2","_isInsideVolume","cachedVolumeStats","HeightTool","_calculateHeight","outside","ProbeTool","eventDispatchDetail","getStackViewports","referencedImageURI","currentImageURI","pixelUnitsOptions","isViewportPreScaled","isSuvScaled","ijk","modalityUnit","getAtIJKPoint","calibratedResults","hasEnhancedRegionValues","units","getPixelValueUnits","DragProbeTool","postMouseDownCallback","postTouchStartCallback","EllipticalROITool","storePointData","centerPointRadius","statsCalculator","BasicStatsCalculator","initialRotation","getRotation","canvasCorners","getCanvasEllipseCorners","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","originalHandleCanvas","pointsCanvas","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","dYCanvas","newHalfCanvasWidth","canvasRight","dXCanvas","newHalfCanvasHeight","areaUnit","area","stdDev","centerPoint","_getCanvasEllipseCenter","pos1Index","post2Index","ellipseObj","xRadius","yRadius","zRadius","worldWidth","worldHeight","getWorldWidthAndHeightFromTwoPoints","isEmptyArea","statsCallback","isInObject","pointInEllipse","fast","getStatistics","statsArray","ellipse","ellipseCanvasPoints","areaLine","CircleROITool","canvasEnd","radiusUnit","perimeter","pos2Index","aspect","radiusLine","ETDRSGridTool","degrees","diameters","diametersCanvas","diameter","worldMeasureToCanvas","degreesRad","angleRadians","degree","measurement","p2","p1Canvas","p2Canvas","DEFAULT_SPLINE_CONFIG","resolution","controlPointAdditionDistance","controlPointDeletionDistance","showControlPointsConnectors","controlPointAdditionEnabled","controlPointDeletionEnabled","SplineTypesEnum","SplineToolActions","SplineROITool","ContourSegmentationBaseTool","SplineTypes","contourHoleAdditionModifierKey","epsilon","spline","Cardinal","Class","CardinalSpline","CatmullRom","CatmullRomSpline","Linear","LinearSpline","BSpline","drawPreviewEnabled","lastControlPointDeletionKeys","AddControlPoint","Primary","DeleteControlPoint","Ctrl","fireChangeOnUpdate","isPointNearCurve","contourHoleProcessingEnabled","changeType","Completed","HandlesUpdated","_keyDownCallback","controlPointIndex","_deleteControlPointByIndex","_mouseMoveCallback","lastCanvasPoint","_mouseDownCallback","doubleClick","MOUSE_DOUBLE_CLICK","closeContour","addNewPoint","closestControlPoint","getClosestControlPointWithinDistance","moveAnnotation","triggerAnnotationCompleted","eventType","ANNOTATION_COMPLETED","triggerAnnotationModified","StatsUpdated","ANNOTATION_MODIFIED","triggerChangeEvent","KEY_DOWN","MOUSE_DOWN","_renderStats","textboxStyle","addControlPointCallback","splineType","splineConfig","_getSplineConfig","closestPointInfo","getClosestPoint","addControlPointAtU","uValue","deleteControlPointCallback","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","canvasMaxX","maxY","canvasMaxY","canvasMinX","minY","canvasMinY","math","getAABB","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","getArea","getMouseModifier","event","createAnnotation","cancelAnnotation","isContourSegmentationTool","renderAnnotationInstance","renderContext","annotationStyle","controlPoints","locked","annotationLocked","childAnnotations","getChildAnnotations","childAnnotationUIDs","_isSplineROIAnnotation","splinePolylineCanvas","_updateSplineInstance","getPolylinePoints","updateContourPolyline","Clockwise","updateWindingDirection","numControlPoints","previewPolylinePoints","getPreviewPolylinePoints","controlPointsConnectors","textbox","createInterpolatedSplineControl","contourAnnotation","createSpline","onInterpolationComplete","splineConfigs","setControlPoints","fixedResolution","fixedScale","splineInstance","SplineClass","splinePolylineWorld","SplineContourSegmentationTool","LivewireContourTool","snapHandleNearby","nearestEdge","showInterpolationPolyline","undo","proximitySquared","startPoint","endPoint","lineSegment","distanceToPointSquared","clearAnnotation","clearEditData","worldToSlice","sliceToWorld","worldPosOriginal","currentPath","getControlPoints","closestHandlePoint","distSquared","worldControlPoint","canvasControlPoint","snapPoint","scissors","findMinNearby","pathPoints","findPathToPoint","addPoints","prependPath","confirmedPath","lastPoint","getLastPoint","addControlPoint","startSearch","updateAnnotation","imgWidth","imgHeight","slicePoint","editHandle","getCalibratedLengthUnitsAndScale","setupBaseEditData","nextPos","viewportImageData","sliceImageData","ijkPoint","startPos","LivewireScissors","createInstanceFromRawPixelData","scissorsNext","currentPathNext","confirmedPathNext","numHandles","previousHandle","nextHandle","findHandlePolylineIndex","slicePos","pathPointsLeft","pathPointsRight","appendPath","contourSegmentationAnnotation","canvasHandles","livewirePath","pointArray","imagePoints","LivewireContourSegmentationTool","updateInterpolatedAnnotation","interpolationSources","originalPolyline","queueMicrotask","repeatInterpolation","originalPoints","handleSmoothing","hIndex","testPoint","minPoint","acceptedPath","path","InterpolationUpdated","rendered","polylineCanvasPoints","ArrowAnnotateTool","getTextCallback","changeTextCallback","arrowFirst","touchTapCallback","taps","doubleClickCallback","clickedAnnotation","_doneChangingTextCallback","stopImmediatePropagation","updatedText","doneChangingTextCallback","prompt","AngleTool","angleStartedNotYetCompleted","line1","canvasPoint3","line2","worldPos3","String","fromCharCode","CobbAngleTool","showArcLines","distanceToLines","isNearFirstLine","isNearSecondLine","_mouseUpCallback","arc1Angle","arc2Angle","arc1Start","arc1End","arc2Start","arc2End","mid1","midPoint","mid2","arc1TextBoxUID","arc1TextLine","arch1TextPosCanvas","arc2TextBoxUID","arc2TextLine","arch2TextPosCanvas","point4","canvasPoint4","getArcsStartEndPoints","linkLine","arc1Side","arc2Side","midLinkLine","linkLineLength","midFirstLine","midSecondLine","directionVectorStartArc1","magnitudeStartArc1","normalizedDirectionStartArc1","directionVectorEndArc1","magnitudeEndArc1","normalizedDirectionEndArc1","directionVectorStartArc2","magnitudeStartArc2","normalizedDirectionStartArc2","directionVectorEndArc2","magnitudeEndArc2","normalizedDirectionEndArc2","seg1","seg2","minDist","MAX_VALUE","UltrasoundDirectionalTool","displayBothAxesDistances","startedDrawing","xValues","yValues","isHorizontal","isUnitless","drawHandle","canvasDeltaY","canvasDeltaX","projectedPointCanvas","imageIndex1","imageIndex2","values1","units1","values2","units2","dist1","dist2","KeyImageTool","canvasPosition","AnnotationEraserTool","_deleteNearbyAnnotations","toolGroup","tools","_toolInstances","annotationsToRemove","interactableAnnotations","setAnnotationSelected","RectangleScissorsTool","strategies","FILL_INSIDE","ERASE_INSIDE","defaultStrategy","activeStrategy","activeLabelmapSegmentation","activeSegmentation","segmentsLocked","segmentLocking","segmentColor","segmentation","representationData","getSegmentation","labelmapData","segmentationImageId","getCurrentLabelmapImageIdForViewport","operationData","applyActiveStrategy","toolMetadata","CircleScissorsTool","strategySpecificConfiguration","SphereScissorsTool","activeSegmentationRepresentation","CircleROIStartEndThresholdTool","numSlicesToPropagate","calculatePointsInsideVolume","showTextBox","spacingInNormal","startCoord","_getStartCoordinate","endCoord","_getEndCoordinate","startCoordinate","endCoordinate","pointsInVolume","projectionPoints","statistics","labelmapUID","_computeProjectionPoints","_computePointsInsideVolume","filterAnnotationsWithinSamePlane","viewplaneNormal","tempStartCoordinate","tempEndCoordinate","_getCoordinateForViewplaneNormal","roundedStartCoordinate","roundedEndCoordinate","cameraCoordinate","roundedCameraCoordinate","middleCoordinate","isMiddleSlice","_getIndexOfCoordinatesForViewplaneNormal","lineWidthToUse","lineDashToUse","_calculateCachedStatsTool","startIJK","endIJK","handlesToStart","startWorld","indexToWorldVec3","endWorld","newProjectionPoints","newPoint","pointsInsideVolume","measureInfo","modalityUnitOptions","worldPos1Index","worldProjectionPointIndex","indexOfProjection","worldPos2Index","numSlicesToPropagateFromStart","numSlicesToPropagateToEnd","endPos","viewplaneNormalAbs","pos","PaintFillTool","currentSegmentationImageId","fixedDimension","getFixedDimension","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","generateHelpers","clickedLabelValue","floodFillResult","floodFill","flooded","scalarDataIndex","setAtIndex","framesModified","getFramesModified","triggerSegmentationDataModified","boundaries","minJ","maxJ","seedIndex3D","getAtIJK","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","toIndex","getScalarDataPosition","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection","OverlayMarkerType","OrientationMarkerTool","CUBE","AXIS","VTPFILE","OVERLAY_MARKER_TYPES","orientationWidget","viewportCorner","Corners","BOTTOM_RIGHT","viewportSize","minPixelSize","maxPixelSize","overlayMarkerType","ANNOTATED_CUBE","overlayConfiguration","faceProperties","xPlus","faceColor","faceRotation","xMinus","yPlus","fontColor","yMinus","zPlus","zMinus","defaultStyle","fontStyle","fontSizeScale","res","edgeThickness","edgeColor","AXES","CUSTOM","polyDataURL","initViewports","_subscribeToViewportEvents","cleanUpData","orientationMarker","orientationMarkers","updateViewport","updatingOrientationMarker","unsubscribe","unobserve","setEnabled","offscreenMultiRenderWindow","getRenderWindow","widget","getWidget","isDeleted","addAxisActorInViewport","getRenderer","removeActor","createAnnotationCube","createCustomActor","renderer","renderWindow","interactor","getInteractor","parentRenderer","setViewportCorner","setViewportSize","setMinPixelSize","setMaxPixelSize","updateMarkerOrientation","addWidget","url","response","fetch","arrayBuffer","vtpReader","parseAsArrayBuffer","shallowCopy","setActiveScalars","setInputData","setColorModeToDirectScalars","setMapper","rotateZ","setDefaultStyle","setXPlusFaceProperty","setXMinusFaceProperty","setYPlusFaceProperty","setYMinusFaceProperty","setZPlusFaceProperty","setZMinusFaceProperty","createAnnotatedCubeActor","axes","annotatedCube","charAt","toUpperCase","SegmentSelectTool","SelectMode","Inside","Border","hoverTimeout","searchRadius","hoverTimer","clearTimeout","_setActiveSegment","getActiveSegmentation","_setActiveSegmentForType","hoveredSegmentIndex","getSegmentIndexAtWorldPoint","getSegmentIndexAtLabelmapBorder","Contour","getHoveredContourSegmentationAnnotation","setActiveSegmentIndex","triggerSegmentationModified","VideoRedactionTool","toolConfiguration","active","viewportUIDsToRender","toolDataCanvasCoordinate","rect","_getRectangleImageCoordinates","rectangle","point0","viewportUID","renderingEngineUID","sceneUID","targetUIDs","targetUID","_getImageVolumeFromTargetUID","worldToIndexVec3","valueMinusMean","_getTargetVolumeUID","scene","volumeUID","getVolumeActors","coloneIndex","_getTargetStackUID","annotationRenderingEngine","_needsRender","_animationFrameSet","_animationFrameHandle","_renderFlaggedViewports","_throwIfDestroyed","elements","_viewportElements","_triggerRender","_render","addViewportElement","removeViewportElement","_setViewportsToBeRenderedNextFrame","_setAllViewportsToBeRenderedNextFrame","elementsEnabled","requestAnimationFrame","enabledTools","draw","anyRendered","tool","ANNOTATION_RENDERED","cancelAnimationFrame","FrameOfReferenceSpecificAnnotationManager","getGroupKey","annotationGroupSelector","_imageVolumeModifiedHandler","frameOfReferenceSpecificAnnotations","getFramesOfReference","groupKey","getAnnotation","frameOfReferenceAnnotations","toolSpecificAnnotations","getNumberOfAnnotations","total","preprocessingFn","groupAnnotations","toolAnnotations","removeAnnotations","removedAnnotations","annotationsForTool","saveAnnotations","restoreAnnotations","getNumberOfAllAnnotations","removeAllAnnotations","IMAGE_VOLUME_MODIFIED","setPreprocessingFn","defaultFrameOfReferenceSpecificAnnotationManager","globalLockedAnnotationUIDsSet","setAnnotationLocked","makeEventDetail","lockedAnnotationUIDsSet","added","lock","unlock","publish","checkAndSetAnnotationLocked","freeze","removed","ANNOTATION_LOCK_CHANGE","selectedAnnotationUIDs","preserveSelected","clearSelectionSet","isSelected","selectAnnotation","deselectAnnotation","isAnnotationSelected","selection","selectionSet","ANNOTATION_SELECTION_CHANGE","defaultManager","getAnnotationManager","setAnnotationManager","annotationManager","resetAnnotationManager","manager","clearParentAnnotation","childUID","parentAnnotationUID","parentAnnotation","childUIDIndex","childAnnotation","parentUID","getParentAnnotation","childAnnotationUID","HTMLDivElement","annotationManagerUID","invalidateAnnotation","currAnnotation","checkAndSetAnnotationVisibility","globalHiddenAnnotationUIDsSet","setAnnotationVisibility","show","annotationUIDsSet","lastHidden","hide","lastVisible","hidden","ANNOTATION_VISIBILITY_CHANGE","_initializeConfig","colorHighlighted","colorSelected","colorLocked","textBoxVisibility","textBoxFontFamily","textBoxFontSize","textBoxColor","textBoxColorHighlighted","textBoxColorSelected","textBoxColorLocked","textBoxBackground","textBoxLinkLineWidth","textBoxLinkLineDash","textBoxShadow","getAnnotationToolStyles","getViewportToolStyles","getToolGroupToolStyles","getDefaultToolStyles","default","setAnnotationStyles","styles","annotationSpecificStyles","setViewportToolStyles","viewportSpecificStyles","setToolGroupToolStyles","toolGroupSpecificStyles","setDefaultToolStyles","toolStyle","specifications","_getToolStyle","annotationToolStyles","viewportToolStyles","global","toolGroupToolStyles","globalStyles","toolStyles","alternatives","getHierarchalPropertyStyles","Selected","Locked","AutoGenerated","triggerAnnotationAddedForElement","ANNOTATION_ADDED","triggerAnnotationAddedForFOR","getToolGroupsWithToolName","viewportsToRender","triggerAnnotationRemoved","_triggerAnnotationCompleted","triggerContourAnnotationCompleted","renderers","planarContourToolName","triggerSegmentationRender","segmentationRenderingEngine","renderSegmentationsForViewport","triggerSegmentationRenderBySegmentationId","renderSegmentation","_getAllViewports","_renderFlaggedSegmentations","_getViewportIdsForSegmentation","segmentationRepresentations","viewportRenderList","segmentationRenderList","representation","_addPlanarFreeHandToolIfAbsent","allSettled","segmentationDetails","status","onSegmentationRender","SEGMENTATION_RENDERED","hasTool","addTool","initialDefaultState","colorLUT","segmentations","viewportSegRepresentations","internalComputeVolumeLabelmapFromStack","segmentationImageIds","internalConvertStackToVolumeLabelmap","defaultSegmentationStateManager","getDefaultRenderingConfig","_stackLabelmapImageIdReferenceMap","getState","updateState","updater","newState","getColorLUT","lutIndex","getNextColorLUTIndex","resetState","updateSegmentation","draftState","addSegmentation","newSegmentation","getLabelmapImageIds","removeSegmentation","filteredSegmentations","triggerSegmentationRemoved","addSegmentationRepresentation","renderingConfig","getSegmentationRepresentations","setRenderInactiveSegmentations","addDefaultSegmentationRepresentation","addLabelmapRepresentation","triggerSegmentationRepresentationModified","segmentReps","segments","colorLUTIndex","_setActiveSegmentation","processLabelmapRepresentationAddition","isBaseVolumeSegmentation","updateLabelmapSegmentationImageReferences","_updateLabelmapSegmentationReferences","labelmapImageIds","updateCallback","viewableLabelmapImageIdFound","labelmapImageId","isReferenceViewable","asOverlay","_updateAllLabelmapSegmentationImageReferences","sliceIndex","withNavigation","getStackSegmentationImageIdsForViewport","associatedReferenceImageAndLabelmapImageIds","removeSegmentationRepresentationsInternal","specifier","removedRepresentations","currentRepresentations","activeRepresentationRemoved","shouldRemove","removeSegmentationRepresentations","triggerSegmentationRepresentationRemoved","remainingRepresentations","removeSegmentationRepresentation","suppressEvent","setActiveSegmentation","activeSegRep","segRep","viewportRepresentations","typeMatch","idMatch","getSegmentationRepresentation","getSegmentationRepresentationVisibility","viewportRepresentation","setSegmentationRepresentationVisibility","segment","addColorLUT","removeColorLUT","_getStackIdForImageIds","getAllViewportSegmentationRepresentations","representations","getSegmentationRepresentationsBySegmentationId","viewportReps","filteredReps","segmentationStyle","viewportsStyle","setStyle","currentStyles","updatedStyles","copyActiveToInactiveIfNotProvided","renderInactiveSegmentations","repConfig","perSegment","allSegments","ALL_SEGMENTATIONS_KEY","segConfig","processedStyles","labelmapStyles","renderOutlineInactive","renderOutline","outlineWidthInactive","outlineWidth","renderFillInactive","renderFill","fillAlphaInactive","fillAlpha","outlineOpacityInactive","outlineOpacity","contourStyles","outlineDashInactive","outlineDash","getDefaultStyle","allSegmentationsKey","getRenderInactiveSegmentations","clearSegmentationStyle","clearAllSegmentationStyles","clearViewportStyle","clearAllViewportStyles","resetToGlobalStyle","hasCustomStyle","segmentationStateManager","indexToUse","colorLUTToUse","missingColorLUTs","getColorLUTIndex","colorLUTOrIndex","parse","segmentationInputArray","segmentationInput","representationInput","internalAddSegmentationRepresentation","setColorLUT","colorLUTsIndex","segmentationRepresentation","getSegmentIndexColor","colorValue","setSegmentIndexColor","colorReference","modifiedSlicesToUse","SEGMENTATION_DATA_MODIFIED","getActiveSegmentIndex","activeSegmentIndex","getSegmentations","getViewportIdsWithSegmentation","viewportSegmentations","computeVolumeLabelmapFromStack","computeAndAddContourRepresentation","computeAndAddLabelmapRepresentation","computeAndAddSurfaceRepresentation","computeAndAddRepresentation","surfacesObj","indices","getUniqueSegmentIndices","geometryIds","promises","surfaceRepresentation","createAndCacheSurfacesFromRaw","updateSurfaceData","rawSurfacesData","rawSurfaceData","closedSurface","workerManager","triggerWorkerProgress","progress","WEB_WORKER_PROGRESS","WorkerTypes","POLYSEG_CONTOUR_TO_SURFACE","POLYSEG_LABELMAP_TO_SURFACE","computeSurfaceData","segmentIndices","contourRepresentationData","annotationUIDsMap","polylines","numPointsArray","annotationUIDs","convertContourToSurface","computeSurfaceFromContourSegmentation","computeSurfaceFromLabelmapSegmentation","labelmapRepresentationData","getCompleteScalarDataArray","convertLabelmapToSurface","surfaces","errors","Boolean","conversionPaths","canComputeRequestedRepresentation","existingRepresentationTypes","supportedTypes","representationType","representationTypeData","validateFn","getExistingRepresentationTypes","existingRepresentationType","fromRepresentationType","toRepresentationType","canConvertFromTo","computedRepresentations","computeFunction","updateFunction","onComputationComplete","debouncedUpdateFunction","_debouncedSegmentationModified","_debouncedUpdateFunction","subscribeToSegmentationChanges","isSegmentIndexLocked","setSegmentIndexLocked","getLockedSegmentIndices","re","toolGroupFilteredByIds","tg","s","MODES","toolOptions","toolGroupToolNames","ToolClass","toolClass","isMultiPartToolActive","synchronizers","BidirectionalTool","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","canvasCoordPoints","shortAxisDistFromCenter","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","dataId1","dataId2","secondLineUID","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos4","index3","index4","handles1","handles2","scale1","scale2","widthUnit","vector1","vector2","PlanarFreehandContourSegmentationTool","allowOpenContours","renderResult","pointCanProjectOnLine","PlanarFreehandROITool","alwaysRenderOpenContourHandles","closeContourProximity","checkCanvasEditFallbackProximity","makeClockWise","subPixelResolution","smoothing","smoothOnAdd","smoothOnEdit","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","displayOnePointAsCrosshairs","isEditingClosed","isEditingOpen","activateDraw","activateOpenContourEndEdit","activateClosedContourEdit","activateOpenContourEdit","previousPoint","pStart","pEnd","cancelDrawing","cancelOpenContourEdit","cancelClosedContourEdit","calibratedScale","updateClosedCachedStats","updateOpenCachedStats","annotationsToDisplay","filterAnnotationsWithinSlice","filterAnnotationsForDisplay","annotationsWithParallelNormals","td","annotationViewPlaneNormal","annotationsWithinSlice","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","renderContour","_calculateStatsIfActive","worldPosIndex","worldPosIndex2","iDelta","jDelta","kDelta","ceil","worldPosEnd","canvasPosEnd","curRow","intersections","intersectionCounter","_pointIJK","getLineSegmentIntersectionsCoordinates","shift","getPixelValueUnitunit","isFinite","RectangleROITool","arguments","onImageSpacingCalibrated","frameOfReference","BaseTool","initialProps","strategyOptions","applyActiveStrategyCallback","callbackType","setConfiguration","newConfiguration","setActiveStrategy","strategyName","getViewReferenceId","polySegConversionInProgress","contourRepresentation","removeRepresentation","renderImmediate","MAX_NUMBER_COLORS","labelMapConfigCache","_getLabelmapConfig","labelmapConfig","isActiveLabelmap","segmentsLabelmapConfig","configToUse","activeSegmentOutlineWidthDelta","_needsTransferFunctionUpdate","segmentsHidden","cacheUID","oldConfig","cfunMTime","getMTime","ofunMTime","forceOpacityUpdate","forceColorUpdate","oldFillAlpha","oldRenderFill","oldRenderOutline","oldOutlineWidth","oldSegmentColor","oldSegmentsHidden","oldCfunMTime","oldOfunMTime","_addLabelmapToViewport","labelmapActorEntry","labelmapStyle","numColors","segmentSpecificLabelmapConfig","segmentOpacity","removePoint","addPointLong","labelmapActor","setClamping","setInterpolationTypeToNearest","setUseLabelOutline","setLabelOutlineOpacity","outlineWidths","setLabelOutlineThickness","setVisibility","_setLabelmapColorAndOpacity","SurfaceData","BrushTool","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","THRESHOLD_INSIDE_CIRCLE","THRESHOLD_INSIDE_SPHERE","THRESHOLD","threshold","thresholdVolumeId","brushSize","preview","previewColors","previewTimeMs","previewMoveDistance","dragMoveDistance","dragTimeMs","AcceptPreview","RejectPreview","_previewData","timerStart","timer","NaN","isDrag","_editData","createEditData","hoverData","_hoverData","createHoverData","getOperationData","OnInteractionStart","time","rejectPreview","previewCallback","Preview","OnInteractionEnd","acceptPreview","CustomEvent","ERROR_EVENT","message","cancelable","dispatchEvent","actors","volumes","segmentationVolume","referencedVolumeIdToThreshold","override","getActiveSegmentationData","brushCursor","activeRepresentation","_calculateCursor","viewRight","centerCursorInWorld","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","strategy","computeInnerCircleRadius","invalidateBrushCursor","brushCursorUID","dynamicRadiusInCanvas","circleUID1","RectangleROIStartEndThresholdTool","computePointsInsideVolume","projectionPointsImageIds","roundedStartCoord","roundedEndCoord","coord","roundedCoord","firstOrLastSlice","habdles","projectionPoint","RectangleROIThresholdTool","ContourWindingDirection","getViewportsForAnnotation","sourcePoints","targetPoint","minDistance","MAX_SAFE_INTEGER","sourcePoint","_distanceBetween","cachedResult","keySet","addImageSegmentIndices","addVolumeSegmentIndices","handleLabelmapSegmentation","handleContourSegmentation","handleSurfaceSegmentation","getViewportsInfo","equalsCheck","getVoxelOverlap","voxelSpacing","voxelCenter","halfSpacingX","halfSpacingY","halfSpacingZ","voxelCornersIJK","offsets","xOff","yOff","zOff","processVolumes","thresholdVolumeInformation","segmentationSpacing","scalarDataLength","getScalarDataLength","volumeInfoList","baseVolumeIdx","volumeSize","segmentIndicesCache","setSegmentationDirty","cached","isDirty","getCachedSegmentIndices","setCachedSegmentIndices","extractCellSizes","cellArray","currentIdx","getNumberOfCells","cellId","cellArrayIndex","STATIC","publicAPI","model","initialValues","empty","UNSIGNED_INT","defaultValues","classHierarchy","superClass","recompute","numberOfCells","cellSizes","getCellSizes","requestedNumTuples","oldNumTuples","getNumberOfTuples","newNumTuples","setData","typedArray","getCell","loc","cellLoc","insertNextCell","cellPointIds","insertNextTuples","vtkCellArray","vtkCellArray$1","newInstance","m","DataTypeByteSize","Int8Array","Uint8ClampedArray","Int32Array","Uint32Array","Float64Array","VtkDataTypes","VOID","CHAR","SIGNED_CHAR","UNSIGNED_CHAR","UNSIGNED_CHAR_CLAMPED","SHORT","UNSIGNED_SHORT","INT","FLOAT","DOUBLE","Constants","DefaultDataType","DesiredOutputPrecision","DEFAULT","SINGLE","AttributeCopyOperations","COPYTUPLE","INTERPOLATE","PASSDATA","ALLCOPY","AttributeLimitTypes","MAX","EXACT","NOLIMIT","AttributeTypes","SCALARS","VECTORS","NORMALS","TCOORDS","TENSORS","GLOBALIDS","PEDIGREEIDS","EDGEFLAG","NUM_ATTRIBUTES","CellGhostTypes","DUPLICATECELL","HIGHCONNECTIVITYCELL","LOWCONNECTIVITYCELL","REFINEDCELL","EXTERIORCELL","HIDDENCELL","PointGhostTypes","DUPLICATEPOINT","HIDDENPOINT","ghostArrayName","vtkErrorMacro","DEFAULT_VALUES","extent","dataDescription","EMPTY","setGetArray","getArray","setExtent","deleted","_len","inExtent","_key","extentArray","changeDetected","setDimensions","dims","nCells","getNumberOfPoints","SINGLE_POINT","X_LINE","Y_LINE","Z_LINE","XY_PLANE","YZ_PLANE","XZ_PLANE","XYZ_GRID","coords","getBounds","getSpatialExtent","ex","computeTransforms","ain","aout","indexToWorldBounds","bin","bout","worldToIndexBounds","onModified","getCenter","computeHistogram","worldBounds","voxelFunction","yStride","zStride","pixels","maximum","minimum","sumOfSquares","isum","inum","average","variance","sigma","computeIncrements","increments","incr","idx","computeOffsetIndex","_ref","getNumberOfComponents","getOffsetIndexFromWorld","getScalarValueFromWorld","offsetIndex","getComponent","vtkImageData$1","HASH_UNDEFINED","INFINITY","funcTag","genTag","symbolTag","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","reIsHostCtor","freeGlobal","freeSelf","self","Function","arrayProto","funcProto","objectProto","coreJsData","maskSrcKey","IE_PROTO","funcToString","objectToString","reIsNative","RegExp","replace","getNative","nativeCreate","symbolProto","symbolToString","Hash","entry","ListCache","MapCache","assocIndexOf","other","baseGet","object","isSymbol","isKey","stringToPath","toKey","baseIsNative","isObject","pattern","isFunction","isHostObject","toSource","getMapData","__data__","getValue","memoize","string","baseToString","match","number","quote","resolver","TypeError","memoized","Cache","isObjectLike","module","exports","proxyMarker","createEndpoint","releaseProxy","finalizer","throwMarker","transferHandlers","canHandle","serialize","port1","port2","MessageChannel","expose","deserialize","port","wrap","serialized","isError","stack","ep","globalThis","allowedOrigins","ev","allowedOrigin","isAllowedOrigin","argumentList","fromWireValue","returnValue","parent","prop","rawValue","proxy","transfers","transferCache","transfer","wireValue","transferables","toWireValue","postMessage","closeEndPoint","endpoint","isMessagePort","close","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","unregister","unregisterProxy","_thisArg","rawArgumentList","processArguments","construct","register","registerProxy","processed","arr","handler","serializedValue","msg","l","zip","transpose","valueof","interpolator","samples"],"sourceRoot":""}